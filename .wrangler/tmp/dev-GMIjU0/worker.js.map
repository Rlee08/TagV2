{
  "version": 3,
  "sources": ["../bundle-I8Zm2U/checked-fetch.js", "wrangler-modules-watch:wrangler:modules-watch", "../../../node_modules/wrangler/templates/modules-watch-stub.js", "../../../node_modules/lodash.throttle/index.js", "../../../node_modules/lodash.uniq/index.js", "../../../node_modules/lodash.isequal/index.js", "../bundle-I8Zm2U/middleware-loader.entry.ts", "../bundle-I8Zm2U/middleware-insertion-facade.js", "../../../worker/worker.ts", "../../../node_modules/cloudflare-workers-unfurl/unfurl.js", "../../../node_modules/src/src/IttyRouter.ts", "../../../node_modules/src/src/Router.ts", "../../../node_modules/src/src/createResponse.ts", "../../../node_modules/src/src/json.ts", "../../../node_modules/src/src/error.ts", "../../../node_modules/src/src/withParams.ts", "../../../node_modules/src/src/AutoRouter.ts", "../../../node_modules/src/src/StatusError.ts", "../../../node_modules/src/src/status.ts", "../../../node_modules/src/src/text.ts", "../../../node_modules/src/src/html.ts", "../../../node_modules/src/src/jpeg.ts", "../../../node_modules/src/src/png.ts", "../../../node_modules/src/src/webp.ts", "../../../node_modules/src/src/withContent.ts", "../../../node_modules/src/src/withCookies.ts", "../../../node_modules/src/src/cors.ts", "../../../worker/assetUploads.ts", "../../../worker/TldrawDurableObject.ts", "../../../node_modules/@tldraw/sync-core/src/index.ts", "../../../node_modules/@tldraw/utils/src/index.ts", "../../../node_modules/@tldraw/utils/src/lib/version.ts", "../../../node_modules/@tldraw/utils/src/lib/PerformanceTracker.ts", "../../../node_modules/@tldraw/utils/src/lib/perf.ts", "../../../node_modules/@tldraw/utils/src/lib/array.ts", "../../../node_modules/@tldraw/utils/src/lib/bind.ts", "../../../node_modules/@tldraw/utils/src/lib/control.ts", "../../../node_modules/@tldraw/utils/src/lib/function.ts", "../../../node_modules/@tldraw/utils/src/lib/cache.ts", "../../../node_modules/@tldraw/utils/src/lib/debounce.ts", "../../../node_modules/@tldraw/utils/src/lib/error.ts", "../../../node_modules/@tldraw/utils/src/lib/file.ts", "../../../node_modules/@tldraw/utils/src/lib/network.ts", "../../../node_modules/@tldraw/utils/src/lib/hash.ts", "../../../node_modules/@tldraw/utils/src/lib/id.ts", "../../../node_modules/@tldraw/utils/src/lib/iterable.ts", "../../../node_modules/@tldraw/utils/src/lib/media/media.ts", "../../../node_modules/@tldraw/utils/src/lib/media/apng.ts", "../../../node_modules/@tldraw/utils/src/lib/media/avif.ts", "../../../node_modules/@tldraw/utils/src/lib/media/gif.ts", "../../../node_modules/@tldraw/utils/src/lib/media/png.ts", "../../../node_modules/@tldraw/utils/src/lib/media/webp.ts", "../../../node_modules/@tldraw/utils/src/lib/number.ts", "../../../node_modules/@tldraw/utils/src/lib/object.ts", "../../../node_modules/@tldraw/utils/src/lib/reordering.ts", "../../../node_modules/fractional-indexing-jittered/lib/index.js", "../../../node_modules/@tldraw/utils/src/lib/sort.ts", "../../../node_modules/@tldraw/utils/src/lib/storage.tsx", "../../../node_modules/@tldraw/utils/src/lib/throttle.ts", "../../../node_modules/@tldraw/utils/src/lib/timers.ts", "../../../node_modules/@tldraw/utils/src/lib/url.ts", "../../../node_modules/@tldraw/utils/src/lib/value.ts", "../../../node_modules/@tldraw/utils/src/lib/warn.ts", "../../../node_modules/@tldraw/sync-core/src/lib/ClientWebSocketAdapter.ts", "../../../node_modules/@tldraw/state/src/index.ts", "../../../node_modules/@tldraw/state/src/lib/helpers.ts", "../../../node_modules/@tldraw/state/src/lib/ArraySet.ts", "../../../node_modules/@tldraw/state/src/lib/Atom.ts", "../../../node_modules/@tldraw/state/src/lib/HistoryBuffer.ts", "../../../node_modules/@tldraw/state/src/lib/types.ts", "../../../node_modules/@tldraw/state/src/lib/capture.ts", "../../../node_modules/@tldraw/state/src/lib/transactions.ts", "../../../node_modules/@tldraw/state/src/lib/EffectScheduler.ts", "../../../node_modules/@tldraw/state/src/lib/constants.ts", "../../../node_modules/@tldraw/state/src/lib/Computed.ts", "../../../node_modules/@tldraw/state/src/lib/warnings.ts", "../../../node_modules/@tldraw/state/src/lib/isSignal.ts", "../../../node_modules/@tldraw/sync-core/src/lib/chunk.ts", "../../../node_modules/@tldraw/sync-core/src/lib/TLSyncClient.ts", "../../../node_modules/@tldraw/store/src/index.ts", "../../../node_modules/@tldraw/store/src/lib/IncrementalSetConstructor.ts", "../../../node_modules/@tldraw/store/src/lib/RecordType.ts", "../../../node_modules/@tldraw/store/src/lib/RecordsDiff.ts", "../../../node_modules/@tldraw/store/src/lib/Store.ts", "../../../node_modules/@tldraw/store/src/lib/StoreQueries.ts", "../../../node_modules/@tldraw/store/src/lib/executeQuery.ts", "../../../node_modules/@tldraw/store/src/lib/setUtils.ts", "../../../node_modules/@tldraw/store/src/lib/StoreSideEffects.ts", "../../../node_modules/@tldraw/store/src/lib/devFreeze.ts", "../../../node_modules/@tldraw/store/src/lib/StoreSchema.ts", "../../../node_modules/@tldraw/store/src/lib/migrate.ts", "../../../node_modules/@tldraw/sync-core/src/lib/diff.ts", "../../../node_modules/@tldraw/sync-core/src/lib/interval.ts", "../../../node_modules/@tldraw/sync-core/src/lib/protocol.ts", "../../../node_modules/@tldraw/sync-core/src/lib/RoomSession.ts", "../../../node_modules/@tldraw/sync-core/src/lib/TLRemoteSyncError.ts", "../../../node_modules/@tldraw/sync-core/src/lib/TLSocketRoom.ts", "../../../node_modules/@tldraw/tlschema/src/index.ts", "../../../node_modules/@tldraw/tlschema/src/assets/TLBaseAsset.ts", "../../../node_modules/@tldraw/validate/src/index.ts", "../../../node_modules/@tldraw/validate/src/lib/validation.ts", "../../../node_modules/@tldraw/tlschema/src/misc/id-validator.ts", "../../../node_modules/@tldraw/tlschema/src/bindings/TLArrowBinding.ts", "../../../node_modules/@tldraw/tlschema/src/misc/geometry-types.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLBinding.ts", "../../../node_modules/@tldraw/tlschema/src/bindings/TLBaseBinding.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLBaseShape.ts", "../../../node_modules/@tldraw/tlschema/src/misc/TLOpacity.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLArrowShape.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLShape.ts", "../../../node_modules/@tldraw/tlschema/src/styles/StyleProp.ts", "../../../node_modules/@tldraw/tlschema/src/recordsWithProps.ts", "../../../node_modules/@tldraw/tlschema/src/styles/TLColorStyle.ts", "../../../node_modules/@tldraw/tlschema/src/styles/TLDashStyle.ts", "../../../node_modules/@tldraw/tlschema/src/styles/TLFillStyle.ts", "../../../node_modules/@tldraw/tlschema/src/styles/TLFontStyle.ts", "../../../node_modules/@tldraw/tlschema/src/styles/TLSizeStyle.ts", "../../../node_modules/@tldraw/tlschema/src/createPresenceStateDerivation.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLCamera.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLInstance.ts", "../../../node_modules/@tldraw/tlschema/src/misc/TLCursor.ts", "../../../node_modules/@tldraw/tlschema/src/misc/TLScribble.ts", "../../../node_modules/@tldraw/tlschema/src/misc/TLColor.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLPage.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLPageState.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLPointer.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLPresence.ts", "../../../node_modules/@tldraw/tlschema/src/createTLSchema.ts", "../../../node_modules/@tldraw/tlschema/src/TLStore.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLDocument.ts", "../../../node_modules/@tldraw/tlschema/src/assets/TLBookmarkAsset.ts", "../../../node_modules/@tldraw/tlschema/src/assets/TLImageAsset.ts", "../../../node_modules/@tldraw/tlschema/src/assets/TLVideoAsset.ts", "../../../node_modules/@tldraw/tlschema/src/records/TLAsset.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLBookmarkShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLDrawShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLEmbedShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLFrameShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLGeoShape.ts", "../../../node_modules/@tldraw/tlschema/src/styles/TLHorizontalAlignStyle.ts", "../../../node_modules/@tldraw/tlschema/src/styles/TLVerticalAlignStyle.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLGroupShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLHighlightShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLImageShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLLineShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLNoteShape.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLTextShape.ts", "../../../node_modules/@tldraw/tlschema/src/styles/TLTextAlignStyle.ts", "../../../node_modules/@tldraw/tlschema/src/shapes/TLVideoShape.ts", "../../../node_modules/@tldraw/tlschema/src/store-migrations.ts", "../../../node_modules/@tldraw/tlschema/src/misc/TLHandle.ts", "../../../node_modules/@tldraw/tlschema/src/translations/translations.ts", "../../../node_modules/@tldraw/tlschema/src/translations/languages.ts", "../../../node_modules/@tldraw/sync-core/src/lib/ServerSocketAdapter.ts", "../../../node_modules/@tldraw/sync-core/src/lib/TLSyncRoom.ts", "../../../node_modules/nanoevents/index.js", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "C:\\Users\\ryant\\Documents\\Ai-Midterm\\Prototype3\\TagV2\\.wrangler\\tmp\\dev-GMIjU0",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "", "// `esbuild` doesn't support returning `watch*` options from `onStart()`\n// plugin callbacks. Instead, we define an empty virtual module that is\n// imported by this injected file. Importing the module registers watchers.\nimport \"wrangler:modules-watch\";\n", "/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n", "/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array ? array.length : 0;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * Checks if a cache value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    Set = getNative(root, 'Set'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each\n * element is kept.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length)\n    ? baseUniq(array)\n    : [];\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = uniq;\n", "/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"C:\\\\Users\\\\ryant\\\\Documents\\\\Ai-Midterm\\\\Prototype3\\\\TagV2\\\\.wrangler\\\\tmp\\\\bundle-I8Zm2U\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"C:\\\\Users\\\\ryant\\\\Documents\\\\Ai-Midterm\\\\Prototype3\\\\TagV2\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"C:\\\\Users\\\\ryant\\\\Documents\\\\Ai-Midterm\\\\Prototype3\\\\TagV2\\\\.wrangler\\\\tmp\\\\bundle-I8Zm2U\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"C:\\\\Users\\\\ryant\\\\Documents\\\\Ai-Midterm\\\\Prototype3\\\\TagV2\\\\.wrangler\\\\tmp\\\\bundle-I8Zm2U\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"C:\\\\Users\\\\ryant\\\\Documents\\\\Ai-Midterm\\\\Prototype3\\\\TagV2\\\\worker\\\\worker.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"C:\\\\Users\\\\ryant\\\\Documents\\\\Ai-Midterm\\\\Prototype3\\\\TagV2\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"C:\\\\Users\\\\ryant\\\\Documents\\\\Ai-Midterm\\\\Prototype3\\\\TagV2\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"C:\\\\Users\\\\ryant\\\\Documents\\\\Ai-Midterm\\\\Prototype3\\\\TagV2\\\\worker\\\\worker.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "import { handleUnfurlRequest } from 'cloudflare-workers-unfurl'\nimport { AutoRouter, cors, error, IRequest } from 'itty-router'\nimport { handleAssetDownload, handleAssetUpload } from './assetUploads'\nimport { Environment } from './types'\n\n// make sure our sync durable object is made available to cloudflare\nexport { TldrawDurableObject } from './TldrawDurableObject'\n\n// we use itty-router (https://itty.dev/) to handle routing. in this example we turn on CORS because\n// we're hosting the worker separately to the client. you should restrict this to your own domain.\nconst { preflight, corsify } = cors({ origin: '*' })\nconst router = AutoRouter<IRequest, [env: Environment, ctx: ExecutionContext]>({\n\tbefore: [preflight],\n\tfinally: [corsify],\n\tcatch: (e) => {\n\t\tconsole.error(e)\n\t\treturn error(e)\n\t},\n})\n\t// requests to /connect are routed to the Durable Object, and handle realtime websocket syncing\n\t.get('/connect/:roomId', (request, env) => {\n\t\tconst id = env.TLDRAW_DURABLE_OBJECT.idFromName(request.params.roomId)\n\t\tconst room = env.TLDRAW_DURABLE_OBJECT.get(id)\n\t\treturn room.fetch(request.url, { headers: request.headers, body: request.body })\n\t})\n\n\t// assets can be uploaded to the bucket under /uploads:\n\t.post('/uploads/:uploadId', handleAssetUpload)\n\n\t// they can be retrieved from the bucket too:\n\t.get('/uploads/:uploadId', handleAssetDownload)\n\n\t// bookmarks need to extract metadata from pasted URLs:\n\t.get('/unfurl', handleUnfurlRequest)\n\n// export our router for cloudflare\nexport default router\n", "/**\n * @template Value\n * @typedef {Object} GoodResult\n * @property {true} ok - The success status.\n * @property {Value} value - The data extracted from the URL.\n */\n\n/**\n * @template Error\n * @typedef {Object} BadResult\n * @property {false} ok - The success status.\n * @property {Error} error - The error\n */\n\n/**\n * @template Value, Error\n * @typedef {GoodResult<Value> | BadResult<Error>} Result\n */\n\n/**\n * @typedef {Object} UnfurledData\n * @property {string} [title] - The title extracted from the URL.\n * @property {string} [description] - The description extracted from the URL.\n * @property {string} [image] - The image URL extracted from the URL.\n * @property {string} [favicon] - The favicon URL extracted from the URL.\n */\n\n/**\n * @typedef {'bad-param' | 'failed-fetch'} UnfurlError\n */\n\nconst validContentTypes = [\n  \"text/html\",\n  \"application/xhtml+xml\",\n  \"application/xml\",\n  \"image/*\",\n];\n\n/**\n *\n * @param {string} contentType\n * @returns {boolean}\n */\nfunction isValidContentType(contentType) {\n  return (\n    // allow unspecified, try to parse it anyway\n    !contentType ||\n    contentType.startsWith(\"image/\") ||\n    validContentTypes.some((valid) => contentType.startsWith(valid))\n  );\n}\n\n/**\n * Handles the unfurling of a URL by extracting metadata such as title, description, image, and favicon.\n * @param {string} url - The URL to unfurl.\n * @returns {Promise<Result<UnfurledData, UnfurlError>>} - A promise that resolves to an object containing the extracted metadata, or null if an error occurs.\n */\nexport async function unfurl(url) {\n  if (typeof url !== \"string\" || !url.match(/^https?:\\/\\//)) {\n    return { ok: false, error: \"bad-param\" };\n  }\n\n  // cloudflare has a built-in HTML parser/rewriter called HTMLRewriter. in order to use it, we\n  // need to define classes that act as event handlers for certain elements, attributes, etc.\n  // see https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/\n  const meta$ = new MetaExtractor();\n  const title$ = new TextExtractor();\n  const icon$ = new IconExtractor();\n\n  try {\n    const headers = new Headers();\n    for (const contentType of validContentTypes) {\n      headers.append(\"accept\", contentType);\n    }\n    const res = await fetch(url, { headers });\n    if (!res.ok || !isValidContentType(res.headers.get(\"content-type\") ?? \"\")) {\n      return { ok: false, error: \"failed-fetch\" };\n    }\n    if (res.headers.get(\"content-type\")?.startsWith(\"image/\")) {\n      return {\n        ok: true,\n        value: {\n          image: url,\n          title: new URL(url).pathname.split(\"/\").pop() || undefined,\n        },\n      };\n    }\n    await new HTMLRewriter()\n      .on(\"meta\", meta$)\n      .on(\"title\", title$)\n      .on(\"link\", icon$)\n      .transform(res)\n      .blob();\n  } catch {\n    return { ok: false, error: \"failed-fetch\" };\n  }\n\n  // we don't know exactly what we'll end up with, so this is a best-effort extraction\n  const { og, twitter } = meta$;\n  const title =\n    og[\"og:title\"] ?? twitter[\"twitter:title\"] ?? title$.string ?? undefined;\n  const description =\n    og[\"og:description\"] ??\n    twitter[\"twitter:description\"] ??\n    meta$.description ??\n    undefined;\n  let image =\n    og[\"og:image:secure_url\"] ??\n    og[\"og:image\"] ??\n    twitter[\"twitter:image\"] ??\n    undefined;\n  let favicon = icon$.appleIcon ?? icon$.icon ?? undefined;\n\n  if (image && !image?.startsWith(\"http\")) {\n    image = new URL(image, url).href;\n  }\n  if (favicon && !favicon?.startsWith(\"http\")) {\n    favicon = new URL(favicon, url).href;\n  }\n\n  return {\n    ok: true,\n    value: {\n      title,\n      description,\n      image,\n      favicon,\n    },\n  };\n}\n\n/**\n * Implements a handler for a GET request where the uri is passed in as a search param called `url`.\n *\n * e.g. GET /foo/bar?url=https://example.com\n *\n * @param {Request} request\n * @returns {Promise<Response>}\n */\nexport async function handleUnfurlRequest(request) {\n  const url = new URL(request.url).searchParams.get(\"url\");\n\n  if (!url) {\n    return new Response(\"Missing URL query parameter.\", { status: 400 });\n  }\n\n  const result = await unfurl(url);\n\n  if (result.ok) {\n    return new Response(JSON.stringify(result.value), {\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  } else if (result.error === \"bad-param\") {\n    return new Response(\"Bad URL query parameter.\", { status: 400 });\n  } else {\n    return new Response(\"Failed to fetch URL.\", { status: 422 });\n  }\n}\n\n/**\n * Extracts text from HTML elements.\n */\nclass TextExtractor {\n  /**\n   * The accumulated text extracted from elements.\n   * @type {string}\n   */\n  string = \"\";\n\n  /**\n   * Handles an incoming piece of text.\n   * @param {Object} param - The text object.\n   * @param {string} param.text - The incoming text.\n   */\n  text({ text }) {\n    this.string += text;\n  }\n}\n\n/**\n * Extracts metadata from HTML elements.\n */\nclass MetaExtractor {\n  /**\n   * The Open Graph (og) metadata extracted from elements.\n   * @type {Object.<string, string|null>}\n   */\n  og = {};\n\n  /**\n   * The Twitter metadata extracted from elements.\n   * @type {Object.<string, string|null>}\n   */\n  twitter = {};\n\n  /**\n   * The description extracted from elements.\n   * @type {string|null}\n   */\n  description = null;\n\n  /**\n   * Handles an incoming element.\n   * @param {Element} element - The incoming element.\n   */\n  element(element) {\n    const property = element.getAttribute(\"property\");\n    const name = element.getAttribute(\"name\");\n\n    if (property && property.startsWith(\"og:\")) {\n      this.og[property] = element.getAttribute(\"content\");\n    } else if (name && name.startsWith(\"twitter:\")) {\n      this.twitter[name] = element.getAttribute(\"content\");\n    } else if (name === \"description\") {\n      this.description = element.getAttribute(\"content\");\n    }\n  }\n}\n\n/**\n * Extracts favicon URLs from HTML elements.\n */\nclass IconExtractor {\n  /**\n   * The Apple touch icon URL extracted from elements.\n   * @type {string|null}\n   */\n  appleIcon = null;\n\n  /**\n   * The favicon URL extracted from elements.\n   * @type {string|null}\n   */\n  icon = null;\n\n  /**\n   * Handles an incoming element.\n   * @param {Element} element - The incoming element.\n   */\n  element(element) {\n    if (element.getAttribute(\"rel\") === \"icon\") {\n      this.icon = element.getAttribute(\"href\");\n    } else if (element.getAttribute(\"rel\") === \"apple-touch-icon\") {\n      this.appleIcon = element.getAttribute(\"href\");\n    }\n  }\n}\n", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "import { IRequest, error } from 'itty-router'\nimport { Environment } from './types'\n\n// assets are stored in the bucket under the /uploads path\nfunction getAssetObjectName(uploadId: string) {\n\treturn `uploads/${uploadId.replace(/[^a-zA-Z0-9\\_\\-]+/g, '_')}`\n}\n\n// when a user uploads an asset, we store it in the bucket. we only allow image and video assets.\nexport async function handleAssetUpload(request: IRequest, env: Environment) {\n\tconst objectName = getAssetObjectName(request.params.uploadId)\n\n\tconst contentType = request.headers.get('content-type') ?? ''\n\tif (!contentType.startsWith('image/') && !contentType.startsWith('video/')) {\n\t\treturn error(400, 'Invalid content type')\n\t}\n\n\tif (await env.TLDRAW_BUCKET.head(objectName)) {\n\t\treturn error(409, 'Upload already exists')\n\t}\n\n\tawait env.TLDRAW_BUCKET.put(objectName, request.body, {\n\t\thttpMetadata: request.headers,\n\t})\n\n\treturn { ok: true }\n}\n\n// when a user downloads an asset, we retrieve it from the bucket. we also cache the response for performance.\nexport async function handleAssetDownload(\n\trequest: IRequest,\n\tenv: Environment,\n\tctx: ExecutionContext\n) {\n\tconst objectName = getAssetObjectName(request.params.uploadId)\n\n\t// if we have a cached response for this request (automatically handling ranges etc.), return it\n\tconst cacheKey = new Request(request.url, { headers: request.headers })\n\tconst cachedResponse = await caches.default.match(cacheKey)\n\tif (cachedResponse) {\n\t\treturn cachedResponse\n\t}\n\n\t// if not, we try to fetch the asset from the bucket\n\tconst object = await env.TLDRAW_BUCKET.get(objectName, {\n\t\trange: request.headers,\n\t\tonlyIf: request.headers,\n\t})\n\n\tif (!object) {\n\t\treturn error(404)\n\t}\n\n\t// write the relevant metadata to the response headers\n\tconst headers = new Headers()\n\tobject.writeHttpMetadata(headers)\n\n\t// assets are immutable, so we can cache them basically forever:\n\theaders.set('cache-control', 'public, max-age=31536000, immutable')\n\theaders.set('etag', object.httpEtag)\n\n\t// we set CORS headers so all clients can access assets. we do this here so our `cors` helper in\n\t// worker.ts doesn't try to set extra cors headers on responses that have been read from the\n\t// cache, which isn't allowed by cloudflare.\n\theaders.set('access-control-allow-origin', '*')\n\n\t// cloudflare doesn't set the content-range header automatically in writeHttpMetadata, so we\n\t// need to do it ourselves.\n\tlet contentRange\n\tif (object.range) {\n\t\tif ('suffix' in object.range) {\n\t\t\tconst start = object.size - object.range.suffix\n\t\t\tconst end = object.size - 1\n\t\t\tcontentRange = `bytes ${start}-${end}/${object.size}`\n\t\t} else {\n\t\t\tconst start = object.range.offset ?? 0\n\t\t\tconst end = object.range.length ? start + object.range.length - 1 : object.size - 1\n\t\t\tif (start !== 0 || end !== object.size - 1) {\n\t\t\t\tcontentRange = `bytes ${start}-${end}/${object.size}`\n\t\t\t}\n\t\t}\n\t}\n\n\tif (contentRange) {\n\t\theaders.set('content-range', contentRange)\n\t}\n\n\t// make sure we get the correct body/status for the response\n\tconst body = 'body' in object && object.body ? object.body : null\n\tconst status = body ? (contentRange ? 206 : 200) : 304\n\n\t// we only cache complete (200) responses\n\tif (status === 200) {\n\t\tconst [cacheBody, responseBody] = body!.tee()\n\t\tctx.waitUntil(caches.default.put(cacheKey, new Response(cacheBody, { headers, status })))\n\t\treturn new Response(responseBody, { headers, status })\n\t}\n\n\treturn new Response(body, { headers, status })\n}\n", "import { RoomSnapshot, TLSocketRoom } from '@tldraw/sync-core'\nimport {\n\tTLRecord,\n\tcreateTLSchema,\n\t// defaultBindingSchemas,\n\tdefaultShapeSchemas,\n} from '@tldraw/tlschema'\nimport { AutoRouter, IRequest, error } from 'itty-router'\nimport throttle from 'lodash.throttle'\nimport { Environment } from './types'\n\n// add custom shapes and bindings here if needed:\nconst schema = createTLSchema({\n\tshapes: { ...defaultShapeSchemas },\n\t// bindings: { ...defaultBindingSchemas },\n})\n\n// each whiteboard room is hosted in a DurableObject:\n// https://developers.cloudflare.com/durable-objects/\n\n// there's only ever one durable object instance per room. it keeps all the room state in memory and\n// handles websocket connections. periodically, it persists the room state to the R2 bucket.\nexport class TldrawDurableObject {\n\tprivate r2: R2Bucket\n\t// the room ID will be missing while the room is being initialized\n\tprivate roomId: string | null = null\n\t// when we load the room from the R2 bucket, we keep it here. it's a promise so we only ever\n\t// load it once.\n\tprivate roomPromise: Promise<TLSocketRoom<TLRecord, void>> | null = null\n\n\tconstructor(\n\t\tprivate readonly ctx: DurableObjectState,\n\t\tenv: Environment\n\t) {\n\t\tthis.r2 = env.TLDRAW_BUCKET\n\n\t\tctx.blockConcurrencyWhile(async () => {\n\t\t\tthis.roomId = ((await this.ctx.storage.get('roomId')) ?? null) as string | null\n\t\t})\n\t}\n\n\tprivate readonly router = AutoRouter({\n\t\tcatch: (e) => {\n\t\t\tconsole.log(e)\n\t\t\treturn error(e)\n\t\t},\n\t})\n\t\t// when we get a connection request, we stash the room id if needed and handle the connection\n\t\t.get('/connect/:roomId', async (request) => {\n\t\t\tif (!this.roomId) {\n\t\t\t\tawait this.ctx.blockConcurrencyWhile(async () => {\n\t\t\t\t\tawait this.ctx.storage.put('roomId', request.params.roomId)\n\t\t\t\t\tthis.roomId = request.params.roomId\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn this.handleConnect(request)\n\t\t})\n\n\t// `fetch` is the entry point for all requests to the Durable Object\n\tfetch(request: Request): Response | Promise<Response> {\n\t\treturn this.router.fetch(request)\n\t}\n\n\t// what happens when someone tries to connect to this room?\n\tasync handleConnect(request: IRequest): Promise<Response> {\n\t\t// extract query params from request\n\t\tconst sessionId = request.query.sessionId as string\n\t\tif (!sessionId) return error(400, 'Missing sessionId')\n\n\t\t// Create the websocket pair for the client\n\t\tconst { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair()\n\t\tserverWebSocket.accept()\n\n\t\t// load the room, or retrieve it if it's already loaded\n\t\tconst room = await this.getRoom()\n\n\t\t// connect the client to the room\n\t\troom.handleSocketConnect({ sessionId, socket: serverWebSocket })\n\n\t\t// return the websocket connection to the client\n\t\treturn new Response(null, { status: 101, webSocket: clientWebSocket })\n\t}\n\n\tgetRoom() {\n\t\tconst roomId = this.roomId\n\t\tif (!roomId) throw new Error('Missing roomId')\n\n\t\tif (!this.roomPromise) {\n\t\t\tthis.roomPromise = (async () => {\n\t\t\t\t// fetch the room from R2\n\t\t\t\tconst roomFromBucket = await this.r2.get(`rooms/${roomId}`)\n\n\t\t\t\t// if it doesn't exist, we'll just create a new empty room\n\t\t\t\tconst initialSnapshot = roomFromBucket\n\t\t\t\t\t? ((await roomFromBucket.json()) as RoomSnapshot)\n\t\t\t\t\t: undefined\n\n\t\t\t\t// create a new TLSocketRoom. This handles all the sync protocol & websocket connections.\n\t\t\t\t// it's up to us to persist the room state to R2 when needed though.\n\t\t\t\treturn new TLSocketRoom<TLRecord, void>({\n\t\t\t\t\tschema,\n\t\t\t\t\tinitialSnapshot,\n\t\t\t\t\tonDataChange: () => {\n\t\t\t\t\t\t// and persist whenever the data in the room changes\n\t\t\t\t\t\tthis.schedulePersistToR2()\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t})()\n\t\t}\n\n\t\treturn this.roomPromise\n\t}\n\n\t// we throttle persistance so it only happens every 10 seconds\n\tschedulePersistToR2 = throttle(async () => {\n\t\tif (!this.roomPromise || !this.roomId) return\n\t\tconst room = await this.getRoom()\n\n\t\t// convert the room to JSON and upload it to R2\n\t\tconst snapshot = JSON.stringify(room.getCurrentSnapshot())\n\t\tawait this.r2.put(`rooms/${this.roomId}`, snapshot)\n\t}, 10_000)\n}\n", "import { registerTldrawLibraryVersion } from '@tldraw/utils'\nexport { ClientWebSocketAdapter, ReconnectManager } from './lib/ClientWebSocketAdapter'\nexport { RoomSessionState, type RoomSession } from './lib/RoomSession'\nexport type { WebSocketMinimal } from './lib/ServerSocketAdapter'\nexport { TLRemoteSyncError } from './lib/TLRemoteSyncError'\nexport { TLSocketRoom, type OmitVoid, type TLSyncLog } from './lib/TLSocketRoom'\nexport {\n\tTLSyncClient,\n\tTLSyncErrorCloseEventCode,\n\tTLSyncErrorCloseEventReason,\n\ttype SubscribingFn,\n\ttype TLPersistentClientSocket,\n\ttype TLPersistentClientSocketStatus,\n\ttype TLSocketStatusListener,\n\ttype TlSocketStatusChangeEvent,\n} from './lib/TLSyncClient'\nexport {\n\tDocumentState,\n\tTLSyncRoom,\n\ttype RoomSnapshot,\n\ttype RoomStoreMethods,\n\ttype TLRoomSocket,\n} from './lib/TLSyncRoom'\nexport { chunk } from './lib/chunk'\nexport {\n\tRecordOpType,\n\tValueOpType,\n\tapplyObjectDiff,\n\tdiffRecord,\n\tgetNetworkDiff,\n\ttype AppendOp,\n\ttype DeleteOp,\n\ttype NetworkDiff,\n\ttype ObjectDiff,\n\ttype PatchOp,\n\ttype PutOp,\n\ttype RecordOp,\n\ttype ValueOp,\n} from './lib/diff'\nexport {\n\t// eslint-disable-next-line deprecation/deprecation\n\tTLIncompatibilityReason,\n\tgetTlsyncProtocolVersion,\n\ttype TLConnectRequest,\n\ttype TLPingRequest,\n\ttype TLPushRequest,\n\ttype TLSocketClientSentEvent,\n\ttype TLSocketServerSentDataEvent,\n\ttype TLSocketServerSentEvent,\n} from './lib/protocol'\nexport type { PersistedRoomSnapshotForSupabase } from './lib/server-types'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n", "import { registerTldrawLibraryVersion } from './lib/version'\n\nexport { default as throttle } from 'lodash.throttle'\nexport { default as uniq } from 'lodash.uniq'\nexport { PerformanceTracker } from './lib/PerformanceTracker'\nexport {\n\tareArraysShallowEqual,\n\tcompact,\n\tdedupe,\n\tlast,\n\tminBy,\n\tpartition,\n\trotateArray,\n} from './lib/array'\nexport { bind } from './lib/bind'\nexport { WeakCache } from './lib/cache'\nexport {\n\tResult,\n\tassert,\n\tassertExists,\n\texhaustiveSwitchError,\n\tpromiseWithResolve,\n\tsleep,\n\ttype ErrorResult,\n\ttype OkResult,\n} from './lib/control'\nexport { debounce } from './lib/debounce'\nexport { annotateError, getErrorAnnotations, type ErrorAnnotations } from './lib/error'\nexport { FileHelpers } from './lib/file'\nexport { noop, omitFromStackTrace } from './lib/function'\nexport { getHashForBuffer, getHashForObject, getHashForString, lns } from './lib/hash'\nexport { mockUniqueId, restoreUniqueId, uniqueId } from './lib/id'\nexport { getFirstFromIterable } from './lib/iterable'\nexport type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from './lib/json-value'\nexport {\n\tDEFAULT_SUPPORTED_IMAGE_TYPES,\n\tDEFAULT_SUPPORTED_MEDIA_TYPE_LIST,\n\tDEFAULT_SUPPORT_VIDEO_TYPES,\n\tMediaHelpers,\n} from './lib/media/media'\nexport { PngHelpers } from './lib/media/png'\nexport { Image, fetch } from './lib/network'\nexport { invLerp, lerp, modulate, rng } from './lib/number'\nexport {\n\tareObjectsShallowEqual,\n\tfilterEntries,\n\tgetOwnProperty,\n\tgroupBy,\n\thasOwnProperty,\n\tmapObjectMapValues,\n\tobjectMapEntries,\n\tobjectMapFromEntries,\n\tobjectMapKeys,\n\tobjectMapValues,\n} from './lib/object'\nexport { measureAverageDuration, measureCbDuration, measureDuration } from './lib/perf'\nexport {\n\tZERO_INDEX_KEY,\n\tgetIndexAbove,\n\tgetIndexBelow,\n\tgetIndexBetween,\n\tgetIndices,\n\tgetIndicesAbove,\n\tgetIndicesBelow,\n\tgetIndicesBetween,\n\tsortByIndex,\n\tvalidateIndexKey,\n\ttype IndexKey,\n} from './lib/reordering'\nexport { sortById } from './lib/sort'\nexport {\n\tclearLocalStorage,\n\tclearSessionStorage,\n\tdeleteFromLocalStorage,\n\tdeleteFromSessionStorage,\n\tgetFromLocalStorage,\n\tgetFromSessionStorage,\n\tsetInLocalStorage,\n\tsetInSessionStorage,\n} from './lib/storage'\nexport { fpsThrottle, throttleToNextFrame } from './lib/throttle'\nexport { Timers } from './lib/timers'\nexport type { Expand, RecursivePartial, Required } from './lib/types'\nexport { safeParseUrl } from './lib/url'\nexport {\n\tSTRUCTURED_CLONE_OBJECT_PROTOTYPE,\n\tisDefined,\n\tisNativeStructuredClone,\n\tisNonNull,\n\tisNonNullish,\n\tstructuredClone,\n} from './lib/value'\nexport { registerTldrawLibraryVersion } from './lib/version'\nexport { warnDeprecatedGetter, warnOnce } from './lib/warn'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n", "interface TldrawLibraryVersion {\n\tname: string\n\tversion: string\n\tmodules: string\n}\n\ninterface TldrawLibraryVersionInfo {\n\tversions: TldrawLibraryVersion[]\n\tdidWarn: boolean\n\tscheduledNotice: number | NodeJS.Timeout | null\n}\n\nconst TLDRAW_LIBRARY_VERSION_KEY = '__TLDRAW_LIBRARY_VERSIONS__' as const\n\n// eslint-disable-next-line @typescript-eslint/prefer-namespace-keyword, @typescript-eslint/no-namespace\ndeclare module globalThis {\n\texport const __TLDRAW_LIBRARY_VERSIONS__: TldrawLibraryVersionInfo\n}\n\nfunction getLibraryVersions(): TldrawLibraryVersionInfo {\n\tif (globalThis[TLDRAW_LIBRARY_VERSION_KEY]) {\n\t\treturn globalThis[TLDRAW_LIBRARY_VERSION_KEY]\n\t}\n\n\tconst info: TldrawLibraryVersionInfo = {\n\t\tversions: [],\n\t\tdidWarn: false,\n\t\tscheduledNotice: null,\n\t}\n\n\tObject.defineProperty(globalThis, TLDRAW_LIBRARY_VERSION_KEY, {\n\t\tvalue: info,\n\t\twritable: false,\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t})\n\n\treturn info\n}\n\nexport function clearRegisteredVersionsForTests() {\n\tconst info = getLibraryVersions()\n\tinfo.versions = []\n\tinfo.didWarn = false\n\tif (info.scheduledNotice) {\n\t\tclearTimeout(info.scheduledNotice)\n\t\tinfo.scheduledNotice = null\n\t}\n}\n\n/** @internal */\nexport function registerTldrawLibraryVersion(name?: string, version?: string, modules?: string) {\n\tif (!name || !version || !modules) {\n\t\tif ((globalThis as any).TLDRAW_LIBRARY_IS_BUILD) {\n\t\t\tthrow new Error('Missing name/version/module system in built version of tldraw library')\n\t\t}\n\t\treturn\n\t}\n\n\tconst info = getLibraryVersions()\n\tinfo.versions.push({ name, version, modules })\n\n\tif (!info.scheduledNotice) {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\tinfo.scheduledNotice = setTimeout(() => {\n\t\t\t\tinfo.scheduledNotice = null\n\t\t\t\tcheckLibraryVersions(info)\n\t\t\t}, 100)\n\t\t} catch {\n\t\t\t// some environments (e.g. cloudflare workers) don't support setTimeout immediately, only in a handler.\n\t\t\t// in this case, we'll just check immediately.\n\t\t\tcheckLibraryVersions(info)\n\t\t}\n\t}\n}\n\nfunction checkLibraryVersions(info: TldrawLibraryVersionInfo) {\n\tif (!info.versions.length) return\n\tif (info.didWarn) return\n\n\tconst sorted = info.versions.sort((a, b) => compareVersions(a.version, b.version))\n\tconst latestVersion = sorted[sorted.length - 1].version\n\n\tconst matchingVersions = new Set<string>()\n\tconst nonMatchingVersions = new Map<string, Set<string>>()\n\tfor (const lib of sorted) {\n\t\tif (nonMatchingVersions.has(lib.name)) {\n\t\t\tmatchingVersions.delete(lib.name)\n\t\t\tentry(nonMatchingVersions, lib.name, new Set()).add(lib.version)\n\t\t\tcontinue\n\t\t}\n\n\t\tif (lib.version === latestVersion) {\n\t\t\tmatchingVersions.add(lib.name)\n\t\t} else {\n\t\t\tmatchingVersions.delete(lib.name)\n\t\t\tentry(nonMatchingVersions, lib.name, new Set()).add(lib.version)\n\t\t}\n\t}\n\n\tif (nonMatchingVersions.size > 0) {\n\t\tconst message = [\n\t\t\t`${format('[tldraw]', ['bold', 'bgRed', 'textWhite'])} ${format('You have multiple versions of tldraw libraries installed. This can lead to bugs and unexpected behavior.', ['textRed', 'bold'])}`,\n\t\t\t'',\n\t\t\t`The latest version you have installed is ${format(`v${latestVersion}`, ['bold', 'textBlue'])}. The following libraries are on the latest version:`,\n\t\t\t...Array.from(matchingVersions, (name) => `  \u2022 \u2705 ${format(name, ['bold'])}`),\n\t\t\t'',\n\t\t\t`The following libraries are not on the latest version, or have multiple versions installed:`,\n\t\t\t...Array.from(nonMatchingVersions, ([name, versions]) => {\n\t\t\t\tconst sortedVersions = Array.from(versions)\n\t\t\t\t\t.sort(compareVersions)\n\t\t\t\t\t.map((v) => format(`v${v}`, v === latestVersion ? ['textGreen'] : ['textRed']))\n\t\t\t\treturn `  \u2022 \u274C ${format(name, ['bold'])} (${sortedVersions.join(', ')})`\n\t\t\t}),\n\t\t]\n\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(message.join('\\n'))\n\t\tinfo.didWarn = true\n\t\treturn\n\t}\n\n\t// at this point, we know that everything has the same version. there may still be duplicates though!\n\tconst potentialDuplicates = new Map<string, { version: string; modules: string[] }>()\n\tfor (const lib of sorted) {\n\t\tentry(potentialDuplicates, lib.name, { version: lib.version, modules: [] }).modules.push(\n\t\t\tlib.modules\n\t\t)\n\t}\n\n\tconst duplicates = new Map<string, { version: string; modules: string[] }>()\n\tfor (const [name, lib] of potentialDuplicates) {\n\t\tif (lib.modules.length > 1) duplicates.set(name, lib)\n\t}\n\n\tif (duplicates.size > 0) {\n\t\tconst message = [\n\t\t\t`${format('[tldraw]', ['bold', 'bgRed', 'textWhite'])} ${format('You have multiple instances of some tldraw libraries active. This can lead to bugs and unexpected behavior. ', ['textRed', 'bold'])}`,\n\t\t\t'',\n\t\t\t'This usually means that your bundler is misconfigured, and is importing the same library multiple times - usually once as an ES Module, and once as a CommonJS module.',\n\t\t\t'',\n\t\t\t'The following libraries have been imported multiple times:',\n\t\t\t...Array.from(duplicates, ([name, lib]) => {\n\t\t\t\tconst modules = lib.modules\n\t\t\t\t\t.map((m, i) => (m === 'esm' ? `      ${i + 1}. ES Modules` : `      ${i + 1}. CommonJS`))\n\t\t\t\t\t.join('\\n')\n\t\t\t\treturn `  \u2022 \u274C ${format(name, ['bold'])} v${lib.version}: \\n${modules}`\n\t\t\t}),\n\t\t\t'',\n\t\t\t'You should configure your bundler to only import one version of each library.',\n\t\t]\n\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(message.join('\\n'))\n\t\tinfo.didWarn = true\n\t\treturn\n\t}\n}\n\nfunction compareVersions(a: string, b: string) {\n\tconst aMatch = a.match(/^(\\d+)\\.(\\d+)\\.(\\d+)(?:-(\\w+))?$/)\n\tconst bMatch = b.match(/^(\\d+)\\.(\\d+)\\.(\\d+)(?:-(\\w+))?$/)\n\n\tif (!aMatch || !bMatch) return a.localeCompare(b)\n\tif (aMatch[1] !== bMatch[1]) return Number(aMatch[1]) - Number(bMatch[1])\n\tif (aMatch[2] !== bMatch[2]) return Number(aMatch[2]) - Number(bMatch[2])\n\tif (aMatch[3] !== bMatch[3]) return Number(aMatch[3]) - Number(bMatch[3])\n\tif (aMatch[4] && bMatch[4]) return aMatch[4].localeCompare(bMatch[4])\n\tif (aMatch[4]) return 1\n\tif (bMatch[4]) return -1\n\treturn 0\n}\n\nconst formats = {\n\tbold: '1',\n\ttextBlue: '94',\n\ttextRed: '31',\n\ttextGreen: '32',\n\tbgRed: '41',\n\ttextWhite: '97',\n} as const\nfunction format(value: string, formatters: (keyof typeof formats)[] = []) {\n\treturn `\\x1B[${formatters.map((f) => formats[f]).join(';')}m${value}\\x1B[m`\n}\n\nfunction entry<K, V>(map: Map<K, V>, key: K, defaultValue: V): V {\n\tif (map.has(key)) {\n\t\treturn map.get(key)!\n\t}\n\tmap.set(key, defaultValue)\n\treturn defaultValue\n}\n", "import { PERFORMANCE_COLORS, PERFORMANCE_PREFIX_COLOR } from './perf'\n\n/** @public */\nexport class PerformanceTracker {\n\tprivate startTime = 0\n\tprivate name = ''\n\tprivate frames = 0\n\tprivate started = false\n\tprivate frame: number | null = null\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\trecordFrame = () => {\n\t\tthis.frames++\n\t\tif (!this.started) return\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tthis.frame = requestAnimationFrame(this.recordFrame)\n\t}\n\n\tstart(name: string) {\n\t\tthis.name = name\n\t\tthis.frames = 0\n\t\tthis.started = true\n\t\tif (this.frame !== null) cancelAnimationFrame(this.frame)\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tthis.frame = requestAnimationFrame(this.recordFrame)\n\t\tthis.startTime = performance.now()\n\t}\n\n\tstop() {\n\t\tthis.started = false\n\t\tif (this.frame !== null) cancelAnimationFrame(this.frame)\n\t\tconst duration = (performance.now() - this.startTime) / 1000\n\t\tconst fps = duration === 0 ? 0 : Math.floor(this.frames / duration)\n\t\tconst background =\n\t\t\tfps > 55\n\t\t\t\t? PERFORMANCE_COLORS.Good\n\t\t\t\t: fps > 30\n\t\t\t\t\t? PERFORMANCE_COLORS.Mid\n\t\t\t\t\t: PERFORMANCE_COLORS.Poor\n\t\tconst color = background === PERFORMANCE_COLORS.Mid ? 'black' : 'white'\n\t\tconst capitalized = this.name[0].toUpperCase() + this.name.slice(1)\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.debug(\n\t\t\t`%cPerf%c ${capitalized} %c${fps}%c fps`,\n\t\t\t`color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,\n\t\t\t'font-weight: normal',\n\t\t\t`font-weight: bold; padding: 2px; background: ${background};color: ${color};`,\n\t\t\t'font-weight: normal'\n\t\t)\n\t}\n\n\tisStarted() {\n\t\treturn this.started\n\t}\n}\n", "export const PERFORMANCE_COLORS = {\n\tGood: '#40C057',\n\tMid: '#FFC078',\n\tPoor: '#E03131',\n}\n\nexport const PERFORMANCE_PREFIX_COLOR = PERFORMANCE_COLORS.Good\n\n/** @internal */\nexport function measureCbDuration(name: string, cb: () => any) {\n\tconst start = performance.now()\n\tconst result = cb()\n\t// eslint-disable-next-line no-console\n\tconsole.debug(\n\t\t`%cPerf%c ${name} took ${performance.now() - start}ms`,\n\t\t`color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,\n\t\t'font-weight: normal'\n\t)\n\treturn result\n}\n\n/** @internal */\nexport function measureDuration(_target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n\tconst originalMethod = descriptor.value\n\tdescriptor.value = function (...args: any[]) {\n\t\tconst start = performance.now()\n\t\tconst result = originalMethod.apply(this, args)\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.debug(\n\t\t\t`%cPerf%c ${propertyKey} took: ${performance.now() - start}ms`,\n\t\t\t`color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,\n\t\t\t'font-weight: normal'\n\t\t)\n\t\treturn result\n\t}\n\treturn descriptor\n}\n\nconst averages = new Map<any, { total: number; count: number }>()\n\n/** @internal */\nexport function measureAverageDuration(\n\t_target: any,\n\tpropertyKey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.value\n\tdescriptor.value = function (...args: any[]) {\n\t\tconst start = performance.now()\n\t\tconst result = originalMethod.apply(this, args)\n\t\tconst end = performance.now()\n\t\tconst length = end - start\n\t\tif (length !== 0) {\n\t\t\tconst value = averages.get(descriptor.value)!\n\t\t\tconst total = value.total + length\n\t\t\tconst count = value.count + 1\n\t\t\taverages.set(descriptor.value, { total, count })\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.debug(\n\t\t\t\t`%cPerf%c ${propertyKey} took ${(end - start).toFixed(2)}ms | average ${(total / count).toFixed(2)}ms`,\n\t\t\t\t`color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,\n\t\t\t\t'font-weight: normal'\n\t\t\t)\n\t\t}\n\t\treturn result\n\t}\n\taverages.set(descriptor.value, { total: 0, count: 0 })\n\treturn descriptor\n}\n", "/**\n * Rotate the contents of an array.\n *\n * @public\n */\nexport function rotateArray<T>(arr: T[], offset: number): T[] {\n\treturn arr.map((_, i) => arr[(i + offset) % arr.length])\n}\n\n/**\n * Deduplicate the items in an array\n *\n * @public\n */\nexport function dedupe<T>(input: T[], equals?: (a: any, b: any) => boolean): T[] {\n\tconst result: T[] = []\n\tmainLoop: for (const item of input) {\n\t\tfor (const existing of result) {\n\t\t\tif (equals ? equals(item, existing) : item === existing) {\n\t\t\t\tcontinue mainLoop\n\t\t\t}\n\t\t}\n\t\tresult.push(item)\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function compact<T>(arr: T[]): NonNullable<T>[] {\n\treturn arr.filter((i) => i !== undefined && i !== null) as any\n}\n\n/** @internal */\nexport function last<T>(arr: readonly T[]): T | undefined {\n\treturn arr[arr.length - 1]\n}\n\n/** @internal */\nexport function minBy<T>(arr: readonly T[], fn: (item: T) => number): T | undefined {\n\tlet min: T | undefined\n\tlet minVal = Infinity\n\tfor (const item of arr) {\n\t\tconst val = fn(item)\n\t\tif (val < minVal) {\n\t\t\tmin = item\n\t\t\tminVal = val\n\t\t}\n\t}\n\treturn min\n}\n\n/**\n * Partitions an array into two arrays, one with items that satisfy the predicate, and one with\n * items that do not.\n *\n * @param arr - The array to partition\n * @param predicate - The predicate to use to partition the array\n * @returns A tuple of two arrays, the first one with items that satisfy the predicate and the\n *   second one with the ones that dont\n * @internal\n */\nexport function partition<T>(arr: T[], predicate: (item: T) => boolean): [T[], T[]] {\n\tconst satisfies: T[] = []\n\tconst doesNotSatisfy: T[] = []\n\tfor (const item of arr) {\n\t\tif (predicate(item)) {\n\t\t\tsatisfies.push(item)\n\t\t} else {\n\t\t\tdoesNotSatisfy.push(item)\n\t\t}\n\t}\n\treturn [satisfies, doesNotSatisfy]\n}\n\n/** @internal */\nexport function areArraysShallowEqual<T>(arr1: readonly T[], arr2: readonly T[]): boolean {\n\tif (arr1 === arr2) return true\n\tif (arr1.length !== arr2.length) return false\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (!Object.is(arr1[i], arr2[i])) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "// MIT License: https://github.com/NoHomey/bind-decorator/blob/master/License\n// Copyright (c) 2016 Ivo Stratev\n\nimport { assert } from './control'\n\n/**\n * `@bind` is a decorator that binds the method to the instance of the class (legacy stage-2\n * typescript decorators).\n *\n * @public\n */\nexport function bind<T extends (...args: any[]) => any>(\n\ttarget: object,\n\tpropertyKey: string,\n\tdescriptor: TypedPropertyDescriptor<T>\n): TypedPropertyDescriptor<T>\n\n/**\n * `@bind` is a decorator that binds the method to the instance of the class (TC39 decorators).\n *\n * @public\n */\nexport function bind<This extends object, T extends (...args: any[]) => any>(\n\toriginalMethod: T,\n\tcontext: ClassMethodDecoratorContext<This, T>\n): void\n\n/** @public */\nexport function bind(\n\t...args: // legacy stage-2 typescript decorators\n\t| [_target: object, propertyKey: string, descriptor: PropertyDescriptor]\n\t\t// TC39 decorators\n\t\t| [originalMethod: (...args: any[]) => any, context: ClassMemberDecoratorContext]\n): PropertyDescriptor | void {\n\tif (args.length === 2) {\n\t\tconst [originalMethod, context] = args\n\t\tcontext.addInitializer(function initializeMethod(this: any) {\n\t\t\tassert(Reflect.isExtensible(this), 'Cannot bind to a non-extensible class.')\n\t\t\tconst value = originalMethod.bind(this)\n\t\t\tconst ok = Reflect.defineProperty(this, context.name, {\n\t\t\t\tvalue,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t})\n\t\t\tassert(ok, 'Cannot bind a non-configurable class method.')\n\t\t})\n\t} else {\n\t\tconst [_target, propertyKey, descriptor] = args\n\t\tif (!descriptor || typeof descriptor.value !== 'function') {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Only methods can be decorated with @bind. <${propertyKey}> is not a method!`\n\t\t\t)\n\t\t}\n\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tget(this: any): any {\n\t\t\t\tconst bound = descriptor.value!.bind(this)\n\t\t\t\t// Credits to https://github.com/andreypopp/autobind-decorator for memoizing the result of bind against a symbol on the instance.\n\t\t\t\tObject.defineProperty(this, propertyKey, {\n\t\t\t\t\tvalue: bound,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t})\n\t\t\t\treturn bound\n\t\t\t},\n\t\t}\n\t}\n}\n", "import { omitFromStackTrace } from './function'\n\n/** @public */\nexport interface OkResult<T> {\n\treadonly ok: true\n\treadonly value: T\n}\n/** @public */\nexport interface ErrorResult<E> {\n\treadonly ok: false\n\treadonly error: E\n}\n/** @public */\nexport type Result<T, E> = OkResult<T> | ErrorResult<E>\n\n/** @public */\nexport const Result = {\n\tok<T>(value: T): OkResult<T> {\n\t\treturn { ok: true, value }\n\t},\n\terr<E>(error: E): ErrorResult<E> {\n\t\treturn { ok: false, error }\n\t},\n}\n\n/** @internal */\nexport function exhaustiveSwitchError(value: never, property?: string): never {\n\tconst debugValue =\n\t\tproperty && value && typeof value === 'object' && property in value ? value[property] : value\n\tthrow new Error(`Unknown switch case ${debugValue}`)\n}\n\n/** @internal */\nexport const assert: (value: unknown, message?: string) => asserts value = omitFromStackTrace(\n\t(value, message) => {\n\t\tif (!value) {\n\t\t\tthrow new Error(message || 'Assertion Error')\n\t\t}\n\t}\n)\n\n/** @internal */\nexport const assertExists = omitFromStackTrace(<T>(value: T, message?: string): NonNullable<T> => {\n\t// note that value == null is equivalent to value === null || value === undefined\n\tif (value == null) {\n\t\tthrow new Error(message ?? 'value must be defined')\n\t}\n\treturn value as NonNullable<T>\n})\n\n/** @internal */\nexport function promiseWithResolve<T>(): Promise<T> & {\n\tresolve(value: T): void\n\treject(reason?: any): void\n} {\n\tlet resolve: (value: T) => void\n\tlet reject: (reason?: any) => void\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res\n\t\treject = rej\n\t})\n\treturn Object.assign(promise, {\n\t\tresolve: resolve!,\n\t\treject: reject!,\n\t})\n}\n\n/** @internal */\nexport function sleep(ms: number): Promise<void> {\n\t// eslint-disable-next-line no-restricted-globals\n\treturn new Promise((resolve) => setTimeout(resolve, ms))\n}\n", "/**\n * When a function is wrapped in `omitFromStackTrace`, if it throws an error the stack trace won't\n * include the function itself or any stack frames above it. Useful for assertion-style function\n * where the error will ideally originate from the call-site rather than within the implementation\n * of the assert fn.\n *\n * Only works in platforms that support `Error.captureStackTrace` (ie v8).\n *\n * @internal\n */\nexport function omitFromStackTrace<Args extends Array<unknown>, Return>(\n\tfn: (...args: Args) => Return\n): (...args: Args) => Return {\n\tconst wrappedFn = (...args: Args) => {\n\t\ttry {\n\t\t\treturn fn(...args)\n\t\t} catch (error) {\n\t\t\tif (error instanceof Error && Error.captureStackTrace) {\n\t\t\t\tError.captureStackTrace(error, wrappedFn)\n\t\t\t}\n\t\t\tthrow error\n\t\t}\n\t}\n\n\treturn wrappedFn\n}\n\n/**\n * Does nothing, but it's really really good at it.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop: () => void = () => {}\n", "/**\n * A micro cache used when storing records in memory (using a WeakMap).\n * @public\n */\nexport class WeakCache<K extends object, V> {\n\t/** The map of items to their cached values. */\n\titems = new WeakMap<K, V>()\n\n\t/**\n\t * Get the cached value for a given record. If the record is not present in the map, the callback\n\t * will be used to create the value (with the result being stored in the cache for next time).\n\t *\n\t * @param item - The item to get.\n\t * @param cb - The callback to use to create the value when a cached value is not found.\n\t */\n\tget<P extends K>(item: P, cb: (item: P) => V) {\n\t\tif (!this.items.has(item)) {\n\t\t\tthis.items.set(item, cb(item))\n\t\t}\n\n\t\treturn this.items.get(item)!\n\t}\n}\n", "/**\n * Debounce a function.\n *\n * @example\n *\n * ```ts\n * const A = debounce(myFunction, 1000)\n * ```\n *\n * @public\n * @see source - https://gist.github.com/ca0v/73a31f57b397606c9813472f7493a940\n */\nexport function debounce<T extends unknown[], U>(\n\tcallback: (...args: T) => PromiseLike<U> | U,\n\twait: number\n) {\n\tlet state:\n\t\t| undefined\n\t\t| {\n\t\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\t\ttimeout: ReturnType<typeof setTimeout>\n\t\t\t\tpromise: Promise<U>\n\t\t\t\tresolve(value: U | PromiseLike<U>): void\n\t\t\t\treject(value: any): void\n\t\t\t\tlatestArgs: T\n\t\t  } = undefined\n\n\tconst fn = (...args: T): Promise<U> => {\n\t\tif (!state) {\n\t\t\tstate = {} as any\n\t\t\tstate!.promise = new Promise((resolve, reject) => {\n\t\t\t\tstate!.resolve = resolve\n\t\t\t\tstate!.reject = reject\n\t\t\t})\n\t\t}\n\t\tclearTimeout(state!.timeout)\n\t\tstate!.latestArgs = args\n\t\t// It's up to the consumer of debounce to call `cancel`\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tstate!.timeout = setTimeout(() => {\n\t\t\tconst s = state!\n\t\t\tstate = undefined\n\t\t\ttry {\n\t\t\t\ts.resolve(callback(...s.latestArgs))\n\t\t\t} catch (e) {\n\t\t\t\ts.reject(e)\n\t\t\t}\n\t\t}, wait)\n\n\t\treturn state!.promise\n\t}\n\tfn.cancel = () => {\n\t\tif (!state) return\n\t\tclearTimeout(state.timeout)\n\t}\n\treturn fn\n}\n", "/** @public */\nexport interface ErrorAnnotations {\n\ttags: Record<string, number | string | boolean | bigint | symbol | null | undefined>\n\textras: Record<string, unknown>\n}\n\nconst annotationsByError = new WeakMap<object, ErrorAnnotations>()\n\n/**\n * Annotate an error with tags and additional data. Annotations won't overwrite existing ones.\n * Retrieve them with `getErrorAnnotations`.\n *\n * @internal\n */\nexport function annotateError(error: unknown, annotations: Partial<ErrorAnnotations>) {\n\tif (typeof error !== 'object' || error === null) return\n\n\tlet currentAnnotations = annotationsByError.get(error)\n\tif (!currentAnnotations) {\n\t\tcurrentAnnotations = { tags: {}, extras: {} }\n\t\tannotationsByError.set(error, currentAnnotations)\n\t}\n\n\tif (annotations.tags) {\n\t\tcurrentAnnotations.tags = {\n\t\t\t...currentAnnotations.tags,\n\t\t\t...annotations.tags,\n\t\t}\n\t}\n\tif (annotations.extras) {\n\t\tcurrentAnnotations.extras = {\n\t\t\t...currentAnnotations.extras,\n\t\t\t...annotations.extras,\n\t\t}\n\t}\n}\n\n/** @internal */\nexport function getErrorAnnotations(error: Error): ErrorAnnotations {\n\treturn annotationsByError.get(error) ?? { tags: {}, extras: {} }\n}\n", "import { fetch } from './network'\n\n/**\n * Helpers for files\n *\n * @public\n */\nexport class FileHelpers {\n\t/**\n\t * @param dataURL - The file as a string.\n\t *\n\t * from https://stackoverflow.com/a/53817185\n\t */\n\tstatic async dataUrlToArrayBuffer(dataURL: string) {\n\t\treturn fetch(dataURL).then(function (result) {\n\t\t\treturn result.arrayBuffer()\n\t\t})\n\t}\n\n\t/**\n\t * Convert a file to a base64 encoded data url.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const A = FileHelpers.toDataUrl(myImageFile)\n\t * ```\n\t *\n\t * @param file - The file as a blob.\n\t */\n\tstatic async blobToDataUrl(file: Blob): Promise<string> {\n\t\treturn await new Promise((resolve, reject) => {\n\t\t\tif (file) {\n\t\t\t\tconst reader = new FileReader()\n\t\t\t\treader.onload = () => resolve(reader.result as string)\n\t\t\t\treader.onerror = (error) => reject(error)\n\t\t\t\treader.onabort = (error) => reject(error)\n\t\t\t\treader.readAsDataURL(file)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Convert a file to a unicode text string.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const A = FileHelpers.fileToDataUrl(myTextFile)\n\t * ```\n\t *\n\t * @param file - The file as a blob.\n\t */\n\tstatic async blobToText(file: Blob): Promise<string> {\n\t\treturn await new Promise((resolve, reject) => {\n\t\t\tif (file) {\n\t\t\t\tconst reader = new FileReader()\n\t\t\t\treader.onload = () => resolve(reader.result as string)\n\t\t\t\treader.onerror = (error) => reject(error)\n\t\t\t\treader.onabort = (error) => reject(error)\n\t\t\t\treader.readAsText(file)\n\t\t\t}\n\t\t})\n\t}\n}\n", "/**\n * Just a wrapper around `window.fetch` that sets the `referrerPolicy` to `strict-origin-when-cross-origin`.\n *\n * @internal\n */\nexport async function fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {\n\t// eslint-disable-next-line no-restricted-properties\n\treturn window.fetch(input, {\n\t\t// We want to make sure that the referrer is not sent to other domains.\n\t\treferrerPolicy: 'strict-origin-when-cross-origin',\n\t\t...init,\n\t})\n}\n\n/**\n * Just a wrapper around `new Image`, and yeah, it's a bit strange that it's in the network.ts file\n * but the main concern here is the referrerPolicy and setting it correctly.\n *\n * @internal\n */\nexport const Image = (width?: number, height?: number) => {\n\t// eslint-disable-next-line no-restricted-properties\n\tconst img = new window.Image(width, height)\n\timg.referrerPolicy = 'strict-origin-when-cross-origin'\n\treturn img\n}\n", "/**\n * Hash a string using the FNV-1a algorithm.\n *\n * @public\n */\nexport function getHashForString(string: string) {\n\tlet hash = 0\n\tfor (let i = 0; i < string.length; i++) {\n\t\thash = (hash << 5) - hash + string.charCodeAt(i)\n\t\thash |= 0 // Convert to 32bit integer\n\t}\n\treturn hash + ''\n}\n\n/**\n * Hash a string using the FNV-1a algorithm.\n *\n * @public\n */\nexport function getHashForObject(obj: any) {\n\treturn getHashForString(JSON.stringify(obj))\n}\n\n/**\n * Hash an ArrayBuffer using the FNV-1a algorithm.\n *\n * @public\n */\nexport function getHashForBuffer(buffer: ArrayBuffer) {\n\tconst view = new DataView(buffer)\n\tlet hash = 0\n\tfor (let i = 0; i < view.byteLength; i++) {\n\t\thash = (hash << 5) - hash + view.getUint8(i)\n\t\thash |= 0 // Convert to 32bit integer\n\t}\n\treturn hash + ''\n}\n\n/** @public */\nexport function lns(str: string) {\n\tconst result = str.split('')\n\tresult.push(...result.splice(0, Math.round(result.length / 5)))\n\tresult.push(...result.splice(0, Math.round(result.length / 4)))\n\tresult.push(...result.splice(0, Math.round(result.length / 3)))\n\tresult.push(...result.splice(0, Math.round(result.length / 2)))\n\treturn result\n\t\t.reverse()\n\t\t.map((n) => (+n ? (+n < 5 ? 5 + +n : +n > 5 ? +n - 5 : n) : n))\n\t\t.join('')\n}\n", "/*!\n * MIT License: https://github.com/ai/nanoid/blob/main/LICENSE\n * Modified code originally from <https://github.com/ai/nanoid>\n * Copyright 2017 Andrey Sitnik <andrey@sitnik.ru>\n *\n * `nanoid` is currently only distributed as an ES module. Some tools (jest, playwright) don't\n * properly support ESM-only code yet, and tldraw itself is distributed as both an ES module and a\n * CommonJS module. By including nanoid here, we can make sure it works well in every environment\n * where tldraw is used. We can also remove some unused features like custom alphabets.\n */\n\n// all environments that tldraw runs in (browser, workers, recent node versions) have global\n// `crypto`\nconst crypto = globalThis.crypto\n\n// This alphabet uses `A-Za-z0-9_-` symbols.\n// The order of characters is optimized for better gzip and brotli compression.\n// Same as in non-secure/index.js\nconst urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n\n// It is best to make fewer, larger requests to the crypto module to\n// avoid system call overhead. So, random numbers are generated in a\n// pool. The pool is a Buffer that is larger than the initial random\n// request size by this multiplier. The pool is enlarged if subsequent\n// requests exceed the maximum buffer size.\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool: Uint8Array, poolOffset: number\n\nfunction fillPool(bytes: number) {\n\tif (!pool || pool.length < bytes) {\n\t\tpool = new Uint8Array(bytes * POOL_SIZE_MULTIPLIER)\n\t\tcrypto.getRandomValues(pool)\n\t\tpoolOffset = 0\n\t} else if (poolOffset + bytes > pool.length) {\n\t\tcrypto.getRandomValues(pool)\n\t\tpoolOffset = 0\n\t}\n\tpoolOffset += bytes\n}\n\nfunction nanoid(size = 21) {\n\t// `-=` convert `size` to number to prevent `valueOf` abusing\n\tfillPool((size -= 0))\n\tlet id = ''\n\t// We are reading directly from the random pool to avoid creating new array\n\tfor (let i = poolOffset - size; i < poolOffset; i++) {\n\t\t// It is incorrect to use bytes exceeding the alphabet size.\n\t\t// The following mask reduces the random byte in the 0-255 value\n\t\t// range to the 0-63 value range. Therefore, adding hacks, such\n\t\t// as empty string fallback or magic numbers, is unnecessary because\n\t\t// the bitmask trims bytes down to the alphabet size.\n\t\tid += urlAlphabet[pool[i] & 63]\n\t}\n\treturn id\n}\n\nlet impl = nanoid\n/** @internal */\nexport function mockUniqueId(fn: (size?: number) => string) {\n\timpl = fn\n}\n\n/** @internal */\nexport function restoreUniqueId() {\n\timpl = nanoid\n}\n\n/**\n * Generate a unique id.\n *\n * @example\n *\n * ```ts\n * const id = uniqueId()\n * ```\n *\n * @public\n */\nexport function uniqueId(size?: number): string {\n\treturn impl(size)\n}\n", "/**\n * Get the first item from an iterable Set or Map.\n *\n * @example\n *\n * ```ts\n * const A = getFirstItem(new Set([1, 2, 3])) // 1\n * const B = getFirstItem(\n * \tnew Map([\n * \t\t['a', 1],\n * \t\t['b', 2],\n * \t])\n * ) // 1\n * ```\n *\n * @param value - The iterable Set or Map.\n * @public\n */\nexport function getFirstFromIterable<T = unknown>(set: Set<T> | Map<any, T>): T {\n\treturn set.values().next().value\n}\n", "import { promiseWithResolve } from '../control'\nimport { Image } from '../network'\nimport { isApngAnimated } from './apng'\nimport { isAvifAnimated } from './avif'\nimport { isGifAnimated } from './gif'\nimport { PngHelpers } from './png'\nimport { isWebpAnimated } from './webp'\n\n/** @public */\nexport const DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES = Object.freeze(['image/svg+xml'])\n/** @public */\nexport const DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES = Object.freeze([\n\t'image/jpeg',\n\t'image/png',\n\t'image/webp',\n])\n/** @public */\nexport const DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES = Object.freeze([\n\t'image/gif',\n\t'image/apng',\n\t'image/avif',\n])\n/** @public */\nexport const DEFAULT_SUPPORTED_IMAGE_TYPES = Object.freeze([\n\t...DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES,\n\t...DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES,\n\t...DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES,\n])\n/** @public */\nexport const DEFAULT_SUPPORT_VIDEO_TYPES = Object.freeze([\n\t'video/mp4',\n\t'video/webm',\n\t'video/quicktime',\n])\n/** @public */\nexport const DEFAULT_SUPPORTED_MEDIA_TYPE_LIST = [\n\t...DEFAULT_SUPPORTED_IMAGE_TYPES,\n\t...DEFAULT_SUPPORT_VIDEO_TYPES,\n].join(',')\n\n/**\n * Helpers for media\n *\n * @public\n */\nexport class MediaHelpers {\n\t/**\n\t * Load a video from a url.\n\t * @public\n\t */\n\tstatic loadVideo(src: string): Promise<HTMLVideoElement> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst video = document.createElement('video')\n\t\t\tvideo.onloadeddata = () => resolve(video)\n\t\t\tvideo.onerror = (e) => {\n\t\t\t\tconsole.error(e)\n\t\t\t\treject(new Error('Could not load video'))\n\t\t\t}\n\t\t\tvideo.crossOrigin = 'anonymous'\n\t\t\tvideo.src = src\n\t\t})\n\t}\n\n\tstatic async getVideoFrameAsDataUrl(video: HTMLVideoElement, time = 0): Promise<string> {\n\t\tconst promise = promiseWithResolve<string>()\n\t\tlet didSetTime = false\n\n\t\tconst onReadyStateChanged = () => {\n\t\t\tif (!didSetTime) {\n\t\t\t\tif (video.readyState >= video.HAVE_METADATA) {\n\t\t\t\t\tdidSetTime = true\n\t\t\t\t\tvideo.currentTime = time\n\t\t\t\t} else {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (video.readyState >= video.HAVE_CURRENT_DATA) {\n\t\t\t\tconst canvas = document.createElement('canvas')\n\t\t\t\tcanvas.width = video.videoWidth\n\t\t\t\tcanvas.height = video.videoHeight\n\t\t\t\tconst ctx = canvas.getContext('2d')\n\t\t\t\tif (!ctx) {\n\t\t\t\t\tthrow new Error('Could not get 2d context')\n\t\t\t\t}\n\t\t\t\tctx.drawImage(video, 0, 0)\n\t\t\t\tpromise.resolve(canvas.toDataURL())\n\t\t\t}\n\t\t}\n\t\tconst onError = (e: Event) => {\n\t\t\tconsole.error(e)\n\t\t\tpromise.reject(new Error('Could not get video frame'))\n\t\t}\n\n\t\tvideo.addEventListener('loadedmetadata', onReadyStateChanged)\n\t\tvideo.addEventListener('loadeddata', onReadyStateChanged)\n\t\tvideo.addEventListener('canplay', onReadyStateChanged)\n\t\tvideo.addEventListener('seeked', onReadyStateChanged)\n\n\t\tvideo.addEventListener('error', onError)\n\t\tvideo.addEventListener('stalled', onError)\n\n\t\tonReadyStateChanged()\n\n\t\ttry {\n\t\t\treturn await promise\n\t\t} finally {\n\t\t\tvideo.removeEventListener('loadedmetadata', onReadyStateChanged)\n\t\t\tvideo.removeEventListener('loadeddata', onReadyStateChanged)\n\t\t\tvideo.removeEventListener('canplay', onReadyStateChanged)\n\t\t\tvideo.removeEventListener('seeked', onReadyStateChanged)\n\n\t\t\tvideo.removeEventListener('error', onError)\n\t\t\tvideo.removeEventListener('stalled', onError)\n\t\t}\n\t}\n\n\t/**\n\t * Load an image from a url.\n\t * @public\n\t */\n\tstatic loadImage(src: string): Promise<HTMLImageElement> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst img = Image()\n\t\t\timg.onload = () => resolve(img)\n\t\t\timg.onerror = (e) => {\n\t\t\t\tconsole.error(e)\n\t\t\t\treject(new Error('Could not load image'))\n\t\t\t}\n\t\t\timg.crossOrigin = 'anonymous'\n\t\t\timg.referrerPolicy = 'strict-origin-when-cross-origin'\n\t\t\timg.src = src\n\t\t})\n\t}\n\n\t/**\n\t * Get the size of a video blob\n\t *\n\t * @param blob - A SharedBlob containing the video\n\t * @public\n\t */\n\tstatic async getVideoSize(blob: Blob): Promise<{ w: number; h: number }> {\n\t\treturn MediaHelpers.usingObjectURL(blob, async (url) => {\n\t\t\tconst video = await MediaHelpers.loadVideo(url)\n\t\t\treturn { w: video.videoWidth, h: video.videoHeight }\n\t\t})\n\t}\n\n\t/**\n\t * Get the size of an image blob\n\t *\n\t * @param blob - A Blob containing the image.\n\t * @public\n\t */\n\tstatic async getImageSize(blob: Blob): Promise<{ w: number; h: number }> {\n\t\tconst image = await MediaHelpers.usingObjectURL(blob, MediaHelpers.loadImage)\n\n\t\ttry {\n\t\t\tif (blob.type === 'image/png') {\n\t\t\t\tconst view = new DataView(await blob.arrayBuffer())\n\t\t\t\tif (PngHelpers.isPng(view, 0)) {\n\t\t\t\t\tconst physChunk = PngHelpers.findChunk(view, 'pHYs')\n\t\t\t\t\tif (physChunk) {\n\t\t\t\t\t\tconst physData = PngHelpers.parsePhys(view, physChunk.dataOffset)\n\t\t\t\t\t\tif (physData.unit === 0 && physData.ppux === physData.ppuy) {\n\t\t\t\t\t\t\tconst pixelRatio = Math.max(physData.ppux / 2834.5, 1)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tw: Math.round(image.naturalWidth / pixelRatio),\n\t\t\t\t\t\t\t\th: Math.round(image.naturalHeight / pixelRatio),\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error(err)\n\t\t\treturn { w: image.naturalWidth, h: image.naturalHeight }\n\t\t}\n\t\treturn { w: image.naturalWidth, h: image.naturalHeight }\n\t}\n\n\tstatic async isAnimated(file: Blob): Promise<boolean> {\n\t\tif (file.type === 'image/gif') {\n\t\t\treturn isGifAnimated(await file.arrayBuffer())\n\t\t}\n\n\t\tif (file.type === 'image/avif') {\n\t\t\treturn isAvifAnimated(await file.arrayBuffer())\n\t\t}\n\n\t\tif (file.type === 'image/webp') {\n\t\t\treturn isWebpAnimated(await file.arrayBuffer())\n\t\t}\n\n\t\tif (file.type === 'image/apng') {\n\t\t\treturn isApngAnimated(await file.arrayBuffer())\n\t\t}\n\n\t\treturn false\n\t}\n\n\tstatic isAnimatedImageType(mimeType: string | null): boolean {\n\t\treturn DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES.includes(mimeType || '')\n\t}\n\n\tstatic isStaticImageType(mimeType: string | null): boolean {\n\t\treturn DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES.includes(mimeType || '')\n\t}\n\n\tstatic isVectorImageType(mimeType: string | null): boolean {\n\t\treturn DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES.includes(mimeType || '')\n\t}\n\n\tstatic isImageType(mimeType: string): boolean {\n\t\treturn DEFAULT_SUPPORTED_IMAGE_TYPES.includes(mimeType)\n\t}\n\n\tstatic async usingObjectURL<T>(blob: Blob, fn: (url: string) => Promise<T>): Promise<T> {\n\t\tconst url = URL.createObjectURL(blob)\n\t\ttry {\n\t\t\treturn await fn(url)\n\t\t} finally {\n\t\t\tURL.revokeObjectURL(url)\n\t\t}\n\t}\n}\n", "/*!\n * MIT License: https://github.com/vHeemstra/is-apng/blob/main/license\n * Copyright (c) Philip van Heemstra\n */\n\nexport function isApngAnimated(buffer: ArrayBuffer): boolean {\n\tconst view = new Uint8Array(buffer)\n\n\tif (\n\t\t!view ||\n\t\t!((typeof Buffer !== 'undefined' && Buffer.isBuffer(view)) || view instanceof Uint8Array) ||\n\t\tview.length < 16\n\t) {\n\t\treturn false\n\t}\n\n\tconst isPNG =\n\t\tview[0] === 0x89 &&\n\t\tview[1] === 0x50 &&\n\t\tview[2] === 0x4e &&\n\t\tview[3] === 0x47 &&\n\t\tview[4] === 0x0d &&\n\t\tview[5] === 0x0a &&\n\t\tview[6] === 0x1a &&\n\t\tview[7] === 0x0a\n\n\tif (!isPNG) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Returns the index of the first occurrence of a sequence in an typed array, or -1 if it is not present.\n\t *\n\t * Works similar to `Array.prototype.indexOf()`, but it searches for a sequence of array values (bytes).\n\t * The bytes in the `haystack` array are decoded (UTF-8) and then used to search for `needle`.\n\t *\n\t * @param haystack `Uint8Array`\n\t * Array to search in.\n\t *\n\t * @param needle `string | RegExp`\n\t * The value to locate in the array.\n\t *\n\t * @param fromIndex `number`\n\t * The array index at which to begin the search.\n\t *\n\t * @param upToIndex `number`\n\t * The array index up to which to search.\n\t * If omitted, search until the end.\n\t *\n\t * @param chunksize `number`\n\t * Size of the chunks used when searching (default 1024).\n\t *\n\t * @returns boolean\n\t * Whether the array holds Animated PNG data.\n\t */\n\tfunction indexOfSubstring(\n\t\thaystack: Uint8Array,\n\t\tneedle: string | RegExp,\n\t\tfromIndex: number,\n\t\tupToIndex?: number,\n\t\tchunksize = 1024 /* Bytes */\n\t) {\n\t\t/**\n\t\t * Adopted from: https://stackoverflow.com/a/67771214/2142071\n\t\t */\n\n\t\tif (!needle) {\n\t\t\treturn -1\n\t\t}\n\t\tneedle = new RegExp(needle, 'g')\n\n\t\t// The needle could get split over two chunks.\n\t\t// So, at every chunk we prepend the last few characters\n\t\t// of the last chunk.\n\t\tconst needle_length = needle.source.length\n\t\tconst decoder = new TextDecoder()\n\n\t\t// Handle search offset in line with\n\t\t// `Array.prototype.indexOf()` and `TypedArray.prototype.subarray()`.\n\t\tconst full_haystack_length = haystack.length\n\t\tif (typeof upToIndex === 'undefined') {\n\t\t\tupToIndex = full_haystack_length\n\t\t}\n\t\tif (fromIndex >= full_haystack_length || upToIndex <= 0 || fromIndex >= upToIndex) {\n\t\t\treturn -1\n\t\t}\n\t\thaystack = haystack.subarray(fromIndex, upToIndex)\n\n\t\tlet position = -1\n\t\tlet current_index = 0\n\t\tlet full_length = 0\n\t\tlet needle_buffer = ''\n\n\t\touter: while (current_index < haystack.length) {\n\t\t\tconst next_index = current_index + chunksize\n\t\t\t// subarray doesn't copy\n\t\t\tconst chunk = haystack.subarray(current_index, next_index)\n\t\t\tconst decoded = decoder.decode(chunk, { stream: true })\n\n\t\t\tconst text = needle_buffer + decoded\n\n\t\t\tlet match: RegExpExecArray | null\n\t\t\tlet last_index = -1\n\t\t\twhile ((match = needle.exec(text)) !== null) {\n\t\t\t\tlast_index = match.index - needle_buffer.length\n\t\t\t\tposition = full_length + last_index\n\t\t\t\tbreak outer\n\t\t\t}\n\n\t\t\tcurrent_index = next_index\n\t\t\tfull_length += decoded.length\n\n\t\t\t// Check that the buffer doesn't itself include the needle\n\t\t\t// this would cause duplicate finds (we could also use a Set to avoid that).\n\t\t\tconst needle_index =\n\t\t\t\tlast_index > -1 ? last_index + needle_length : decoded.length - needle_length\n\t\t\tneedle_buffer = decoded.slice(needle_index)\n\t\t}\n\n\t\t// Correct for search offset.\n\t\tif (position >= 0) {\n\t\t\tposition += fromIndex >= 0 ? fromIndex : full_haystack_length + fromIndex\n\t\t}\n\n\t\treturn position\n\t}\n\n\t// APNGs have an animation control chunk ('acTL') preceding the IDATs.\n\t// See: https://en.wikipedia.org/wiki/APNG#File_format\n\tconst idatIdx = indexOfSubstring(view, 'IDAT', 12)\n\tif (idatIdx >= 12) {\n\t\tconst actlIdx = indexOfSubstring(view, 'acTL', 8, idatIdx)\n\t\treturn actlIdx >= 8\n\t}\n\n\treturn false\n}\n\n// globalThis.isApng = isApng\n\n// (new TextEncoder()).encode('IDAT')\n// Decimal: [73, 68, 65, 84]\n// Hex: [0x49, 0x44, 0x41, 0x54]\n\n// (new TextEncoder()).encode('acTL')\n// Decimal: [97, 99, 84, 76]\n// Hex: [0x61, 0x63, 0x54, 0x4C]\n\n// const idatIdx = buffer.indexOf('IDAT')\n// const actlIdx = buffer.indexOf('acTL')\n", "export const isAvifAnimated = (buffer: ArrayBuffer) => {\n\tconst view = new Uint8Array(buffer)\n\treturn view[3] === 44\n}\n", "/*!\n * MIT License\n * Modified code originally from <https://github.com/qzb/is-animated>\n * Copyright (c) 2016 J\u00F3zef Soko\u0142owski <j.k.sokolowski@gmail.com>\n */\n\n/** Returns total length of data blocks sequence */\nfunction getDataBlocksLength(buffer: Uint8Array, offset: number): number {\n\tlet length = 0\n\n\twhile (buffer[offset + length]) {\n\t\tlength += buffer[offset + length] + 1\n\t}\n\n\treturn length + 1\n}\n\n/**\n * Checks if buffer contains GIF image\n *\n * @public\n */\nexport function isGIF(buffer: ArrayBuffer): boolean {\n\tconst enc = new TextDecoder('ascii')\n\tconst header = enc.decode(buffer.slice(0, 3))\n\treturn header === 'GIF'\n}\n\n/**\n * Checks if buffer contains animated GIF image\n *\n * @public\n */\nexport function isGifAnimated(buffer: ArrayBuffer): boolean {\n\tconst view = new Uint8Array(buffer)\n\tlet hasColorTable, colorTableSize\n\tlet offset = 0\n\tlet imagesCount = 0\n\n\t// Check if this is this image has valid GIF header.\n\t// If not return false. Chrome, FF and IE doesn't handle GIFs with invalid version.\n\tif (!isGIF(buffer)) {\n\t\treturn false\n\t}\n\n\t// Skip header, logical screen descriptor and global color table\n\n\thasColorTable = view[10] & 0x80 // 0b10000000\n\tcolorTableSize = view[10] & 0x07 // 0b00000111\n\n\toffset += 6 // skip header\n\toffset += 7 // skip logical screen descriptor\n\toffset += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0 // skip global color table\n\n\t// Find if there is more than one image descriptor\n\n\twhile (imagesCount < 2 && offset < view.length) {\n\t\tswitch (view[offset]) {\n\t\t\t// Image descriptor block. According to specification there could be any\n\t\t\t// number of these blocks (even zero). When there is more than one image\n\t\t\t// descriptor browsers will display animation (they shouldn't when there\n\t\t\t// is no delays defined, but they do it anyway).\n\t\t\tcase 0x2c:\n\t\t\t\timagesCount += 1\n\n\t\t\t\thasColorTable = view[offset + 9] & 0x80 // 0b10000000\n\t\t\t\tcolorTableSize = view[offset + 9] & 0x07 // 0b00000111\n\n\t\t\t\toffset += 10 // skip image descriptor\n\t\t\t\toffset += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0 // skip local color table\n\t\t\t\toffset += getDataBlocksLength(view, offset + 1) + 1 // skip image data\n\n\t\t\t\tbreak\n\n\t\t\t// Skip all extension blocks. In theory this \"plain text extension\" blocks\n\t\t\t// could be frames of animation, but no browser renders them.\n\t\t\tcase 0x21:\n\t\t\t\toffset += 2 // skip introducer and label\n\t\t\t\toffset += getDataBlocksLength(view, offset) // skip this block and following data blocks\n\n\t\t\t\tbreak\n\n\t\t\t// Stop processing on trailer block,\n\t\t\t// all data after this point will is ignored by decoders\n\t\t\tcase 0x3b:\n\t\t\t\toffset = view.length // fast forward to end of buffer\n\t\t\t\tbreak\n\n\t\t\t// Oops! This GIF seems to be invalid\n\t\t\tdefault:\n\t\t\t\t// fast forward to end of buffer\n\t\t\t\toffset = view.length\n\t\t\t\tbreak\n\t\t}\n\t}\n\n\treturn imagesCount > 1\n}\n", "/*!\n * MIT License: https://github.com/alexgorbatchev/crc/blob/master/LICENSE\n * Copyright: 2014 Alex Gorbatchev\n * Code: crc32, https://github.com/alexgorbatchev/crc/blob/master/src/calculators/crc32.ts\n */\n\ntype BufferInput = string | ArrayBuffer | Buffer\n\ninterface CRCCalculator<T = BufferInput | Uint8Array> {\n\t(value: T, previous?: number): number\n}\n\nlet TABLE: Array<number> | Int32Array = [\n\t0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n\t0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n\t0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n\t0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n\t0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n\t0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n\t0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n\t0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n\t0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n\t0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n\t0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n\t0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n\t0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n\t0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n\t0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n\t0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n\t0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n\t0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n\t0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n\t0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n\t0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n\t0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n\t0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n\t0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n\t0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n\t0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n\t0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n\t0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n\t0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n\t0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n\t0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n\t0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n]\n\nif (typeof Int32Array !== 'undefined') {\n\tTABLE = new Int32Array(TABLE)\n}\n\nconst crc: CRCCalculator<Uint8Array> = (current, previous) => {\n\tlet crc = previous === 0 ? 0 : ~~previous! ^ -1\n\n\tfor (let index = 0; index < current.length; index++) {\n\t\tcrc = TABLE[(crc ^ current[index]) & 0xff] ^ (crc >>> 8)\n\t}\n\n\treturn crc ^ -1\n}\n\nconst LEN_SIZE = 4\nconst CRC_SIZE = 4\n\n/** @public */\nexport class PngHelpers {\n\tstatic isPng(view: DataView, offset: number) {\n\t\tif (\n\t\t\tview.getUint8(offset + 0) === 0x89 &&\n\t\t\tview.getUint8(offset + 1) === 0x50 &&\n\t\t\tview.getUint8(offset + 2) === 0x4e &&\n\t\t\tview.getUint8(offset + 3) === 0x47 &&\n\t\t\tview.getUint8(offset + 4) === 0x0d &&\n\t\t\tview.getUint8(offset + 5) === 0x0a &&\n\t\t\tview.getUint8(offset + 6) === 0x1a &&\n\t\t\tview.getUint8(offset + 7) === 0x0a\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tstatic getChunkType(view: DataView, offset: number) {\n\t\treturn [\n\t\t\tString.fromCharCode(view.getUint8(offset)),\n\t\t\tString.fromCharCode(view.getUint8(offset + 1)),\n\t\t\tString.fromCharCode(view.getUint8(offset + 2)),\n\t\t\tString.fromCharCode(view.getUint8(offset + 3)),\n\t\t].join('')\n\t}\n\n\tstatic readChunks(view: DataView, offset = 0) {\n\t\tconst chunks: Record<string, { dataOffset: number; size: number; start: number }> = {}\n\t\tif (!PngHelpers.isPng(view, offset)) {\n\t\t\tthrow new Error('Not a PNG')\n\t\t}\n\t\toffset += 8\n\n\t\twhile (offset <= view.buffer.byteLength) {\n\t\t\tconst start = offset\n\t\t\tconst len = view.getInt32(offset)\n\t\t\toffset += 4\n\t\t\tconst chunkType = PngHelpers.getChunkType(view, offset)\n\n\t\t\tif (chunkType === 'IDAT' && chunks[chunkType]) {\n\t\t\t\toffset += len + LEN_SIZE + CRC_SIZE\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (chunkType === 'IEND') {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tchunks[chunkType] = {\n\t\t\t\tstart,\n\t\t\t\tdataOffset: offset + 4,\n\t\t\t\tsize: len,\n\t\t\t}\n\t\t\toffset += len + LEN_SIZE + CRC_SIZE\n\t\t}\n\n\t\treturn chunks\n\t}\n\n\tstatic parsePhys(view: DataView, offset: number) {\n\t\treturn {\n\t\t\tppux: view.getUint32(offset),\n\t\t\tppuy: view.getUint32(offset + 4),\n\t\t\tunit: view.getUint8(offset + 4),\n\t\t}\n\t}\n\n\tstatic findChunk(view: DataView, type: string) {\n\t\tconst chunks = PngHelpers.readChunks(view)\n\t\treturn chunks[type]\n\t}\n\n\tstatic setPhysChunk(view: DataView, dpr = 1, options?: BlobPropertyBag) {\n\t\tlet offset = 46\n\t\tlet size = 0\n\t\tconst res1 = PngHelpers.findChunk(view, 'pHYs')\n\t\tif (res1) {\n\t\t\toffset = res1.start\n\t\t\tsize = res1.size\n\t\t}\n\n\t\tconst res2 = PngHelpers.findChunk(view, 'IDAT')\n\t\tif (res2) {\n\t\t\toffset = res2.start\n\t\t\tsize = 0\n\t\t}\n\n\t\tconst pHYsData = new ArrayBuffer(21)\n\t\tconst pHYsDataView = new DataView(pHYsData)\n\n\t\tpHYsDataView.setUint32(0, 9)\n\n\t\tpHYsDataView.setUint8(4, 'p'.charCodeAt(0))\n\t\tpHYsDataView.setUint8(5, 'H'.charCodeAt(0))\n\t\tpHYsDataView.setUint8(6, 'Y'.charCodeAt(0))\n\t\tpHYsDataView.setUint8(7, 's'.charCodeAt(0))\n\n\t\tconst DPI_96 = 2835.5\n\n\t\tpHYsDataView.setInt32(8, DPI_96 * dpr)\n\t\tpHYsDataView.setInt32(12, DPI_96 * dpr)\n\t\tpHYsDataView.setInt8(16, 1)\n\n\t\tconst crcBit = new Uint8Array(pHYsData.slice(4, 17))\n\t\tpHYsDataView.setInt32(17, crc(crcBit))\n\n\t\tconst startBuf = view.buffer.slice(0, offset)\n\t\tconst endBuf = view.buffer.slice(offset + size)\n\n\t\treturn new Blob([startBuf, pHYsData, endBuf], options)\n\t}\n}\n", "/*!\n * MIT License: https://github.com/sindresorhus/is-webp/blob/main/license\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n */\nfunction isWebp(view: Uint8Array) {\n\tif (!view || view.length < 12) {\n\t\treturn false\n\t}\n\n\treturn view[8] === 87 && view[9] === 69 && view[10] === 66 && view[11] === 80\n}\n\nexport function isWebpAnimated(buffer: ArrayBuffer) {\n\tconst view = new Uint8Array(buffer)\n\n\tif (!isWebp(view)) {\n\t\treturn false\n\t}\n\n\tif (!view || view.length < 21) {\n\t\treturn false\n\t}\n\n\treturn ((view[20] >> 1) & 1) === 1\n}\n", "/**\n * Linear interpolate between two values.\n *\n * @example\n *\n * ```ts\n * const A = lerp(0, 1, 0.5)\n * ```\n *\n * @public\n */\nexport function lerp(a: number, b: number, t: number) {\n\treturn a + (b - a) * t\n}\n\n/**\n * Inverse lerp between two values. Given a value `n` in the range [a, b], returns a number between\n * 0 and 1.\n *\n * @public\n */\nexport function invLerp(a: number, b: number, t: number) {\n\treturn (t - a) / (b - a)\n}\n\n/**\n * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift). The\n * result will always be betweeen -1 and 1.\n *\n * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).\n *\n * @public\n */\nexport function rng(seed = '') {\n\tlet x = 0\n\tlet y = 0\n\tlet z = 0\n\tlet w = 0\n\n\tfunction next() {\n\t\tconst t = x ^ (x << 11)\n\t\tx = y\n\t\ty = z\n\t\tz = w\n\t\tw ^= ((w >>> 19) ^ t ^ (t >>> 8)) >>> 0\n\t\treturn (w / 0x100000000) * 2\n\t}\n\n\tfor (let k = 0; k < seed.length + 64; k++) {\n\t\tx ^= seed.charCodeAt(k) | 0\n\t\tnext()\n\t}\n\n\treturn next\n}\n\n/**\n * Modulate a value between two ranges.\n *\n * @example\n *\n * ```ts\n * const A = modulate(0, [0, 1], [0, 100])\n * ```\n *\n * @param value - The interpolation value.\n * @param rangeA - From [low, high]\n * @param rangeB - To [low, high]\n * @param clamp - Whether to clamp the the result to [low, high]\n * @public\n */\nexport function modulate(value: number, rangeA: number[], rangeB: number[], clamp = false): number {\n\tconst [fromLow, fromHigh] = rangeA\n\tconst [v0, v1] = rangeB\n\tconst result = v0 + ((value - fromLow) / (fromHigh - fromLow)) * (v1 - v0)\n\n\treturn clamp\n\t\t? v0 < v1\n\t\t\t? Math.max(Math.min(result, v1), v0)\n\t\t\t: Math.max(Math.min(result, v0), v1)\n\t\t: result\n}\n", "/** @internal */\nexport function hasOwnProperty(obj: object, key: string): boolean {\n\treturn Object.prototype.hasOwnProperty.call(obj, key)\n}\n\n/** @internal */\nexport function getOwnProperty<K extends string, V>(\n\tobj: Partial<Record<K, V>>,\n\tkey: K\n): V | undefined\n/** @internal */\nexport function getOwnProperty(obj: object, key: string): unknown\n/** @internal */\nexport function getOwnProperty(obj: object, key: string): unknown {\n\tif (!hasOwnProperty(obj, key)) {\n\t\treturn undefined\n\t}\n\t// @ts-expect-error we know the property exists\n\treturn obj[key]\n}\n\n/**\n * An alias for `Object.keys` that treats the object as a map and so preserves the type of the keys.\n *\n * @internal\n */\nexport function objectMapKeys<Key extends string>(object: {\n\treadonly [K in Key]: unknown\n}): Array<Key> {\n\treturn Object.keys(object) as Key[]\n}\n\n/**\n * An alias for `Object.values` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapValues<Key extends string, Value>(object: {\n\t[K in Key]: Value\n}): Array<Value> {\n\treturn Object.values(object) as Value[]\n}\n\n/**\n * An alias for `Object.entries` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapEntries<Key extends string, Value>(object: {\n\t[K in Key]: Value\n}): Array<[Key, Value]> {\n\treturn Object.entries(object) as [Key, Value][]\n}\n\n/**\n * An alias for `Object.fromEntries` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapFromEntries<Key extends string, Value>(\n\tentries: ReadonlyArray<readonly [Key, Value]>\n): { [K in Key]: Value } {\n\treturn Object.fromEntries(entries) as { [K in Key]: Value }\n}\n\n/**\n * Filters an object using a predicate function.\n * @returns a new object with only the entries that pass the predicate\n * @internal\n */\nexport function filterEntries<Key extends string, Value>(\n\tobject: { [K in Key]: Value },\n\tpredicate: (key: Key, value: Value) => boolean\n): { [K in Key]: Value } {\n\tconst result: { [K in Key]?: Value } = {}\n\tlet didChange = false\n\tfor (const [key, value] of objectMapEntries(object)) {\n\t\tif (predicate(key, value)) {\n\t\t\tresult[key] = value\n\t\t} else {\n\t\t\tdidChange = true\n\t\t}\n\t}\n\treturn didChange ? (result as { [K in Key]: Value }) : object\n}\n\n/**\n * Maps the values of one object map to another.\n * @returns a new object with the entries mapped\n * @internal\n */\nexport function mapObjectMapValues<Key extends string, ValueBefore, ValueAfter>(\n\tobject: { readonly [K in Key]: ValueBefore },\n\tmapper: (key: Key, value: ValueBefore) => ValueAfter\n): { [K in Key]: ValueAfter } {\n\tconst result = {} as { [K in Key]: ValueAfter }\n\tfor (const [key, value] of objectMapEntries(object)) {\n\t\tconst newValue = mapper(key, value)\n\t\tresult[key] = newValue\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function areObjectsShallowEqual<T extends object>(obj1: T, obj2: T): boolean {\n\tif (obj1 === obj2) return true\n\tconst keys1 = new Set(Object.keys(obj1))\n\tconst keys2 = new Set(Object.keys(obj2))\n\tif (keys1.size !== keys2.size) return false\n\tfor (const key of keys1) {\n\t\tif (!keys2.has(key)) return false\n\t\tif (!Object.is((obj1 as any)[key], (obj2 as any)[key])) return false\n\t}\n\treturn true\n}\n\n/** @internal */\nexport function groupBy<K extends string, V>(\n\tarray: ReadonlyArray<V>,\n\tkeySelector: (value: V) => K\n): Record<K, V[]> {\n\tconst result: Record<K, V[]> = {} as any\n\tfor (const value of array) {\n\t\tconst key = keySelector(value)\n\t\tif (!result[key]) result[key] = []\n\t\tresult[key].push(value)\n\t}\n\treturn result\n}\n", "import {\n\tgenerateJitteredKeyBetween,\n\tgenerateNJitteredKeysBetween,\n\tgenerateNKeysBetween,\n} from 'fractional-indexing-jittered'\n\nconst generateKeysFn =\n\tprocess.env.NODE_ENV === 'test' ? generateNKeysBetween : generateNJitteredKeysBetween\n\n/**\n * A string made up of an integer part followed by a fraction part. The fraction point consists of\n * zero or more digits with no trailing zeros. Based on\n * {@link https://observablehq.com/@dgreensp/implementing-fractional-indexing}.\n *\n * @public\n */\nexport type IndexKey = string & { __brand: 'indexKey' }\n\n/**\n * The index key for the first index - 'a0'.\n * @public\n */\nexport const ZERO_INDEX_KEY = 'a0' as IndexKey\n\n/** @internal */\nexport function validateIndexKey(index: string): asserts index is IndexKey {\n\ttry {\n\t\tgenerateJitteredKeyBetween(index, null)\n\t} catch (e) {\n\t\tthrow new Error('invalid index: ' + index)\n\t}\n}\n\n/**\n * Get a number of indices between two indices.\n * @param below - The index below.\n * @param above - The index above.\n * @param n - The number of indices to get.\n * @public\n */\nexport function getIndicesBetween(\n\tbelow: IndexKey | null | undefined,\n\tabove: IndexKey | null | undefined,\n\tn: number\n) {\n\treturn generateKeysFn(below ?? null, above ?? null, n) as IndexKey[]\n}\n\n/**\n * Get a number of indices above an index.\n * @param below - The index below.\n * @param n - The number of indices to get.\n * @public\n */\nexport function getIndicesAbove(below: IndexKey | null | undefined, n: number) {\n\treturn generateKeysFn(below ?? null, null, n) as IndexKey[]\n}\n\n/**\n * Get a number of indices below an index.\n * @param above - The index above.\n * @param n - The number of indices to get.\n * @public\n */\nexport function getIndicesBelow(above: IndexKey | null | undefined, n: number) {\n\treturn generateKeysFn(null, above ?? null, n) as IndexKey[]\n}\n\n/**\n * Get the index between two indices.\n * @param below - The index below.\n * @param above - The index above.\n * @public\n */\nexport function getIndexBetween(\n\tbelow: IndexKey | null | undefined,\n\tabove: IndexKey | null | undefined\n) {\n\treturn generateKeysFn(below ?? null, above ?? null, 1)[0] as IndexKey\n}\n\n/**\n * Get the index above a given index.\n * @param below - The index below.\n * @public\n */\nexport function getIndexAbove(below: IndexKey | null | undefined = null) {\n\treturn generateKeysFn(below, null, 1)[0] as IndexKey\n}\n\n/**\n * Get the index below a given index.\n * @param above - The index above.\n *  @public\n */\nexport function getIndexBelow(above: IndexKey | null | undefined = null) {\n\treturn generateKeysFn(null, above, 1)[0] as IndexKey\n}\n\n/**\n * Get n number of indices, starting at an index.\n * @param n - The number of indices to get.\n * @param start -  The index to start at.\n * @public\n */\nexport function getIndices(n: number, start = 'a1' as IndexKey) {\n\treturn [start, ...generateKeysFn(start, null, n)] as IndexKey[]\n}\n\n/**\n * Sort by index.\n * @param a - An object with an index property.\n * @param b - An object with an index property.\n * @public */\nexport function sortByIndex<T extends { index: IndexKey }>(a: T, b: T) {\n\tif (a.index < b.index) {\n\t\treturn -1\n\t} else if (a.index > b.index) {\n\t\treturn 1\n\t}\n\treturn 0\n}\n", "// src/charSet.ts\nfunction indexCharacterSet(options) {\n  const dicts = createCharSetDicts(options.chars);\n  const limits = integerLimits(\n    dicts,\n    options.firstPositive,\n    options.mostPositive,\n    options.mostNegative\n  );\n  const jitterRange = options.jitterRange ?? Math.floor(Math.pow(dicts.length, 3) / 5);\n  const paddingRange = paddingDict(jitterRange, dicts.length);\n  return {\n    chars: options.chars,\n    byChar: dicts.byChar,\n    byCode: dicts.byCode,\n    length: dicts.length,\n    first: dicts.byCode[0],\n    last: dicts.byCode[dicts.length - 1],\n    firstPositive: limits.firstPositive,\n    mostPositive: limits.mostPositive,\n    firstNegative: limits.firstNegative,\n    mostNegative: limits.mostNegative,\n    jitterRange,\n    paddingDict: paddingRange\n  };\n}\nfunction createCharSetDicts(charSet) {\n  const byCode = {};\n  const byChar = {};\n  const length = charSet.length;\n  for (let i = 0; i < length; i++) {\n    const char = charSet[i];\n    byCode[i] = char;\n    byChar[char] = i;\n  }\n  return {\n    byCode,\n    byChar,\n    length\n  };\n}\nfunction integerLimits(dicts, firstPositive, mostPositive, mostNegative) {\n  const firstPositiveIndex = firstPositive ? dicts.byChar[firstPositive] : Math.ceil(dicts.length / 2);\n  const mostPositiveIndex = mostPositive ? dicts.byChar[mostPositive] : dicts.length - 1;\n  const mostNegativeIndex = mostNegative ? dicts.byChar[mostNegative] : 0;\n  if (firstPositiveIndex === void 0 || mostPositiveIndex === void 0 || mostNegativeIndex === void 0) {\n    throw new Error(\"invalid charSet\");\n  }\n  if (mostPositiveIndex - firstPositiveIndex < 3) {\n    throw new Error(\n      \"mostPositive must be at least 3 characters away from neutral\"\n    );\n  }\n  if (firstPositiveIndex - mostNegativeIndex < 3) {\n    throw new Error(\n      \"mostNegative must be at least 3 characters away from neutral\"\n    );\n  }\n  return {\n    firstPositive: dicts.byCode[firstPositiveIndex],\n    mostPositive: dicts.byCode[mostPositiveIndex],\n    firstNegative: dicts.byCode[firstPositiveIndex - 1],\n    mostNegative: dicts.byCode[mostNegativeIndex]\n  };\n}\nfunction paddingDict(jitterRange, charSetLength) {\n  const paddingDict2 = {};\n  let distance = 0;\n  for (let i = 0; i < 100; i++) {\n    paddingDict2[i] = Math.pow(charSetLength, i);\n    if (paddingDict2[i] > jitterRange) {\n      break;\n    }\n  }\n  return paddingDict2;\n}\nvar _base62CharSet = null;\nfunction base62CharSet() {\n  if (_base62CharSet)\n    return _base62CharSet;\n  return _base62CharSet = indexCharacterSet({\n    // Base62 are all the alphanumeric characters, database and user friendly\n    // For shorter strings and more room you could opt for more characters\n    chars: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n    // This gives us nice human readable keys to start with a0 a1 etc\n    firstPositive: \"a\",\n    mostPositive: \"z\",\n    mostNegative: \"A\"\n  });\n}\n\n// src/integerLength.ts\nfunction distanceBetween(a, b, charSet) {\n  const indexA = charSet.byChar[a];\n  const indexB = charSet.byChar[b];\n  return Math.abs(indexA - indexB);\n}\nfunction integerLength(head, charSet) {\n  const firstChar = head[0];\n  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {\n    throw new Error(\"invalid firstChar on key\");\n  }\n  if (firstChar === charSet.mostPositive) {\n    const firstLevel = distanceBetween(firstChar, charSet.firstPositive, charSet) + 1;\n    return firstLevel + integerLengthFromSecondLevel(head.slice(1), \"positive\", charSet);\n  }\n  if (firstChar === charSet.mostNegative) {\n    const firstLevel = distanceBetween(firstChar, charSet.firstNegative, charSet) + 1;\n    return firstLevel + integerLengthFromSecondLevel(head.slice(1), \"negative\", charSet);\n  }\n  const isPositiveRange = firstChar >= charSet.firstPositive;\n  if (isPositiveRange) {\n    return distanceBetween(firstChar, charSet.firstPositive, charSet) + 2;\n  } else {\n    return distanceBetween(firstChar, charSet.firstNegative, charSet) + 2;\n  }\n}\nfunction integerLengthFromSecondLevel(key, direction, charSet) {\n  const firstChar = key[0];\n  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {\n    throw new Error(\"invalid firstChar on key\");\n  }\n  if (firstChar === charSet.mostPositive && direction === \"positive\") {\n    const totalPositiveRoom = distanceBetween(firstChar, charSet.mostNegative, charSet) + 1;\n    return totalPositiveRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);\n  }\n  if (firstChar === charSet.mostNegative && direction === \"negative\") {\n    const totalNegativeRoom = distanceBetween(firstChar, charSet.mostPositive, charSet) + 1;\n    return totalNegativeRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);\n  }\n  if (direction === \"positive\") {\n    return distanceBetween(firstChar, charSet.mostNegative, charSet) + 2;\n  } else {\n    return distanceBetween(firstChar, charSet.mostPositive, charSet) + 2;\n  }\n}\n\n// src/padToSameLength.ts\nfunction makeSameLength(a, b, pad, fillChar, forceLength) {\n  const max = forceLength ?? Math.max(a.length, b.length);\n  if (pad === \"start\") {\n    return [a.padStart(max, fillChar), b.padStart(max, fillChar)];\n  }\n  return [a.padEnd(max, fillChar), b.padEnd(max, fillChar)];\n}\n\n// src/keyAsNumber.ts\nfunction midPoint(lower, upper, charSet) {\n  let [paddedLower, paddedUpper] = makeSameLength(\n    lower,\n    upper,\n    \"end\",\n    charSet.first\n  );\n  let distance = lexicalDistance(paddedLower, paddedUpper, charSet);\n  if (distance === 1) {\n    paddedLower = paddedLower.padEnd(paddedLower.length + 1, charSet.first);\n    distance = charSet.length;\n  }\n  const mid = encodeToCharSet(Math.floor(distance / 2), charSet);\n  return addCharSetKeys(paddedLower, mid, charSet);\n}\nfunction lexicalDistance(a, b, charSet) {\n  const [lower, upper] = makeSameLength(a, b, \"end\", charSet.first).sort();\n  const distance = subtractCharSetKeys(upper, lower, charSet);\n  return decodeCharSetToNumber(distance, charSet);\n}\nfunction addCharSetKeys(a, b, charSet) {\n  const base = charSet.length;\n  const [paddedA, paddedB] = makeSameLength(a, b, \"start\", charSet.first);\n  const result = [];\n  let carry = 0;\n  for (let i = paddedA.length - 1; i >= 0; i--) {\n    const digitA = charSet.byChar[paddedA[i]];\n    const digitB = charSet.byChar[paddedB[i]];\n    const sum = digitA + digitB + carry;\n    carry = Math.floor(sum / base);\n    const remainder = sum % base;\n    result.unshift(charSet.byCode[remainder]);\n  }\n  if (carry > 0) {\n    result.unshift(charSet.byCode[carry]);\n  }\n  return result.join(\"\");\n}\nfunction subtractCharSetKeys(a, b, charSet) {\n  const base = charSet.length;\n  const [paddedA, paddedB] = makeSameLength(a, b, \"start\", charSet.first);\n  const result = [];\n  let borrow = 0;\n  for (let i = paddedA.length - 1; i >= 0; i--) {\n    let digitA = charSet.byChar[paddedA[i]];\n    const digitB = charSet.byChar[paddedB[i]] + borrow;\n    if (digitA < digitB) {\n      borrow = 1;\n      digitA += base;\n    } else {\n      borrow = 0;\n    }\n    const difference = digitA - digitB;\n    result.unshift(charSet.byCode[difference]);\n  }\n  if (borrow > 0) {\n    throw new Error(\n      \"Subtraction result is negative. Ensure a is greater than or equal to b.\"\n    );\n  }\n  while (result.length > 1 && result[0] === charSet.byCode[0]) {\n    result.shift();\n  }\n  return result.join(\"\");\n}\nfunction incrementKey(key, charSet) {\n  return addCharSetKeys(key, charSet.byCode[1], charSet);\n}\nfunction decrementKey(key, charSet) {\n  return subtractCharSetKeys(key, charSet.byCode[1], charSet);\n}\nfunction encodeToCharSet(int, charSet) {\n  if (int === 0) {\n    return charSet.byCode[0];\n  }\n  let res = \"\";\n  const max = charSet.length;\n  while (int > 0) {\n    res = charSet.byCode[int % max] + res;\n    int = Math.floor(int / max);\n  }\n  return res;\n}\nfunction decodeCharSetToNumber(key, charSet) {\n  let res = 0;\n  const length = key.length;\n  const max = charSet.length;\n  for (let i = 0; i < length; i++) {\n    res += charSet.byChar[key[i]] * Math.pow(max, length - i - 1);\n  }\n  return res;\n}\n\n// src/integer.ts\nfunction startKey(charSet) {\n  return charSet.firstPositive + charSet.byCode[0];\n}\nfunction validInteger(integer, charSet) {\n  const length = integerLength(integer, charSet);\n  return length === integer.length;\n}\nfunction validateOrderKey(orderKey, charSet) {\n  getIntegerPart(orderKey, charSet);\n}\nfunction getIntegerPart(orderKey, charSet) {\n  const head = integerHead(orderKey, charSet);\n  const integerPartLength = integerLength(head, charSet);\n  if (integerPartLength > orderKey.length) {\n    throw new Error(\"invalid order key length: \" + orderKey);\n  }\n  return orderKey.slice(0, integerPartLength);\n}\nfunction validateInteger(integer, charSet) {\n  if (!validInteger(integer, charSet)) {\n    throw new Error(\"invalid integer length: \" + integer);\n  }\n}\nfunction incrementInteger(integer, charSet) {\n  validateInteger(integer, charSet);\n  const [head, digs] = splitInteger(integer, charSet);\n  const anyNonMaxedDigit = digs.split(\"\").some((d) => d !== charSet.byCode[charSet.length - 1]);\n  if (anyNonMaxedDigit) {\n    const newDigits = incrementKey(digs, charSet);\n    return head + newDigits;\n  }\n  const nextHead = incrementIntegerHead(head, charSet);\n  return startOnNewHead(nextHead, \"lower\", charSet);\n}\nfunction decrementInteger(integer, charSet) {\n  validateInteger(integer, charSet);\n  const [head, digs] = splitInteger(integer, charSet);\n  const anyNonLimitDigit = digs.split(\"\").some((d) => d !== charSet.byCode[0]);\n  if (anyNonLimitDigit) {\n    const newDigits = decrementKey(digs, charSet);\n    return head + newDigits;\n  }\n  const nextHead = decrementIntegerHead(head, charSet);\n  return startOnNewHead(nextHead, \"upper\", charSet);\n}\nfunction integerHead(integer, charSet) {\n  let i = 0;\n  if (integer[0] === charSet.mostPositive) {\n    while (integer[i] === charSet.mostPositive) {\n      i = i + 1;\n    }\n  }\n  if (integer[0] === charSet.mostNegative) {\n    while (integer[i] === charSet.mostNegative) {\n      i = i + 1;\n    }\n  }\n  return integer.slice(0, i + 1);\n}\nfunction splitInteger(integer, charSet) {\n  const head = integerHead(integer, charSet);\n  const tail = integer.slice(head.length);\n  return [head, tail];\n}\nfunction incrementIntegerHead(head, charSet) {\n  const inPositiveRange = head >= charSet.firstPositive;\n  const nextHead = incrementKey(head, charSet);\n  const headIsLimitMax = head[head.length - 1] === charSet.mostPositive;\n  const nextHeadIsLimitMax = nextHead[nextHead.length - 1] === charSet.mostPositive;\n  if (inPositiveRange && nextHeadIsLimitMax) {\n    return nextHead + charSet.mostNegative;\n  }\n  if (!inPositiveRange && headIsLimitMax) {\n    return head.slice(0, head.length - 1);\n  }\n  return nextHead;\n}\nfunction decrementIntegerHead(head, charSet) {\n  const inPositiveRange = head >= charSet.firstPositive;\n  const headIsLimitMin = head[head.length - 1] === charSet.mostNegative;\n  if (inPositiveRange && headIsLimitMin) {\n    const nextLevel = head.slice(0, head.length - 1);\n    return decrementKey(nextLevel, charSet);\n  }\n  if (!inPositiveRange && headIsLimitMin) {\n    return head + charSet.mostPositive;\n  }\n  return decrementKey(head, charSet);\n}\nfunction startOnNewHead(head, limit, charSet) {\n  const newLength = integerLength(head, charSet);\n  const fillChar = limit === \"upper\" ? charSet.byCode[charSet.length - 1] : charSet.byCode[0];\n  return head + fillChar.repeat(newLength - head.length);\n}\n\n// src/jittering.ts\nfunction jitterString(orderKey, charSet) {\n  const shift = encodeToCharSet(\n    Math.floor(Math.random() * charSet.jitterRange),\n    charSet\n  );\n  return addCharSetKeys(orderKey, shift, charSet);\n}\nfunction padAndJitterString(orderKey, numberOfChars, charSet) {\n  const paddedKey = orderKey.padEnd(\n    orderKey.length + numberOfChars,\n    charSet.first\n  );\n  return jitterString(paddedKey, charSet);\n}\nfunction paddingNeededForJitter(orderKey, b, charSet) {\n  const integer = getIntegerPart(orderKey, charSet);\n  const nextInteger = incrementInteger(integer, charSet);\n  let needed = 0;\n  if (b !== null) {\n    const distanceToB = lexicalDistance(orderKey, b, charSet);\n    if (distanceToB < charSet.jitterRange + 1) {\n      needed = Math.max(needed, paddingNeededForDistance(distanceToB, charSet));\n    }\n  }\n  const distanceToNextInteger = lexicalDistance(orderKey, nextInteger, charSet);\n  if (distanceToNextInteger < charSet.jitterRange + 1) {\n    needed = Math.max(\n      needed,\n      paddingNeededForDistance(distanceToNextInteger, charSet)\n    );\n  }\n  return needed;\n}\nfunction paddingNeededForDistance(distance, charSet) {\n  const gap = charSet.jitterRange - distance;\n  const firstBigger = Object.entries(charSet.paddingDict).find(\n    ([_key, value]) => {\n      return value > gap;\n    }\n  );\n  return firstBigger ? parseInt(firstBigger[0]) : 0;\n}\n\n// src/generateKeyBetween.ts\nfunction generateKeyBetween(lower, upper, charSet = base62CharSet()) {\n  if (lower !== null) {\n    validateOrderKey(lower, charSet);\n  }\n  if (upper !== null) {\n    validateOrderKey(upper, charSet);\n  }\n  if (lower === null && upper === null) {\n    return startKey(charSet);\n  }\n  if (lower === null) {\n    const integer = getIntegerPart(upper, charSet);\n    return decrementInteger(integer, charSet);\n  }\n  if (upper === null) {\n    const integer = getIntegerPart(lower, charSet);\n    return incrementInteger(integer, charSet);\n  }\n  if (lower >= upper) {\n    throw new Error(lower + \" >= \" + upper);\n  }\n  return midPoint(lower, upper, charSet);\n}\nfunction generateNKeysBetween(a, b, n, charSet = base62CharSet()) {\n  return spreadGeneratorResults(\n    a,\n    b,\n    n,\n    charSet,\n    generateKeyBetween,\n    generateNKeysBetween\n  );\n}\nfunction generateJitteredKeyBetween(lower, upper, charSet = base62CharSet()) {\n  const key = generateKeyBetween(lower, upper, charSet);\n  const paddingNeeded = paddingNeededForJitter(key, upper, charSet);\n  if (paddingNeeded) {\n    return padAndJitterString(key, paddingNeeded, charSet);\n  }\n  return jitterString(key, charSet);\n}\nfunction generateNJitteredKeysBetween(lower, upper, n, charSet = base62CharSet()) {\n  return spreadGeneratorResults(\n    lower,\n    upper,\n    n,\n    charSet,\n    generateJitteredKeyBetween,\n    generateNJitteredKeysBetween\n  );\n}\nfunction spreadGeneratorResults(lower, upper, n, charSet, generateKey, generateNKeys) {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [generateKey(lower, upper, charSet)];\n  }\n  if (upper == null) {\n    let newUpper = generateKey(lower, upper, charSet);\n    const result = [newUpper];\n    for (let i = 0; i < n - 1; i++) {\n      newUpper = generateKey(newUpper, upper, charSet);\n      result.push(newUpper);\n    }\n    return result;\n  }\n  if (lower == null) {\n    let newLower = generateKey(lower, upper, charSet);\n    const result = [newLower];\n    for (let i = 0; i < n - 1; i++) {\n      newLower = generateKey(lower, newLower, charSet);\n      result.push(newLower);\n    }\n    result.reverse();\n    return result;\n  }\n  const mid = Math.floor(n / 2);\n  const midOrderKey = generateKey(lower, upper, charSet);\n  return [\n    ...generateNKeys(lower, midOrderKey, mid, charSet),\n    midOrderKey,\n    ...generateNKeys(midOrderKey, upper, n - mid - 1, charSet)\n  ];\n}\n\n// src/IndexGenerator.ts\nvar IndexGenerator = class {\n  charSet;\n  useJitter;\n  list;\n  useGroups;\n  groupIdLength;\n  constructor(list, options = {}) {\n    this.charSet = options.charSet ?? base62CharSet();\n    this.useJitter = options.useJitter ?? true;\n    this.list = list;\n    this.useGroups = !!options.groupIdLength && options.groupIdLength > 0;\n    this.groupIdLength = options.groupIdLength ?? 0;\n  }\n  /**\n   * Updates the list that the generator uses to generate keys.\n   * The generator will not mutate the internal list when generating keys.\n   */\n  updateList(list) {\n    this.list = [...list].sort();\n  }\n  /**\n   * Generate any number of keys at the start of the list (before the first key).\n   * Optionally you can supply a groupId to generate keys at the start of a specific group.\n   */\n  nKeysStart(n, groupId) {\n    this.validateGroupId(groupId);\n    return this.generateNKeysBetween(\n      null,\n      this.firstOfGroup(groupId),\n      n,\n      groupId\n    );\n  }\n  /**\n   * Generate a single key at the start of the list (before the first key).\n   * Optionally you can supply a groupId to generate a key at the start of a specific group.\n   */\n  keyStart(groupId) {\n    this.validateGroupId(groupId);\n    return this.nKeysStart(1, groupId)[0];\n  }\n  /**\n   * Generate any number of keys at the end of the list (after the last key).\n   * Optionally you can supply a groupId to generate keys at the end of a specific group.\n   */\n  nKeysEnd(n, groupId) {\n    this.validateGroupId(groupId);\n    return this.generateNKeysBetween(\n      this.lastOfGroup(groupId),\n      null,\n      n,\n      groupId\n    );\n  }\n  /**\n   * Generate a single key at the end of the list (after the last key).\n   * Optionally you can supply a groupId to generate a key at the end of a specific group.\n   */\n  keyEnd(groupId) {\n    this.validateGroupId(groupId);\n    return this.nKeysEnd(1, groupId)[0];\n  }\n  /**\n   * Generate any number of keys behind a specific key and in front of the next key.\n   * GroupId will be inferred from the orderKey if working with groups\n   */\n  nKeysAfter(orderKey, n) {\n    const keyAfter = this.getKeyAfter(orderKey);\n    return this.generateNKeysBetween(\n      orderKey,\n      keyAfter,\n      n,\n      this.groupId(orderKey)\n    );\n  }\n  /**\n   * Generate a single key behind a specific key and in front of the next key.\n   * GroupId will be inferred from the orderKey if working with groups\n   */\n  keyAfter(orderKey) {\n    return this.nKeysAfter(orderKey, 1)[0];\n  }\n  /**\n   * Generate any number of keys in front of a specific key and behind the previous key.\n   * GroupId will be inferred from the orderKey if working with groups\n   */\n  nKeysBefore(orderKey, n) {\n    const keyBefore = this.getKeyBefore(orderKey);\n    return this.generateNKeysBetween(\n      keyBefore,\n      orderKey,\n      n,\n      this.groupId(orderKey)\n    );\n  }\n  /**\n   * Generate a single key in front of a specific key and behind the previous key.\n   * GroupId will be inferred from the orderKey if working with groups\n   */\n  keyBefore(orderKey) {\n    return this.nKeysBefore(orderKey, 1)[0];\n  }\n  /**\n   * private function responsible for calling the correct generate function\n   */\n  generateNKeysBetween(lowerKey, upperKey, n, groupId) {\n    const lower = this.groupLessKey(lowerKey);\n    const upper = this.groupLessKey(upperKey);\n    const keys = this.useJitter ? generateNJitteredKeysBetween(lower, upper, n, this.charSet) : generateNKeysBetween(lower, upper, n, this.charSet);\n    return !groupId ? keys : keys.map((key) => groupId + key);\n  }\n  /**\n   * get the key before the supplied orderKey, if it exists and is in the same group\n   */\n  getKeyBefore(orderKey) {\n    const index = this.list.indexOf(orderKey);\n    if (index === -1) {\n      throw new Error(`orderKey is not in the list`);\n    }\n    const before = this.list[index - 1];\n    return !!before && this.isSameGroup(orderKey, before) ? before : null;\n  }\n  /**\n   * get the key after the supplied orderKey, if it exists and is in the same group\n   */\n  getKeyAfter(orderKey) {\n    const index = this.list.indexOf(orderKey);\n    if (index === -1) {\n      throw new Error(`orderKey is not in the list`);\n    }\n    const after = this.list[index + 1];\n    return !!after && this.isSameGroup(orderKey, after) ? after : null;\n  }\n  /**\n   * get the first key of the group (or the first key of the list if not using groups)\n   */\n  firstOfGroup(groupId) {\n    if (!this.useGroups)\n      return this.list[0] ?? null;\n    const first = this.list.find((key) => this.isPartOfGroup(key, groupId));\n    return first ?? null;\n  }\n  /**\n   * get the last key of the group (or the last key of the list if not using groups)\n   */\n  lastOfGroup(groupId) {\n    if (!this.useGroups)\n      return this.list[this.list.length - 1] ?? null;\n    const allGroupItems = this.list.filter(\n      (key) => this.isPartOfGroup(key, groupId)\n    );\n    const last = allGroupItems[allGroupItems.length - 1];\n    return last ?? null;\n  }\n  /**\n   * throw an error if the groupId is invalid or supplied when not using groups\n   */\n  validateGroupId(groupId) {\n    if (!this.useGroups) {\n      if (groupId) {\n        console.warn(\"groupId should not used when not using groups\");\n      }\n      return;\n    }\n    if (!groupId) {\n      throw new Error(\"groupId is required when using groups\");\n    }\n    if (groupId.length !== this.groupIdLength) {\n      throw new Error(`groupId must be the lenght supplied in the options`);\n    }\n  }\n  /**\n   * get the groupId from the orderKey\n   */\n  groupId(orderKey) {\n    if (!this.useGroups)\n      return void 0;\n    return this.splitIntoGroupIdAndOrderKey(orderKey)[0];\n  }\n  /**\n   * remove the groupId from the orderKey\n   */\n  groupLessKey(orderKey) {\n    if (!this.useGroups)\n      return orderKey;\n    return this.splitIntoGroupIdAndOrderKey(orderKey)[1];\n  }\n  /**\n   * split the orderKey into groupId and key\n   * if not using groups, orderKey will be the same as key\n   */\n  splitIntoGroupIdAndOrderKey(orderKey) {\n    if (!this.useGroups || !orderKey) {\n      return [void 0, orderKey];\n    }\n    const groupId = orderKey.substring(0, this.groupIdLength);\n    const key = orderKey.substring(this.groupIdLength);\n    return [groupId, key];\n  }\n  /**\n   * check if two keys are in the same group\n   * if not using groups, keys will always be in the same group\n   */\n  isSameGroup(a, b) {\n    if (!this.useGroups)\n      return true;\n    const [aGroupId] = this.splitIntoGroupIdAndOrderKey(a);\n    const [bGroupId] = this.splitIntoGroupIdAndOrderKey(b);\n    return aGroupId === bGroupId;\n  }\n  /**\n   * check if the key is part of the group\n   * if not using groups, key will always be part of the group\n   */\n  isPartOfGroup(orderKey, groupId) {\n    if (!this.useGroups)\n      return true;\n    const [keyGroupId] = this.splitIntoGroupIdAndOrderKey(orderKey);\n    return keyGroupId === groupId;\n  }\n};\nexport {\n  IndexGenerator,\n  base62CharSet,\n  generateJitteredKeyBetween,\n  generateKeyBetween,\n  generateNJitteredKeysBetween,\n  generateNKeysBetween,\n  indexCharacterSet\n};\n", "/** @public */\nexport function sortById<T extends { id: any }>(a: T, b: T) {\n\treturn a.id > b.id ? 1 : -1\n}\n", "/* eslint-disable no-restricted-syntax */\n\n/**\n * Get a value from local storage.\n *\n * @param key - The key to get.\n *\n * @internal\n */\nexport function getFromLocalStorage(key: string) {\n\ttry {\n\t\treturn localStorage.getItem(key)\n\t} catch {\n\t\treturn null\n\t}\n}\n\n/**\n * Set a value in local storage. Will not throw an error if localStorage is not available.\n *\n * @param key - The key to set.\n * @param value - The value to set.\n *\n * @internal\n */\nexport function setInLocalStorage(key: string, value: string) {\n\ttry {\n\t\tlocalStorage.setItem(key, value)\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Remove a value from local storage. Will not throw an error if localStorage is not available.\n *\n * @param key - The key to set.\n *\n * @internal\n */\nexport function deleteFromLocalStorage(key: string) {\n\ttry {\n\t\tlocalStorage.removeItem(key)\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Clear all values from local storage. Will not throw an error if localStorage is not available.\n *\n * @internal\n */\nexport function clearLocalStorage() {\n\ttry {\n\t\tlocalStorage.clear()\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Get a value from session storage.\n *\n * @param key - The key to get.\n *\n * @internal\n */\nexport function getFromSessionStorage(key: string) {\n\ttry {\n\t\treturn sessionStorage.getItem(key)\n\t} catch {\n\t\treturn null\n\t}\n}\n\n/**\n * Set a value in session storage. Will not throw an error if sessionStorage is not available.\n *\n * @param key - The key to set.\n * @param value - The value to set.\n *\n * @internal\n */\nexport function setInSessionStorage(key: string, value: string) {\n\ttry {\n\t\tsessionStorage.setItem(key, value)\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Remove a value from session storage. Will not throw an error if sessionStorage is not available.\n *\n * @param key - The key to set.\n *\n * @internal\n */\nexport function deleteFromSessionStorage(key: string) {\n\ttry {\n\t\tsessionStorage.removeItem(key)\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Clear all values from session storage. Will not throw an error if sessionStorage is not available.\n *\n * @internal\n */\nexport function clearSessionStorage() {\n\ttry {\n\t\tsessionStorage.clear()\n\t} catch {\n\t\t// noop\n\t}\n}\n", "const isTest = () =>\n\ttypeof process !== 'undefined' &&\n\tprocess.env.NODE_ENV === 'test' &&\n\t// @ts-expect-error\n\t!globalThis.__FORCE_RAF_IN_TESTS__\n\nconst fpsQueue: Array<() => void> = []\nconst targetFps = 60\nconst targetTimePerFrame = Math.ceil(1000 / targetFps)\nlet frame: number | undefined\nlet time = 0\nlet last = 0\n\nconst flush = () => {\n\tconst queue = fpsQueue.splice(0, fpsQueue.length)\n\tfor (const fn of queue) {\n\t\tfn()\n\t}\n}\n\nfunction tick() {\n\tif (frame) {\n\t\treturn\n\t}\n\tconst now = Date.now()\n\tconst elapsed = now - last\n\n\tif (time + elapsed < targetTimePerFrame) {\n\t\t// It's up to the consumer of debounce to call `cancel`\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tframe = requestAnimationFrame(() => {\n\t\t\tframe = undefined\n\t\t\ttick()\n\t\t})\n\t\treturn\n\t}\n\t// It's up to the consumer of debounce to call `cancel`\n\t// eslint-disable-next-line no-restricted-globals\n\tframe = requestAnimationFrame(() => {\n\t\tframe = undefined\n\t\tlast = now\n\t\t// If we fall behind more than 10 frames, we'll just reset the time so we don't try to update a number of times\n\t\t// This can happen if we don't interact with the page for a while\n\t\ttime = Math.min(time + elapsed - targetTimePerFrame, targetTimePerFrame * 10)\n\t\tflush()\n\t})\n}\n\nlet started = false\n\n/**\n * Returns a throttled version of the function that will only be called max once per frame.\n * The target frame rate is 60fps.\n * @param fn - the fun to return a throttled version of\n * @returns\n * @internal\n */\nexport function fpsThrottle(fn: { (): void; cancel?(): void }): {\n\t(): void\n\tcancel?(): void\n} {\n\tif (isTest()) {\n\t\tfn.cancel = () => frame && cancelAnimationFrame(frame)\n\t\treturn fn\n\t}\n\n\tconst throttledFn = () => {\n\t\tif (fpsQueue.includes(fn)) {\n\t\t\treturn\n\t\t}\n\t\tfpsQueue.push(fn)\n\t\tif (!started) {\n\t\t\tstarted = true\n\t\t\t// We set last to Date.now() - targetTimePerFrame - 1 so that the first run will happen immediately\n\t\t\tlast = Date.now() - targetTimePerFrame - 1\n\t\t}\n\t\ttick()\n\t}\n\tthrottledFn.cancel = () => {\n\t\tconst index = fpsQueue.indexOf(fn)\n\t\tif (index > -1) {\n\t\t\tfpsQueue.splice(index, 1)\n\t\t}\n\t}\n\treturn throttledFn\n}\n\n/**\n * Calls the function on the next frame. The target frame rate is 60fps.\n * If the same fn is passed again before the next frame, it will still be called only once.\n * @param fn - the fun to call on the next frame\n * @returns a function that will cancel the call if called before the next frame\n * @internal\n */\nexport function throttleToNextFrame(fn: () => void): () => void {\n\tif (isTest()) {\n\t\tfn()\n\t\treturn () => {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tif (!fpsQueue.includes(fn)) {\n\t\tfpsQueue.push(fn)\n\t\tif (!started) {\n\t\t\tstarted = true\n\t\t\t// We set last to Date.now() - targetTimePerFrame - 1 so that the first run will happen immediately\n\t\t\tlast = Date.now() - targetTimePerFrame - 1\n\t\t}\n\t\ttick()\n\t}\n\n\treturn () => {\n\t\tconst index = fpsQueue.indexOf(fn)\n\t\tif (index > -1) {\n\t\t\tfpsQueue.splice(index, 1)\n\t\t}\n\t}\n}\n", "/* eslint-disable no-restricted-properties */\n\n/** @public */\nexport class Timers {\n\tprivate timeouts = new Map<string, number[]>()\n\tprivate intervals = new Map<string, number[]>()\n\tprivate rafs = new Map<string, number[]>()\n\n\tconstructor() {\n\t\tthis.setTimeout = this.setTimeout.bind(this)\n\t\tthis.setInterval = this.setInterval.bind(this)\n\t\tthis.requestAnimationFrame = this.requestAnimationFrame.bind(this)\n\t\tthis.dispose = this.dispose.bind(this)\n\t}\n\n\t/** @public */\n\tsetTimeout(contextId: string, handler: TimerHandler, timeout?: number, ...args: any[]): number {\n\t\tconst id = window.setTimeout(handler, timeout, args)\n\t\tconst current = this.timeouts.get(contextId) ?? []\n\t\tthis.timeouts.set(contextId, [...current, id])\n\t\treturn id\n\t}\n\n\t/** @public */\n\tsetInterval(contextId: string, handler: TimerHandler, timeout?: number, ...args: any[]): number {\n\t\tconst id = window.setInterval(handler, timeout, args)\n\t\tconst current = this.intervals.get(contextId) ?? []\n\t\tthis.intervals.set(contextId, [...current, id])\n\t\treturn id\n\t}\n\n\t/** @public */\n\trequestAnimationFrame(contextId: string, callback: FrameRequestCallback): number {\n\t\tconst id = window.requestAnimationFrame(callback)\n\t\tconst current = this.rafs.get(contextId) ?? []\n\t\tthis.rafs.set(contextId, [...current, id])\n\t\treturn id\n\t}\n\n\t/** @public */\n\tdispose(contextId: string) {\n\t\tthis.timeouts.get(contextId)?.forEach((id) => clearTimeout(id))\n\t\tthis.intervals.get(contextId)?.forEach((id) => clearInterval(id))\n\t\tthis.rafs.get(contextId)?.forEach((id) => cancelAnimationFrame(id))\n\n\t\tthis.timeouts.delete(contextId)\n\t\tthis.intervals.delete(contextId)\n\t\tthis.rafs.delete(contextId)\n\t}\n\n\tdisposeAll() {\n\t\tfor (const contextId of this.timeouts.keys()) {\n\t\t\tthis.dispose(contextId)\n\t\t}\n\t}\n\n\tforContext(contextId: string) {\n\t\treturn {\n\t\t\tsetTimeout: (handler: TimerHandler, timeout?: number, ...args: any[]) =>\n\t\t\t\tthis.setTimeout(contextId, handler, timeout, args),\n\t\t\tsetInterval: (handler: TimerHandler, timeout?: number, ...args: any[]) =>\n\t\t\t\tthis.setInterval(contextId, handler, timeout, args),\n\t\t\trequestAnimationFrame: (callback: FrameRequestCallback) =>\n\t\t\t\tthis.requestAnimationFrame(contextId, callback),\n\t\t\tdispose: () => this.dispose(contextId),\n\t\t}\n\t}\n}\n", "/** @public */\nexport const safeParseUrl = (url: string, baseUrl?: string | URL) => {\n\ttry {\n\t\treturn new URL(url, baseUrl)\n\t} catch (err) {\n\t\treturn\n\t}\n}\n", "/**\n * Get whether a value is not undefined.\n *\n * @param value - The value to check.\n * @public\n */\nexport function isDefined<T>(value: T): value is typeof value extends undefined ? never : T {\n\treturn value !== undefined\n}\n\n/**\n * Get whether a value is null\n *\n * @param value - The value to check.\n * @public\n */\nexport function isNonNull<T>(value: T): value is typeof value extends null ? never : T {\n\treturn value !== null\n}\n\n/**\n * Get whether a value is nullish (null, undefined).\n *\n * @param value - The value to check.\n * @public\n */\nexport function isNonNullish<T>(\n\tvalue: T\n): value is typeof value extends undefined ? never : typeof value extends null ? never : T {\n\treturn value !== null && value !== undefined\n}\n\nfunction getStructuredClone(): [<T>(i: T) => T, boolean] {\n\tif (typeof globalThis !== 'undefined' && (globalThis as any).structuredClone) {\n\t\treturn [globalThis.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\tif (typeof global !== 'undefined' && (global as any).structuredClone) {\n\t\treturn [global.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\tif (typeof window !== 'undefined' && (window as any).structuredClone) {\n\t\treturn [window.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\treturn [<T>(i: T): T => (i ? JSON.parse(JSON.stringify(i)) : i), false]\n}\n\nconst _structuredClone = getStructuredClone()\n\n/**\n * Create a deep copy of a value. Uses the structuredClone API if available, otherwise uses JSON.parse(JSON.stringify()).\n *\n * @param i - The value to clone.\n * @public */\nexport const structuredClone = _structuredClone[0]\n\n/**\n * @internal\n */\nexport const isNativeStructuredClone = _structuredClone[1]\n\n/**\n * When we patch structuredClone in jsdom for testing (see https://github.com/jsdom/jsdom/issues/3363),\n * the Object that is used as a prototype for the cloned object is not the same as the Object in\n * the code under test (that comes from jsdom's fake global context). This constant is used in\n * our code to work around this case.\n *\n * This is also the case for Array prototype, but that problem can be worked around with an\n * Array.isArray() check.\n * @internal\n */\nexport const STRUCTURED_CLONE_OBJECT_PROTOTYPE = Object.getPrototypeOf(structuredClone({}))\n", "const usedWarnings = new Set<string>()\n\n/** @internal */\nexport function warnDeprecatedGetter(name: string) {\n\twarnOnce(\n\t\t`Using '${name}' is deprecated and will be removed in the near future. Please refactor to use 'get${name[0].toLocaleUpperCase()}${name.slice(\n\t\t\t1\n\t\t)}' instead.`\n\t)\n}\n\n/** @internal */\nexport function warnOnce(message: string) {\n\tif (usedWarnings.has(message)) return\n\n\tusedWarnings.add(message)\n\tconsole.warn(`[tldraw] ${message}`)\n}\n", "import { atom, Atom } from '@tldraw/state'\nimport { TLRecord } from '@tldraw/tlschema'\nimport { assert, warnOnce } from '@tldraw/utils'\nimport { chunk } from './chunk'\nimport { TLSocketClientSentEvent, TLSocketServerSentEvent } from './protocol'\nimport {\n\tTLPersistentClientSocket,\n\tTLPersistentClientSocketStatus,\n\tTLSocketStatusListener,\n\tTLSyncErrorCloseEventCode,\n\tTLSyncErrorCloseEventReason,\n} from './TLSyncClient'\n\nfunction listenTo<T extends EventTarget>(target: T, event: string, handler: () => void) {\n\ttarget.addEventListener(event, handler)\n\treturn () => {\n\t\ttarget.removeEventListener(event, handler)\n\t}\n}\n\nfunction debug(...args: any[]) {\n\t// @ts-ignore\n\tif (typeof window !== 'undefined' && window.__tldraw_socket_debug) {\n\t\tconst now = new Date()\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(\n\t\t\t`${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`,\n\t\t\t...args\n\t\t\t//, new Error().stack\n\t\t)\n\t}\n}\n\n// NOTE: ClientWebSocketAdapter requires its users to implement their own connection loss\n//       detection, for example by regularly pinging the server and .restart()ing\n//       the connection when a number of pings goes unanswered. Without this mechanism,\n//       we might not be able to detect the websocket connection going down in a timely manner\n//       (it will probably time out on outgoing data packets at some point).\n//\n//       This is by design. While the Websocket protocol specifies protocol-level pings,\n//       they don't seem to be surfaced in browser APIs and can't be relied on. Therefore,\n//       pings need to be implemented one level up, on the application API side, which for our\n//       codebase means whatever code that uses ClientWebSocketAdapter.\n/** @internal */\nexport class ClientWebSocketAdapter implements TLPersistentClientSocket<TLRecord> {\n\t_ws: WebSocket | null = null\n\n\tisDisposed = false\n\n\t/** @internal */\n\treadonly _reconnectManager: ReconnectManager\n\n\t// TODO: .close should be a project-wide interface with a common contract (.close()d thing\n\t//       can only be garbage collected, and can't be used anymore)\n\tclose() {\n\t\tthis.isDisposed = true\n\t\tthis._reconnectManager.close()\n\t\t//  WebSocket.close() is idempotent\n\t\tthis._ws?.close()\n\t}\n\n\tconstructor(getUri: () => Promise<string> | string) {\n\t\tthis._reconnectManager = new ReconnectManager(this, getUri)\n\t}\n\n\tprivate _handleConnect() {\n\t\tdebug('handleConnect')\n\n\t\tthis._connectionStatus.set('online')\n\t\tthis.statusListeners.forEach((cb) => cb({ status: 'online' }))\n\n\t\tthis._reconnectManager.connected()\n\t}\n\n\tprivate _handleDisconnect(\n\t\treason: 'closed' | 'error' | 'manual',\n\t\tcloseCode?: number,\n\t\tdidOpen?: boolean,\n\t\tcloseReason?: string\n\t) {\n\t\tcloseReason = closeReason || TLSyncErrorCloseEventReason.UNKNOWN_ERROR\n\n\t\tdebug('handleDisconnect', {\n\t\t\tcurrentStatus: this.connectionStatus,\n\t\t\tcloseCode,\n\t\t\treason,\n\t\t})\n\n\t\tlet newStatus: 'offline' | 'error'\n\t\tswitch (reason) {\n\t\t\tcase 'closed':\n\t\t\t\tif (closeCode === TLSyncErrorCloseEventCode) {\n\t\t\t\t\tnewStatus = 'error'\n\t\t\t\t} else {\n\t\t\t\t\tnewStatus = 'offline'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'error':\n\t\t\t\tnewStatus = 'error'\n\t\t\t\tbreak\n\t\t\tcase 'manual':\n\t\t\t\tnewStatus = 'offline'\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (closeCode === 1006 && !didOpen) {\n\t\t\twarnOnce(\n\t\t\t\t\"Could not open WebSocket connection. This might be because you're trying to load a URL that doesn't support websockets. Check the URL you're trying to connect to.\"\n\t\t\t)\n\t\t}\n\n\t\tif (\n\t\t\t// it the status changed\n\t\t\tthis.connectionStatus !== newStatus &&\n\t\t\t// ignore errors if we're already in the offline state\n\t\t\t!(newStatus === 'error' && this.connectionStatus === 'offline')\n\t\t) {\n\t\t\tthis._connectionStatus.set(newStatus)\n\t\t\tthis.statusListeners.forEach((cb) =>\n\t\t\t\tcb(newStatus === 'error' ? { status: 'error', reason: closeReason } : { status: newStatus })\n\t\t\t)\n\t\t}\n\n\t\tthis._reconnectManager.disconnected()\n\t}\n\n\t_setNewSocket(ws: WebSocket) {\n\t\tassert(!this.isDisposed, 'Tried to set a new websocket on a disposed socket')\n\t\tassert(\n\t\t\tthis._ws === null ||\n\t\t\t\tthis._ws.readyState === WebSocket.CLOSED ||\n\t\t\t\tthis._ws.readyState === WebSocket.CLOSING,\n\t\t\t`Tried to set a new websocket in when the existing one was ${this._ws?.readyState}`\n\t\t)\n\n\t\tlet didOpen = false\n\n\t\t// NOTE: Sockets can stay for quite a while in the CLOSING state. This is because the transition\n\t\t//       between CLOSING and CLOSED happens either after the closing handshake, or after a\n\t\t//       timeout, but in either case those sockets don't need any special handling, the browser\n\t\t//       will close them eventually. We just \"orphan\" such sockets and ignore their onclose/onerror.\n\t\tws.onopen = () => {\n\t\t\tdebug('ws.onopen')\n\t\t\tassert(\n\t\t\t\tthis._ws === ws,\n\t\t\t\t\"sockets must only be orphaned when they are CLOSING or CLOSED, so they can't open\"\n\t\t\t)\n\t\t\tdidOpen = true\n\t\t\tthis._handleConnect()\n\t\t}\n\t\tws.onclose = (event: CloseEvent) => {\n\t\t\tdebug('ws.onclose', event)\n\t\t\tif (this._ws === ws) {\n\t\t\t\tthis._handleDisconnect('closed', event.code, didOpen, event.reason)\n\t\t\t} else {\n\t\t\t\tdebug('ignoring onclose for an orphaned socket')\n\t\t\t}\n\t\t}\n\t\tws.onerror = (event) => {\n\t\t\tdebug('ws.onerror', event)\n\t\t\tif (this._ws === ws) {\n\t\t\t\tthis._handleDisconnect('error')\n\t\t\t} else {\n\t\t\t\tdebug('ignoring onerror for an orphaned socket')\n\t\t\t}\n\t\t}\n\t\tws.onmessage = (ev) => {\n\t\t\tassert(\n\t\t\t\tthis._ws === ws,\n\t\t\t\t\"sockets must only be orphaned when they are CLOSING or CLOSED, so they can't receive messages\"\n\t\t\t)\n\t\t\tconst parsed = JSON.parse(ev.data.toString())\n\t\t\tthis.messageListeners.forEach((cb) => cb(parsed))\n\t\t}\n\n\t\tthis._ws = ws\n\t}\n\n\t_closeSocket() {\n\t\tif (this._ws === null) return\n\n\t\tthis._ws.close()\n\t\t// explicitly orphan the socket to ignore its onclose/onerror, because onclose can be delayed\n\t\tthis._ws = null\n\t\tthis._handleDisconnect('manual')\n\t}\n\n\t// TLPersistentClientSocket stuff\n\n\t_connectionStatus: Atom<TLPersistentClientSocketStatus | 'initial'> = atom(\n\t\t'websocket connection status',\n\t\t'initial'\n\t)\n\n\t// eslint-disable-next-line no-restricted-syntax\n\tget connectionStatus(): TLPersistentClientSocketStatus {\n\t\tconst status = this._connectionStatus.get()\n\t\treturn status === 'initial' ? 'offline' : status\n\t}\n\n\tsendMessage(msg: TLSocketClientSentEvent<TLRecord>) {\n\t\tassert(!this.isDisposed, 'Tried to send message on a disposed socket')\n\n\t\tif (!this._ws) return\n\t\tif (this.connectionStatus === 'online') {\n\t\t\tconst chunks = chunk(JSON.stringify(msg))\n\t\t\tfor (const part of chunks) {\n\t\t\t\tthis._ws.send(part)\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn('Tried to send message while ' + this.connectionStatus)\n\t\t}\n\t}\n\n\tprivate messageListeners = new Set<(msg: TLSocketServerSentEvent<TLRecord>) => void>()\n\tonReceiveMessage(cb: (val: TLSocketServerSentEvent<TLRecord>) => void) {\n\t\tassert(!this.isDisposed, 'Tried to add message listener on a disposed socket')\n\n\t\tthis.messageListeners.add(cb)\n\t\treturn () => {\n\t\t\tthis.messageListeners.delete(cb)\n\t\t}\n\t}\n\n\tprivate statusListeners = new Set<TLSocketStatusListener>()\n\tonStatusChange(cb: TLSocketStatusListener) {\n\t\tassert(!this.isDisposed, 'Tried to add status listener on a disposed socket')\n\n\t\tthis.statusListeners.add(cb)\n\t\treturn () => {\n\t\t\tthis.statusListeners.delete(cb)\n\t\t}\n\t}\n\n\trestart() {\n\t\tassert(!this.isDisposed, 'Tried to restart a disposed socket')\n\t\tdebug('restarting')\n\n\t\tthis._closeSocket()\n\t\tthis._reconnectManager.maybeReconnected()\n\t}\n}\n\n// Those constants are exported primarily for tests\n// ACTIVE_ means the tab is active, document.hidden is false\nexport const ACTIVE_MIN_DELAY = 500\nexport const ACTIVE_MAX_DELAY = 2000\n// Correspondingly, here document.hidden is true. It's intended to reduce the load and battery drain\n// on client devices somewhat when they aren't looking at the tab. We don't disconnect completely\n// to minimise issues with reconnection/sync when the tab becomes visible again\nexport const INACTIVE_MIN_DELAY = 1000\nexport const INACTIVE_MAX_DELAY = 1000 * 60 * 5\nexport const DELAY_EXPONENT = 1.5\n// this is a tradeoff between quickly detecting connections stuck in the CONNECTING state and\n// not needlessly reconnecting if the connection is just slow to establish\nexport const ATTEMPT_TIMEOUT = 1000\n\n/** @internal */\nexport class ReconnectManager {\n\tprivate isDisposed = false\n\tprivate disposables: (() => void)[] = [\n\t\t() => {\n\t\t\tif (this.reconnectTimeout) clearTimeout(this.reconnectTimeout)\n\t\t\tif (this.recheckConnectingTimeout) clearTimeout(this.recheckConnectingTimeout)\n\t\t},\n\t]\n\tprivate reconnectTimeout: ReturnType<typeof setTimeout> | null = null\n\tprivate recheckConnectingTimeout: ReturnType<typeof setTimeout> | null = null\n\n\tprivate lastAttemptStart: number | null = null\n\tintendedDelay: number = ACTIVE_MIN_DELAY\n\tprivate state: 'pendingAttempt' | 'pendingAttemptResult' | 'delay' | 'connected'\n\n\tconstructor(\n\t\tprivate socketAdapter: ClientWebSocketAdapter,\n\t\tprivate getUri: () => Promise<string> | string\n\t) {\n\t\tthis.subscribeToReconnectHints()\n\n\t\tthis.disposables.push(\n\t\t\tlistenTo(window, 'offline', () => {\n\t\t\t\tdebug('window went offline')\n\t\t\t\t// On the one hand, 'offline' event is not really reliable; on the other, the only\n\t\t\t\t// alternative is to wait for pings not being delivered, which takes more than 20 seconds,\n\t\t\t\t// which means we won't see the ClientWebSocketAdapter status change for more than\n\t\t\t\t// 20 seconds after the tab goes offline. Our application layer must be resistent to\n\t\t\t\t// connection restart anyway, so we can just try to reconnect and see if\n\t\t\t\t// we're truly offline.\n\t\t\t\tthis.socketAdapter._closeSocket()\n\t\t\t})\n\t\t)\n\n\t\tthis.state = 'pendingAttempt'\n\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\tthis.scheduleAttempt()\n\t}\n\n\tprivate subscribeToReconnectHints() {\n\t\tthis.disposables.push(\n\t\t\tlistenTo(window, 'online', () => {\n\t\t\t\tdebug('window went online')\n\t\t\t\tthis.maybeReconnected()\n\t\t\t}),\n\t\t\tlistenTo(document, 'visibilitychange', () => {\n\t\t\t\tif (!document.hidden) {\n\t\t\t\t\tdebug('document became visible')\n\t\t\t\t\tthis.maybeReconnected()\n\t\t\t\t}\n\t\t\t})\n\t\t)\n\n\t\tif (Object.prototype.hasOwnProperty.call(navigator, 'connection')) {\n\t\t\tconst connection = (navigator as any)['connection'] as EventTarget\n\t\t\tthis.disposables.push(\n\t\t\t\tlistenTo(connection, 'change', () => {\n\t\t\t\t\tdebug('navigator.connection change')\n\t\t\t\t\tthis.maybeReconnected()\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate scheduleAttempt() {\n\t\tassert(this.state === 'pendingAttempt')\n\t\tdebug('scheduling a connection attempt')\n\t\tPromise.resolve(this.getUri()).then((uri) => {\n\t\t\t// this can happen if the promise gets resolved too late\n\t\t\tif (this.state !== 'pendingAttempt' || this.isDisposed) return\n\t\t\tassert(\n\t\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.OPEN,\n\t\t\t\t'There should be no connection attempts while already connected'\n\t\t\t)\n\n\t\t\tthis.lastAttemptStart = Date.now()\n\t\t\tthis.socketAdapter._setNewSocket(new WebSocket(httpToWs(uri)))\n\t\t\tthis.state = 'pendingAttemptResult'\n\t\t})\n\t}\n\n\tprivate getMaxDelay() {\n\t\treturn document.hidden ? INACTIVE_MAX_DELAY : ACTIVE_MAX_DELAY\n\t}\n\n\tprivate getMinDelay() {\n\t\treturn document.hidden ? INACTIVE_MIN_DELAY : ACTIVE_MIN_DELAY\n\t}\n\n\tprivate clearReconnectTimeout() {\n\t\tif (this.reconnectTimeout) {\n\t\t\tclearTimeout(this.reconnectTimeout)\n\t\t\tthis.reconnectTimeout = null\n\t\t}\n\t}\n\n\tprivate clearRecheckConnectingTimeout() {\n\t\tif (this.recheckConnectingTimeout) {\n\t\t\tclearTimeout(this.recheckConnectingTimeout)\n\t\t\tthis.recheckConnectingTimeout = null\n\t\t}\n\t}\n\n\tmaybeReconnected() {\n\t\tdebug('ReconnectManager.maybeReconnected')\n\t\t// It doesn't make sense to have another check scheduled if we're already checking it now.\n\t\t// If we have a CONNECTING check scheduled and relevant, it'll be recreated below anyway\n\t\tthis.clearRecheckConnectingTimeout()\n\n\t\t// readyState can be CONNECTING, OPEN, CLOSING, CLOSED, or null (if getUri() is still pending)\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {\n\t\t\tdebug('ReconnectManager.maybeReconnected: already connected')\n\t\t\t// nothing to do, we're already OK\n\t\t\treturn\n\t\t}\n\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.CONNECTING) {\n\t\t\tdebug('ReconnectManager.maybeReconnected: connecting')\n\t\t\t// We might be waiting for a TCP connection that sent SYN out and will never get it back,\n\t\t\t// while a new connection appeared. On the other hand, we might have just started connecting\n\t\t\t// and will succeed in a bit. Thus, we're checking how old the attempt is and retry anew\n\t\t\t// if it's old enough. This by itself can delay the connection a bit, but shouldn't prevent\n\t\t\t// new connections as long as `maybeReconnected` is not looped itself\n\t\t\tassert(\n\t\t\t\tthis.lastAttemptStart,\n\t\t\t\t'ReadyState=CONNECTING without lastAttemptStart should be impossible'\n\t\t\t)\n\t\t\tconst sinceLastStart = Date.now() - this.lastAttemptStart\n\t\t\tif (sinceLastStart < ATTEMPT_TIMEOUT) {\n\t\t\t\tdebug('ReconnectManager.maybeReconnected: connecting, rechecking later')\n\t\t\t\tthis.recheckConnectingTimeout = setTimeout(\n\t\t\t\t\t() => this.maybeReconnected(),\n\t\t\t\t\tATTEMPT_TIMEOUT - sinceLastStart\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tdebug('ReconnectManager.maybeReconnected: connecting, but for too long, retry now')\n\t\t\t\t// Last connection attempt was started a while ago, it's possible that network conditions\n\t\t\t\t// changed, and it's worth retrying to connect. `disconnected` will handle reconnection\n\t\t\t\t//\n\t\t\t\t// NOTE: The danger here is looping in connection attemps if connections are slow.\n\t\t\t\t//       Make sure that `maybeReconnected` is not called in the `disconnected` codepath!\n\t\t\t\tthis.clearRecheckConnectingTimeout()\n\t\t\t\tthis.socketAdapter._closeSocket()\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tdebug('ReconnectManager.maybeReconnected: closing/closed/null, retry now')\n\t\t// readyState is CLOSING or CLOSED, or the websocket is null\n\t\t// Restart the backoff and retry ASAP (honouring the min delay)\n\t\t// this.state doesn't really matter, because disconnected() will handle any state correctly\n\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\tthis.disconnected()\n\t}\n\n\tdisconnected() {\n\t\tdebug('ReconnectManager.disconnected')\n\t\t// This either means we're freshly disconnected, or the last connection attempt failed;\n\t\t// either way, time to try again.\n\n\t\t// Guard against delayed notifications and recheck synchronously\n\t\tif (\n\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.OPEN &&\n\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.CONNECTING\n\t\t) {\n\t\t\tdebug('ReconnectManager.disconnected: websocket is not OPEN or CONNECTING')\n\t\t\tthis.clearReconnectTimeout()\n\n\t\t\tlet delayLeft\n\t\t\tif (this.state === 'connected') {\n\t\t\t\t// it's the first sign that we got disconnected; the state will be updated below,\n\t\t\t\t// just set the appropriate delay for now\n\t\t\t\tthis.intendedDelay = this.getMinDelay()\n\t\t\t\tdelayLeft = this.intendedDelay\n\t\t\t} else {\n\t\t\t\tdelayLeft =\n\t\t\t\t\tthis.lastAttemptStart !== null\n\t\t\t\t\t\t? this.lastAttemptStart + this.intendedDelay - Date.now()\n\t\t\t\t\t\t: 0\n\t\t\t}\n\n\t\t\tif (delayLeft > 0) {\n\t\t\t\tdebug('ReconnectManager.disconnected: delaying, delayLeft', delayLeft)\n\t\t\t\t// try again later\n\t\t\t\tthis.state = 'delay'\n\n\t\t\t\tthis.reconnectTimeout = setTimeout(() => this.disconnected(), delayLeft)\n\t\t\t} else {\n\t\t\t\t// not connected and not delayed, time to retry\n\t\t\t\tthis.state = 'pendingAttempt'\n\n\t\t\t\tthis.intendedDelay = Math.min(\n\t\t\t\t\tthis.getMaxDelay(),\n\t\t\t\t\tMath.max(this.getMinDelay(), this.intendedDelay) * DELAY_EXPONENT\n\t\t\t\t)\n\t\t\t\tdebug(\n\t\t\t\t\t'ReconnectManager.disconnected: attempting a connection, next delay',\n\t\t\t\t\tthis.intendedDelay\n\t\t\t\t)\n\t\t\t\tthis.scheduleAttempt()\n\t\t\t}\n\t\t}\n\t}\n\n\tconnected() {\n\t\tdebug('ReconnectManager.connected')\n\t\t// this notification could've been delayed, recheck synchronously\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {\n\t\t\tdebug('ReconnectManager.connected: websocket is OPEN')\n\t\t\tthis.state = 'connected'\n\t\t\tthis.clearReconnectTimeout()\n\t\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.disposables.forEach((d) => d())\n\t\tthis.isDisposed = true\n\t}\n}\n\nfunction httpToWs(url: string) {\n\treturn url.replace(/^http(s)?:/, 'ws$1:')\n}\n", "import { registerTldrawLibraryVersion } from '@tldraw/utils'\nimport { singleton } from './lib/helpers'\n\nexport { ArraySet } from './lib/ArraySet'\nexport { atom, isAtom } from './lib/Atom'\nexport type { Atom, AtomOptions } from './lib/Atom'\nexport {\n\tUNINITIALIZED,\n\tcomputed,\n\tgetComputedInstance,\n\tisUninitialized,\n\twithDiff,\n} from './lib/Computed'\nexport type { Computed, ComputedOptions, WithDiff } from './lib/Computed'\nexport { EffectScheduler, react, reactor } from './lib/EffectScheduler'\nexport type { EffectSchedulerOptions, Reactor } from './lib/EffectScheduler'\nexport { unsafe__withoutCapture, whyAmIRunning } from './lib/capture'\nexport { EMPTY_ARRAY } from './lib/helpers'\nexport { isSignal } from './lib/isSignal'\nexport { transact, transaction } from './lib/transactions'\nexport { RESET_VALUE } from './lib/types'\nexport type { Child, ComputeDiff, Signal } from './lib/types'\n\n// This should be incremented any time an API change is made. i.e. for additions or removals.\n// Bugfixes need not increment this.\nconst currentApiVersion = 1\n\nconst actualApiVersion = singleton('apiVersion', () => currentApiVersion)\n\nif (actualApiVersion !== currentApiVersion) {\n\tthrow new Error(\n\t\t`You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package.`\n\t)\n}\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n", "import { Child, Signal } from './types'\n\n/**\n * Get whether the given value is a child.\n *\n * @param x The value to check.\n * @returns True if the value is a child, false otherwise.\n */\nfunction isChild(x: any): x is Child {\n\treturn x && typeof x === 'object' && 'parents' in x\n}\n\n/**\n * Get whether a child's parents have changed.\n *\n * @param child The child to check.\n * @returns True if the child's parents have changed, false otherwise.\n */\nexport function haveParentsChanged(child: Child) {\n\tfor (let i = 0, n = child.parents.length; i < n; i++) {\n\t\t// Get the parent's value without capturing it.\n\t\tchild.parents[i].__unsafe__getWithoutCapture(true)\n\n\t\t// If the parent's epoch does not match the child's view of the parent's epoch, then the parent has changed.\n\t\tif (child.parents[i].lastChangedEpoch !== child.parentEpochs[i]) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Detach a child from a parent.\n *\n * @param parent The parent to detach from.\n * @param child The child to detach.\n */\nexport function detach(parent: Signal<any>, child: Child) {\n\t// If the child is not attached to the parent, do nothing.\n\tif (!parent.children.remove(child)) {\n\t\treturn\n\t}\n\n\t// If the parent has no more children, then detach the parent from its parents.\n\tif (parent.children.isEmpty && isChild(parent)) {\n\t\tfor (let i = 0, n = parent.parents.length; i < n; i++) {\n\t\t\tdetach(parent.parents[i], parent)\n\t\t}\n\t}\n}\n\n/**\n * Attach a child to a parent.\n *\n * @param parent The parent to attach to.\n * @param child The child to attach.\n */\nexport function attach(parent: Signal<any>, child: Child) {\n\t// If the child is already attached to the parent, do nothing.\n\tif (!parent.children.add(child)) {\n\t\treturn\n\t}\n\n\t// If the parent itself is a child, add the parent to the parent's parents.\n\tif (isChild(parent)) {\n\t\tfor (let i = 0, n = parent.parents.length; i < n; i++) {\n\t\t\tattach(parent.parents[i], parent)\n\t\t}\n\t}\n}\n\n/**\n * Get whether two values are equal (insofar as @tldraw/state is concerned).\n *\n * @param a The first value.\n * @param b The second value.\n */\nexport function equals(a: any, b: any): boolean {\n\tconst shallowEquals =\n\t\ta === b || Object.is(a, b) || Boolean(a && b && typeof a.equals === 'function' && a.equals(b))\n\treturn shallowEquals\n}\n\nexport declare function assertNever(x: never): never\n\nexport function singleton<T>(key: string, init: () => T): T {\n\tconst symbol = Symbol.for(`com.tldraw.state/${key}`)\n\tconst global = globalThis as any\n\tglobal[symbol] ??= init()\n\treturn global[symbol]\n}\n\n/**\n * @public\n */\nexport const EMPTY_ARRAY: [] = singleton('empty_array', () => Object.freeze([]) as any)\n", "// The maximum size for an array in an ArraySet\nexport const ARRAY_SIZE_THRESHOLD = 8\n\n/**\n * An ArraySet operates as an array until it reaches a certain size, after which a Set is used\n * instead. In either case, the same methods are used to get, set, remove, and visit the items.\n * @internal\n */\nexport class ArraySet<T> {\n\tprivate arraySize = 0\n\n\tprivate array: (T | undefined)[] | null = Array(ARRAY_SIZE_THRESHOLD)\n\n\tprivate set: Set<T> | null = null\n\n\t/**\n\t * Get whether this ArraySet has any elements.\n\t *\n\t * @returns True if this ArraySet has any elements, false otherwise.\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isEmpty() {\n\t\tif (this.array) {\n\t\t\treturn this.arraySize === 0\n\t\t}\n\n\t\tif (this.set) {\n\t\t\treturn this.set.size === 0\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Add an item to the ArraySet if it is not already present.\n\t *\n\t * @param elem - The element to add.\n\t */\n\n\tadd(elem: T) {\n\t\tif (this.array) {\n\t\t\tconst idx = this.array.indexOf(elem)\n\n\t\t\t// Return false if the element is already in the array.\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tif (this.arraySize < ARRAY_SIZE_THRESHOLD) {\n\t\t\t\t// If the array is below the size threshold, push items into the array.\n\n\t\t\t\t// Insert the element into the array's next available slot.\n\t\t\t\tthis.array[this.arraySize] = elem\n\t\t\t\tthis.arraySize++\n\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\t// If the array is full, convert it to a set and remove the array.\n\t\t\t\tthis.set = new Set(this.array as any)\n\t\t\t\tthis.array = null\n\t\t\t\tthis.set.add(elem)\n\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tif (this.set) {\n\t\t\t// Return false if the element is already in the set.\n\t\t\tif (this.set.has(elem)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.set.add(elem)\n\t\t\treturn true\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Remove an item from the ArraySet if it is present.\n\t *\n\t * @param elem - The element to remove\n\t */\n\tremove(elem: T) {\n\t\tif (this.array) {\n\t\t\tconst idx = this.array.indexOf(elem)\n\n\t\t\t// If the item is not in the array, return false.\n\t\t\tif (idx === -1) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.array[idx] = undefined\n\t\t\tthis.arraySize--\n\n\t\t\tif (idx !== this.arraySize) {\n\t\t\t\t// If the item is not the last item in the array, move the last item into the\n\t\t\t\t// removed item's slot.\n\t\t\t\tthis.array[idx] = this.array[this.arraySize]\n\t\t\t\tthis.array[this.arraySize] = undefined\n\t\t\t}\n\n\t\t\treturn true\n\t\t}\n\n\t\tif (this.set) {\n\t\t\t// If the item is not in the set, return false.\n\t\t\tif (!this.set.has(elem)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.set.delete(elem)\n\n\t\t\treturn true\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Run a callback for each element in the ArraySet.\n\t *\n\t * @param visitor - The callback to run for each element.\n\t */\n\tvisit(visitor: (item: T) => void) {\n\t\tif (this.array) {\n\t\t\tfor (let i = 0; i < this.arraySize; i++) {\n\t\t\t\tconst elem = this.array[i]\n\n\t\t\t\tif (typeof elem !== 'undefined') {\n\t\t\t\t\tvisitor(elem)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (this.set) {\n\t\t\tthis.set.forEach(visitor)\n\n\t\t\treturn\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\thas(elem: T) {\n\t\tif (this.array) {\n\t\t\treturn this.array.indexOf(elem) !== -1\n\t\t} else {\n\t\t\treturn this.set!.has(elem)\n\t\t}\n\t}\n\n\tclear() {\n\t\tif (this.set) {\n\t\t\tthis.set.clear()\n\t\t} else {\n\t\t\tthis.arraySize = 0\n\t\t\tthis.array = []\n\t\t}\n\t}\n\n\tsize() {\n\t\tif (this.set) {\n\t\t\treturn this.set.size\n\t\t} else {\n\t\t\treturn this.arraySize\n\t\t}\n\t}\n}\n", "import { ArraySet } from './ArraySet'\nimport { HistoryBuffer } from './HistoryBuffer'\nimport { maybeCaptureParent } from './capture'\nimport { EMPTY_ARRAY, equals, singleton } from './helpers'\nimport { advanceGlobalEpoch, atomDidChange, getGlobalEpoch } from './transactions'\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types'\n\n/**\n * The options to configure an atom, passed into the [[atom]] function.\n * @public\n */\nexport interface AtomOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via [[Atom.set]], you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify [[AtomOptions.historyLength]].\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a - The old value\n\t * @param b - The new value\n\t * @returns\n\t */\n\tisEqual?(a: any, b: any): boolean\n}\n\n/**\n * An Atom is a signal that can be updated directly by calling [[Atom.set]] or [[Atom.update]].\n *\n * Atoms are created using the [[atom]] function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * print(name.get()) // 'John'\n * ```\n *\n * @public\n */\nexport interface Atom<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Sets the value of this atom to the given value. If the value is the same as the current value, this is a no-op.\n\t *\n\t * @param value - The new value to set.\n\t * @param diff - The diff to use for the update. If not provided, the diff will be computed using [[AtomOptions.computeDiff]].\n\t */\n\tset(value: Value, diff?: Diff): Value\n\t/**\n\t * Updates the value of this atom using the given updater function. If the returned value is the same as the current value, this is a no-op.\n\t *\n\t * @param updater - A function that takes the current value and returns the new value.\n\t */\n\tupdate(updater: (value: Value) => Value): Value\n}\n\n/**\n * @internal\n */\nclass __Atom__<Value, Diff = unknown> implements Atom<Value, Diff> {\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate current: Value,\n\t\toptions?: AtomOptions<Value, Diff>\n\t) {\n\t\tthis.isEqual = options?.isEqual ?? null\n\n\t\tif (!options) return\n\n\t\tif (options.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\n\t\tthis.computeDiff = options.computeDiff\n\t}\n\n\treadonly isEqual: null | ((a: any, b: any) => boolean)\n\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\n\tlastChangedEpoch = getGlobalEpoch()\n\n\tchildren = new ArraySet<Child>()\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t__unsafe__getWithoutCapture(_ignoreErrors?: boolean): Value {\n\t\treturn this.current\n\t}\n\n\tget() {\n\t\tmaybeCaptureParent(this)\n\t\treturn this.current\n\t}\n\n\tset(value: Value, diff?: Diff): Value {\n\t\t// If the value has not changed, do nothing.\n\t\tif (this.isEqual?.(this.current, value) ?? equals(this.current, value)) {\n\t\t\treturn this.current\n\t\t}\n\n\t\t// Tick forward the global epoch\n\t\tadvanceGlobalEpoch()\n\n\t\t// Add the diff to the history buffer.\n\t\tif (this.historyBuffer) {\n\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\tgetGlobalEpoch(),\n\t\t\t\tdiff ??\n\t\t\t\t\tthis.computeDiff?.(this.current, value, this.lastChangedEpoch, getGlobalEpoch()) ??\n\t\t\t\t\tRESET_VALUE\n\t\t\t)\n\t\t}\n\n\t\t// Update the atom's record of the epoch when last changed.\n\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\n\t\tconst oldValue = this.current\n\t\tthis.current = value\n\n\t\t// Notify all children that this atom has changed.\n\t\tatomDidChange(this as any, oldValue)\n\n\t\treturn value\n\t}\n\n\tupdate(updater: (value: Value) => Value): Value {\n\t\treturn this.set(updater(this.current))\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\tmaybeCaptureParent(this)\n\n\t\t// If no changes have occurred since the given epoch, return an empty array.\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\nexport const _Atom = singleton('Atom', () => __Atom__)\nexport type _Atom = InstanceType<typeof _Atom>\n\n/**\n * Creates a new [[Atom]].\n *\n * An Atom is a signal that can be updated directly by calling [[Atom.set]] or [[Atom.update]].\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * name.get() // 'John'\n *\n * name.set('Jane')\n *\n * name.get() // 'Jane'\n * ```\n *\n * @public\n */\nexport function atom<Value, Diff = unknown>(\n\t/**\n\t * A name for the signal. This is used for debugging and profiling purposes, it does not need to be unique.\n\t */\n\tname: string,\n\t/**\n\t * The initial value of the signal.\n\t */\n\tinitialValue: Value,\n\t/**\n\t * The options to configure the atom. See [[AtomOptions]].\n\t */\n\toptions?: AtomOptions<Value, Diff>\n): Atom<Value, Diff> {\n\treturn new _Atom(name, initialValue, options)\n}\n\n/**\n * Returns true if the given value is an [[Atom]].\n * @public\n */\nexport function isAtom(value: unknown): value is Atom<unknown> {\n\treturn value instanceof _Atom\n}\n", "import { RESET_VALUE } from './types'\n\ntype RangeTuple<Diff> = [fromEpoch: number, toEpoch: number, diff: Diff]\n\n/**\n * A structure that stores diffs between values of an atom.\n *\n * @internal\n */\nexport class HistoryBuffer<Diff> {\n\tprivate index = 0\n\n\t// use a wrap around buffer to store the last N values\n\tbuffer: Array<RangeTuple<Diff> | undefined>\n\n\tconstructor(private readonly capacity: number) {\n\t\tthis.buffer = new Array(capacity)\n\t}\n\n\t/**\n\t * Add a diff to the history buffer.\n\t *\n\t * @param lastComputedEpoch - The epoch when the diff was computed.\n\t * @param currentEpoch - The current epoch.\n\t * @param diff - The diff to add, or else a reset value.\n\t */\n\tpushEntry(lastComputedEpoch: number, currentEpoch: number, diff: Diff | RESET_VALUE) {\n\t\tif (diff === undefined) {\n\t\t\treturn\n\t\t}\n\n\t\tif (diff === RESET_VALUE) {\n\t\t\tthis.clear()\n\t\t\treturn\n\t\t}\n\n\t\t// Add the diff to the buffer as a range tuple.\n\t\tthis.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff]\n\n\t\t// Bump the index, wrapping around if necessary.\n\t\tthis.index = (this.index + 1) % this.capacity\n\t}\n\n\t/**\n\t * Clear the history buffer.\n\t */\n\tclear() {\n\t\tthis.index = 0\n\t\tthis.buffer.fill(undefined)\n\t}\n\n\t/**\n\t * Get the diffs since the given epoch.\n\t *\n\t * @param sinceEpoch - The epoch to get diffs since.\n\t * @returns An array of diffs or a flag to reset the history buffer.\n\t */\n\tgetChangesSince(sinceEpoch: number): RESET_VALUE | Diff[] {\n\t\tconst { index, capacity, buffer } = this\n\n\t\t// For each item in the buffer...\n\t\tfor (let i = 0; i < capacity; i++) {\n\t\t\tconst offset = (index - 1 + capacity - i) % capacity\n\n\t\t\tconst elem = buffer[offset]\n\n\t\t\t// If there's no element in the offset position, return the reset value\n\t\t\tif (!elem) {\n\t\t\t\treturn RESET_VALUE\n\t\t\t}\n\n\t\t\tconst [fromEpoch, toEpoch] = elem\n\n\t\t\t// If the first element is already too early, bail\n\t\t\tif (i === 0 && sinceEpoch >= toEpoch) {\n\t\t\t\treturn []\n\t\t\t}\n\n\t\t\t// If the element is since the given epoch, return an array with all diffs from this element and all following elements\n\t\t\tif (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {\n\t\t\t\tconst len = i + 1\n\t\t\t\tconst result = new Array(len)\n\n\t\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\t\tresult[j] = buffer[(offset + j) % capacity]![2]\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't returned yet, return the reset value\n\t\treturn RESET_VALUE\n\t}\n}\n", "import { ArraySet } from './ArraySet'\n\n/** @public */\nexport const RESET_VALUE: unique symbol = Symbol.for('com.tldraw.state/RESET_VALUE')\n\n/** @public */\nexport type RESET_VALUE = typeof RESET_VALUE\n\n/**\n * A Signal is a reactive value container. The value may change over time, and it may keep track of the diffs between sequential values.\n *\n * There are two types of signal:\n *\n * - Atomic signals, created using [[atom]]. These are mutable references to values that can be changed using [[Atom.set]].\n * - Computed signals, created using [[computed]]. These are values that are computed from other signals. They are recomputed lazily if their dependencies change.\n *\n * @public\n */\nexport interface Signal<Value, Diff = unknown> {\n\t/**\n\t * The name of the signal. This is used at runtime for debugging and perf profiling only. It does not need to be globally unique.\n\t */\n\tname: string\n\t/**\n\t * The current value of the signal. This is a reactive value, and will update when the signal changes.\n\t * Any computed signal that depends on this signal will be lazily recomputed if this signal changes.\n\t * Any effect that depends on this signal will be rescheduled if this signal changes.\n\t */\n\tget(): Value\n\n\t/**\n\t * The epoch when this signal's value last changed. Note tha this is not the same as when the value was last computed.\n\t * A signal may recopmute it's value without changing it.\n\t */\n\tlastChangedEpoch: number\n\t/**\n\t * Returns the sequence of diffs between the the value at the given epoch and the current value.\n\t * Returns the [[RESET_VALUE]] constant if there is not enough information to compute the diff sequence.\n\t * @param epoch - The epoch to get diffs since.\n\t */\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[]\n\t/**\n\t * Returns the current value of the signal without capturing it as a dependency.\n\t * Use this if you need to retrieve the signal's value in a hot loop where the performance overhead of dependency tracking is too high.\n\t */\n\t__unsafe__getWithoutCapture(ignoreErrors?: boolean): Value\n\t/** @internal */\n\tchildren: ArraySet<Child>\n}\n\n/** @internal */\nexport interface Child {\n\tlastTraversedEpoch: number\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\treadonly parents: Signal<any, any>[]\n\treadonly parentEpochs: number[]\n\tisActivelyListening: boolean\n}\n\n/**\n * Computes the diff between the previous and current value.\n *\n * If the diff cannot be computed for whatever reason, it should return [[RESET_VALUE]].\n *\n * @public\n */\nexport type ComputeDiff<Value, Diff> = (\n\tpreviousValue: Value,\n\tcurrentValue: Value,\n\tlastComputedEpoch: number,\n\tcurrentEpoch: number\n) => Diff | RESET_VALUE\n", "import { attach, detach, singleton } from './helpers'\nimport type { Child, Signal } from './types'\n\nclass CaptureStackFrame {\n\toffset = 0\n\n\tmaybeRemoved?: Signal<any>[]\n\n\tconstructor(\n\t\tpublic readonly below: CaptureStackFrame | null,\n\t\tpublic readonly child: Child\n\t) {}\n}\n\nconst inst = singleton('capture', () => ({ stack: null as null | CaptureStackFrame }))\n\n/**\n * Executes the given function without capturing any parents in the current capture context.\n *\n * This is mainly useful if you want to run an effect only when certain signals change while also\n * dereferencing other signals which should not cause the effect to rerun on their own.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Sam')\n * const time = atom('time', () => new Date().getTime())\n *\n * setInterval(() => {\n *   time.set(new Date().getTime())\n * })\n *\n * react('log name changes', () => {\n * \t print(name.get(), 'was changed at', unsafe__withoutCapture(() => time.get()))\n * })\n *\n * ```\n *\n * @public\n */\nexport function unsafe__withoutCapture<T>(fn: () => T): T {\n\tconst oldStack = inst.stack\n\tinst.stack = null\n\ttry {\n\t\treturn fn()\n\t} finally {\n\t\tinst.stack = oldStack\n\t}\n}\n\nexport function startCapturingParents(child: Child) {\n\tinst.stack = new CaptureStackFrame(inst.stack, child)\n\tchild.parentSet.clear()\n}\n\nexport function stopCapturingParents() {\n\tconst frame = inst.stack!\n\tinst.stack = frame.below\n\n\tif (frame.offset < frame.child.parents.length) {\n\t\tfor (let i = frame.offset; i < frame.child.parents.length; i++) {\n\t\t\tconst maybeRemovedParent = frame.child.parents[i]\n\t\t\tif (!frame.child.parentSet.has(maybeRemovedParent)) {\n\t\t\t\tdetach(maybeRemovedParent, frame.child)\n\t\t\t}\n\t\t}\n\n\t\tframe.child.parents.length = frame.offset\n\t\tframe.child.parentEpochs.length = frame.offset\n\t}\n\n\tif (frame.maybeRemoved) {\n\t\tfor (let i = 0; i < frame.maybeRemoved.length; i++) {\n\t\t\tconst maybeRemovedParent = frame.maybeRemoved[i]\n\t\t\tif (!frame.child.parentSet.has(maybeRemovedParent)) {\n\t\t\t\tdetach(maybeRemovedParent, frame.child)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// this must be called after the parent is up to date\nexport function maybeCaptureParent(p: Signal<any, any>) {\n\tif (inst.stack) {\n\t\tconst wasCapturedAlready = inst.stack.child.parentSet.has(p)\n\t\t// if the child didn't deref this parent last time it executed, then idx will be -1\n\t\t// if the child did deref this parent last time but in a different order relative to other parents, then idx will be greater than stack.offset\n\t\t// if the child did deref this parent last time in the same order, then idx will be the same as stack.offset\n\t\t// if the child did deref this parent already during this capture session then 0 <= idx < stack.offset\n\n\t\tif (wasCapturedAlready) {\n\t\t\treturn\n\t\t}\n\n\t\tinst.stack.child.parentSet.add(p)\n\t\tif (inst.stack.child.isActivelyListening) {\n\t\t\tattach(p, inst.stack.child)\n\t\t}\n\n\t\tif (inst.stack.offset < inst.stack.child.parents.length) {\n\t\t\tconst maybeRemovedParent = inst.stack.child.parents[inst.stack.offset]\n\t\t\tif (maybeRemovedParent !== p) {\n\t\t\t\tif (!inst.stack.maybeRemoved) {\n\t\t\t\t\tinst.stack.maybeRemoved = [maybeRemovedParent]\n\t\t\t\t} else {\n\t\t\t\t\tinst.stack.maybeRemoved.push(maybeRemovedParent)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinst.stack.child.parents[inst.stack.offset] = p\n\t\tinst.stack.child.parentEpochs[inst.stack.offset] = p.lastChangedEpoch\n\t\tinst.stack.offset++\n\t}\n}\n\n/**\n * A debugging tool that tells you why a computed signal or effect is running.\n * Call in the body of a computed signal or effect function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Bob')\n * react('greeting', () => {\n * \twhyAmIRunning()\n *\tprint('Hello', name.get())\n * })\n *\n * name.set('Alice')\n *\n * // 'greeting' is running because:\n * //     'name' changed => 'Alice'\n * ```\n *\n * @public\n */\nexport function whyAmIRunning() {\n\tconst child = inst.stack?.child\n\tif (!child) {\n\t\tthrow new Error('whyAmIRunning() called outside of a reactive context')\n\t}\n\n\tconst changedParents = []\n\tfor (let i = 0; i < child.parents.length; i++) {\n\t\tconst parent = child.parents[i]\n\n\t\tif (parent.lastChangedEpoch > child.parentEpochs[i]) {\n\t\t\tchangedParents.push(parent)\n\t\t}\n\t}\n\n\tif (changedParents.length === 0) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log((child as any).name, 'is running but none of the parents changed')\n\t} else {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log((child as any).name, 'is running because:')\n\t\tfor (const changedParent of changedParents) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.log(\n\t\t\t\t'\\t',\n\t\t\t\t(changedParent as any).name,\n\t\t\t\t'changed =>',\n\t\t\t\tchangedParent.__unsafe__getWithoutCapture(true)\n\t\t\t)\n\t\t}\n\t}\n}\n", "import { _Atom } from './Atom'\nimport { EffectScheduler } from './EffectScheduler'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { singleton } from './helpers'\nimport { Child, Signal } from './types'\n\nclass Transaction {\n\tconstructor(public readonly parent: Transaction | null) {}\n\tinitialAtomValues = new Map<_Atom, any>()\n\n\t/**\n\t * Get whether this transaction is a root (no parents).\n\t *\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isRoot() {\n\t\treturn this.parent === null\n\t}\n\n\t/**\n\t * Commit the transaction's changes.\n\t *\n\t * @public\n\t */\n\tcommit() {\n\t\tif (inst.globalIsReacting) {\n\t\t\t// if we're committing during a reaction we actually need to\n\t\t\t// use the 'cleanup' reactors set to ensure we re-run effects if necessary\n\t\t\tfor (const atom of this.initialAtomValues.keys()) {\n\t\t\t\ttraverseAtomForCleanup(atom)\n\t\t\t}\n\t\t} else if (this.isRoot) {\n\t\t\t// For root transactions, flush changed atoms\n\t\t\tflushChanges(this.initialAtomValues.keys())\n\t\t} else {\n\t\t\t// For transactions with parents, add the transaction's initial values to the parent's.\n\t\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\t\tif (!this.parent!.initialAtomValues.has(atom)) {\n\t\t\t\t\tthis.parent!.initialAtomValues.set(atom, value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Abort the transaction.\n\t *\n\t * @public\n\t */\n\tabort() {\n\t\tinst.globalEpoch++\n\n\t\t// Reset each of the transaction's atoms to its initial value.\n\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\tatom.set(value)\n\t\t\tatom.historyBuffer?.clear()\n\t\t})\n\n\t\t// Commit the changes.\n\t\tthis.commit()\n\t}\n}\n\nconst inst = singleton('transactions', () => ({\n\t// The current epoch (global to all atoms).\n\tglobalEpoch: GLOBAL_START_EPOCH + 1,\n\t// Whether any transaction is reacting.\n\tglobalIsReacting: false,\n\tcurrentTransaction: null as Transaction | null,\n\n\tcleanupReactors: null as null | Set<EffectScheduler<unknown>>,\n\treactionEpoch: GLOBAL_START_EPOCH + 1,\n}))\n\nexport function getReactionEpoch() {\n\treturn inst.reactionEpoch\n}\n\nexport function getGlobalEpoch() {\n\treturn inst.globalEpoch\n}\n\nexport function getIsReacting() {\n\treturn inst.globalIsReacting\n}\n\nfunction traverse(reactors: Set<EffectScheduler<unknown>>, child: Child) {\n\tif (child.lastTraversedEpoch === inst.globalEpoch) {\n\t\treturn\n\t}\n\n\tchild.lastTraversedEpoch = inst.globalEpoch\n\n\tif (child instanceof EffectScheduler) {\n\t\treactors.add(child)\n\t} else {\n\t\t;(child as any as Signal<any>).children.visit((c) => traverse(reactors, c))\n\t}\n}\n\n/**\n * Collect all of the reactors that need to run for an atom and run them.\n *\n * @param atoms - The atoms to flush changes for.\n */\nfunction flushChanges(atoms: Iterable<_Atom>) {\n\tif (inst.globalIsReacting) {\n\t\tthrow new Error('flushChanges cannot be called during a reaction')\n\t}\n\n\tconst outerTxn = inst.currentTransaction\n\ttry {\n\t\t// clear the transaction stack\n\t\tinst.currentTransaction = null\n\t\tinst.globalIsReacting = true\n\t\tinst.reactionEpoch = inst.globalEpoch\n\n\t\t// Collect all of the visited reactors.\n\t\tconst reactors = new Set<EffectScheduler<unknown>>()\n\n\t\tfor (const atom of atoms) {\n\t\t\tatom.children.visit((child) => traverse(reactors, child))\n\t\t}\n\n\t\t// Run each reactor.\n\t\tfor (const r of reactors) {\n\t\t\tr.maybeScheduleEffect()\n\t\t}\n\n\t\tlet updateDepth = 0\n\t\twhile (inst.cleanupReactors?.size) {\n\t\t\tif (updateDepth++ > 1000) {\n\t\t\t\tthrow new Error('Reaction update depth limit exceeded')\n\t\t\t}\n\t\t\tconst reactors = inst.cleanupReactors\n\t\t\tinst.cleanupReactors = null\n\t\t\tfor (const r of reactors) {\n\t\t\t\tr.maybeScheduleEffect()\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tinst.cleanupReactors = null\n\t\tinst.globalIsReacting = false\n\t\tinst.currentTransaction = outerTxn\n\t}\n}\n\n/**\n * Handle a change to an atom.\n *\n * @param atom The atom that changed.\n * @param previousValue The atom's previous value.\n *\n * @internal\n */\nexport function atomDidChange(atom: _Atom, previousValue: any) {\n\tif (inst.currentTransaction) {\n\t\t// If we are in a transaction, then all we have to do is preserve\n\t\t// the value of the atom at the start of the transaction in case\n\t\t// we need to roll back.\n\t\tif (!inst.currentTransaction.initialAtomValues.has(atom)) {\n\t\t\tinst.currentTransaction.initialAtomValues.set(atom, previousValue)\n\t\t}\n\t} else if (inst.globalIsReacting) {\n\t\t// If the atom changed during the reaction phase of flushChanges\n\t\t// (and there are no transactions started inside the reaction phase)\n\t\t// then we are past the point where a transaction can be aborted\n\t\t// so we don't need to note down the previousValue.\n\t\ttraverseAtomForCleanup(atom)\n\t} else {\n\t\t// If there is no transaction, flush the changes immediately.\n\t\tflushChanges([atom])\n\t}\n}\n\nfunction traverseAtomForCleanup(atom: _Atom) {\n\tconst rs = (inst.cleanupReactors ??= new Set())\n\tatom.children.visit((child) => traverse(rs, child))\n}\n\nexport function advanceGlobalEpoch() {\n\tinst.globalEpoch++\n}\n\n/**\n * Batches state updates, deferring side effects until after the transaction completes.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   print(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n * })\n *\n * // Logs \"Hello, Jane Smith!\"\n * ```\n *\n * If the function throws, the transaction is aborted and any signals that were updated during the transaction revert to their state before the transaction began.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   print(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  throw new Error('oops')\n * })\n *\n * // Does not log\n * // firstName.get() === 'John'\n * ```\n *\n * A `rollback` callback is passed into the function.\n * Calling this will prevent the transaction from committing and will revert any signals that were updated during the transaction to their state before the transaction began.\n *\n *  * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   print(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction((rollback) => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n *  rollback()\n * })\n *\n * // Does not log\n * // firstName.get() === 'John'\n * // lastName.get() === 'Doe'\n * ```\n *\n * @param fn - The function to run in a transaction, called with a function to roll back the change.\n * @public\n */\nexport function transaction<T>(fn: (rollback: () => void) => T) {\n\tconst txn = new Transaction(inst.currentTransaction)\n\n\t// Set the current transaction to the transaction\n\tinst.currentTransaction = txn\n\n\ttry {\n\t\tlet result = undefined as T | undefined\n\t\tlet rollback = false\n\n\t\ttry {\n\t\t\t// Run the function.\n\t\t\tresult = fn(() => (rollback = true))\n\t\t} catch (e) {\n\t\t\t// Abort the transaction if the function throws.\n\t\t\ttxn.abort()\n\t\t\tthrow e\n\t\t}\n\n\t\tif (rollback) {\n\t\t\t// If the rollback was triggered, abort the transaction.\n\t\t\ttxn.abort()\n\t\t} else {\n\t\t\ttxn.commit()\n\t\t}\n\n\t\treturn result\n\t} finally {\n\t\t// Set the current transaction to the transaction's parent.\n\t\tinst.currentTransaction = inst.currentTransaction.parent\n\t}\n}\n\n/**\n * Like [transaction](#transaction), but does not create a new transaction if there is already one in progress.\n *\n * @param fn - The function to run in a transaction.\n * @public\n */\nexport function transact<T>(fn: () => T): T {\n\tif (inst.currentTransaction) {\n\t\treturn fn()\n\t}\n\treturn transaction(fn)\n}\n", "import { ArraySet } from './ArraySet'\nimport { startCapturingParents, stopCapturingParents } from './capture'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { attach, detach, haveParentsChanged, singleton } from './helpers'\nimport { getGlobalEpoch } from './transactions'\nimport { Signal } from './types'\n\n/** @public */\nexport interface EffectSchedulerOptions {\n\t/**\n\t * scheduleEffect is a function that will be called when the effect is scheduled.\n\t *\n\t * It can be used to defer running effects until a later time, for example to batch them together with requestAnimationFrame.\n\t *\n\t *\n\t * @example\n\t * ```ts\n\t * let isRafScheduled = false\n\t * const scheduledEffects: Array<() => void> = []\n\t * const scheduleEffect = (runEffect: () => void) => {\n\t * \tscheduledEffects.push(runEffect)\n\t * \tif (!isRafScheduled) {\n\t * \t\tisRafScheduled = true\n\t * \t\trequestAnimationFrame(() => {\n\t * \t\t\tisRafScheduled = false\n\t * \t\t\tscheduledEffects.forEach((runEffect) => runEffect())\n\t * \t\t\tscheduledEffects.length = 0\n\t * \t\t})\n\t * \t}\n\t * }\n\t * const stop = react('set page title', () => {\n\t * \tdocument.title = doc.title,\n\t * }, scheduleEffect)\n\t * ```\n\t *\n\t * @param execute - A function that will execute the effect.\n\t * @returns\n\t */\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tscheduleEffect?: (execute: () => void) => void\n}\n\nclass __EffectScheduler__<Result> implements EffectScheduler<Result> {\n\tprivate _isActivelyListening = false\n\t/**\n\t * Whether this scheduler is attached and actively listening to its parents.\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isActivelyListening() {\n\t\treturn this._isActivelyListening\n\t}\n\t/** @internal */\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\tprivate lastReactedEpoch = GLOBAL_START_EPOCH\n\tprivate _scheduleCount = 0\n\n\t/**\n\t * The number of times this effect has been scheduled.\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget scheduleCount() {\n\t\treturn this._scheduleCount\n\t}\n\n\t/** @internal */\n\treadonly parentSet = new ArraySet<Signal<any, any>>()\n\t/** @internal */\n\treadonly parentEpochs: number[] = []\n\t/** @internal */\n\treadonly parents: Signal<any, any>[] = []\n\tprivate readonly _scheduleEffect?: (execute: () => void) => void\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate readonly runEffect: (lastReactedEpoch: number) => Result,\n\t\toptions?: EffectSchedulerOptions\n\t) {\n\t\tthis._scheduleEffect = options?.scheduleEffect\n\t}\n\n\t/** @internal */\n\tmaybeScheduleEffect() {\n\t\t// bail out if we have been cancelled by another effect\n\t\tif (!this._isActivelyListening) return\n\t\t// bail out if no atoms have changed since the last time we ran this effect\n\t\tif (this.lastReactedEpoch === getGlobalEpoch()) return\n\n\t\t// bail out if we have parents and they have not changed since last time\n\t\tif (this.parents.length && !haveParentsChanged(this)) {\n\t\t\tthis.lastReactedEpoch = getGlobalEpoch()\n\t\t\treturn\n\t\t}\n\t\t// if we don't have parents it's probably the first time this is running.\n\t\tthis.scheduleEffect()\n\t}\n\n\t/** @internal */\n\tscheduleEffect() {\n\t\tthis._scheduleCount++\n\t\tif (this._scheduleEffect) {\n\t\t\t// if the effect should be deferred (e.g. until a react render), do so\n\t\t\tthis._scheduleEffect(this.maybeExecute)\n\t\t} else {\n\t\t\t// otherwise execute right now!\n\t\t\tthis.execute()\n\t\t}\n\t}\n\n\t/** @internal */\n\t// eslint-disable-next-line local/prefer-class-methods\n\treadonly maybeExecute = () => {\n\t\t// bail out if we have been detached before this runs\n\t\tif (!this._isActivelyListening) return\n\t\tthis.execute()\n\t}\n\n\t/**\n\t * Makes this scheduler become 'actively listening' to its parents.\n\t * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n\t * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].\n\t * @public\n\t */\n\tattach() {\n\t\tthis._isActivelyListening = true\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tattach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Makes this scheduler stop 'actively listening' to its parents.\n\t * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.\n\t */\n\tdetach() {\n\t\tthis._isActivelyListening = false\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tdetach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Executes the effect immediately and returns the result.\n\t * @returns The result of the effect.\n\t */\n\texecute(): Result {\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\t// Important! We have to make a note of the current epoch before running the effect.\n\t\t\t// We allow atoms to be updated during effects, which increments the global epoch,\n\t\t\t// so if we were to wait until after the effect runs, the this.lastReactedEpoch value might get ahead of itself.\n\t\t\tconst currentEpoch = getGlobalEpoch()\n\t\t\tconst result = this.runEffect(this.lastReactedEpoch)\n\t\t\tthis.lastReactedEpoch = currentEpoch\n\t\t\treturn result\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n}\n\n/**\n * An EffectScheduler is responsible for executing side effects in response to changes in state.\n *\n * You probably don't need to use this directly unless you're integrating this library with a framework of some kind.\n *\n * Instead, use the [[react]] and [[reactor]] functions.\n *\n * @example\n * ```ts\n * const render = new EffectScheduler('render', drawToCanvas)\n *\n * render.attach()\n * render.execute()\n * ```\n *\n * @public\n */\nexport const EffectScheduler = singleton(\n\t'EffectScheduler',\n\t(): {\n\t\tnew <Result>(\n\t\t\tname: string,\n\t\t\trunEffect: (lastReactedEpoch: number) => Result,\n\t\t\toptions?: EffectSchedulerOptions\n\t\t): EffectScheduler<Result>\n\t} => __EffectScheduler__\n)\n/** @public */\nexport interface EffectScheduler<Result> {\n\t/**\n\t * Whether this scheduler is attached and actively listening to its parents.\n\t * @public\n\t */\n\treadonly isActivelyListening: boolean\n\n\t/** @internal */\n\treadonly lastTraversedEpoch: number\n\n\t/**\n\t * The number of times this effect has been scheduled.\n\t * @public\n\t */\n\treadonly scheduleCount: number\n\n\t/** @internal */\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\n\t/** @internal */\n\treadonly parentEpochs: number[]\n\n\t/** @internal */\n\treadonly parents: Signal<any, any>[]\n\n\t/** @internal */\n\tmaybeScheduleEffect(): void\n\n\t/** @internal */\n\tscheduleEffect(): void\n\n\t/** @internal */\n\tmaybeExecute(): void\n\n\t/**\n\t * Makes this scheduler become 'actively listening' to its parents.\n\t * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n\t * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].\n\t * @public\n\t */\n\tattach(): void\n\n\t/**\n\t * Makes this scheduler stop 'actively listening' to its parents.\n\t * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.\n\t */\n\tdetach(): void\n\n\t/**\n\t * Executes the effect immediately and returns the result.\n\t * @returns The result of the effect.\n\t */\n\texecute(): Result\n}\n\n/**\n * Starts a new effect scheduler, scheduling the effect immediately.\n *\n * Returns a function that can be called to stop the scheduler.\n *\n * @example\n * ```ts\n * const color = atom('color', 'red')\n * const stop = react('set style', () => {\n *   divElem.style.color = color.get()\n * })\n * color.set('blue')\n * // divElem.style.color === 'blue'\n * stop()\n * color.set('green')\n * // divElem.style.color === 'blue'\n * ```\n *\n *\n * Also useful in React applications for running effects outside of the render cycle.\n *\n * @example\n * ```ts\n * useEffect(() => react('set style', () => {\n *   divRef.current.style.color = color.get()\n * }), [])\n * ```\n *\n * @public\n */\nexport function react(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => any,\n\toptions?: EffectSchedulerOptions\n) {\n\tconst scheduler = new EffectScheduler(name, fn, options)\n\tscheduler.attach()\n\tscheduler.scheduleEffect()\n\treturn () => {\n\t\tscheduler.detach()\n\t}\n}\n\n/**\n * The reactor is a user-friendly interface for starting and stopping an [[EffectScheduler]].\n *\n * Calling .start() will attach the scheduler and execute the effect immediately the first time it is called.\n *\n * If the reactor is stopped, calling `.start()` will re-attach the scheduler but will only execute the effect if any of its parents have changed since it was stopped.\n *\n * You can create a reactor with [[reactor]].\n * @public\n */\nexport interface Reactor<T = unknown> {\n\t/**\n\t * The underlying effect scheduler.\n\t * @public\n\t */\n\tscheduler: EffectScheduler<T>\n\t/**\n\t * Start the scheduler. The first time this is called the effect will be scheduled immediately.\n\t *\n\t * If the reactor is stopped, calling this will start the scheduler again but will only execute the effect if any of its parents have changed since it was stopped.\n\t *\n\t * If you need to force re-execution of the effect, pass `{ force: true }`.\n\t * @public\n\t */\n\tstart(options?: { force?: boolean }): void\n\t/**\n\t * Stop the scheduler.\n\t * @public\n\t */\n\tstop(): void\n}\n\n/**\n * Creates a [[Reactor]], which is a thin wrapper around an [[EffectScheduler]].\n *\n * @public\n */\nexport function reactor<Result>(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => Result,\n\toptions?: EffectSchedulerOptions\n): Reactor<Result> {\n\tconst scheduler = new EffectScheduler<Result>(name, fn, options)\n\treturn {\n\t\tscheduler,\n\t\tstart: (options?: { force?: boolean }) => {\n\t\t\tconst force = options?.force ?? false\n\t\t\tscheduler.attach()\n\t\t\tif (force) {\n\t\t\t\tscheduler.scheduleEffect()\n\t\t\t} else {\n\t\t\t\tscheduler.maybeScheduleEffect()\n\t\t\t}\n\t\t},\n\t\tstop: () => {\n\t\t\tscheduler.detach()\n\t\t},\n\t}\n}\n", "// Derivations start on GLOBAL_START_EPOCH so they are dirty before having been computed\nexport const GLOBAL_START_EPOCH = -1\n", "/* eslint-disable prefer-rest-params */\nimport { assert } from '@tldraw/utils'\nimport { ArraySet } from './ArraySet'\nimport { HistoryBuffer } from './HistoryBuffer'\nimport { maybeCaptureParent, startCapturingParents, stopCapturingParents } from './capture'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { EMPTY_ARRAY, equals, haveParentsChanged, singleton } from './helpers'\nimport { getGlobalEpoch, getIsReacting, getReactionEpoch } from './transactions'\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types'\nimport { logComputedGetterWarning } from './warnings'\n\n/**\n * @public\n */\nexport const UNINITIALIZED = Symbol.for('com.tldraw.state/UNINITIALIZED')\n/**\n * The type of the first value passed to a computed signal function as the 'prevValue' parameter.\n *\n * @see [[isUninitialized]].\n * @public\n */\nexport type UNINITIALIZED = typeof UNINITIALIZED\n\n/**\n * Call this inside a computed signal function to determine whether it is the first time the function is being called.\n *\n * Mainly useful for incremental signal computation.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   if (isUninitialized(prevValue)) {\n *     print('First time!')\n *   }\n *   return count.get() * 2\n * })\n * ```\n *\n * @param value - The value to check.\n * @public\n */\nexport function isUninitialized(value: any): value is UNINITIALIZED {\n\treturn value === UNINITIALIZED\n}\n\n/** @public */\nexport const WithDiff = singleton(\n\t'WithDiff',\n\t() =>\n\t\tclass WithDiff<Value, Diff> {\n\t\t\tconstructor(\n\t\t\t\tpublic value: Value,\n\t\t\t\tpublic diff: Diff\n\t\t\t) {}\n\t\t}\n)\n\n/** @public */\nexport interface WithDiff<Value, Diff> {\n\tvalue: Value\n\tdiff: Diff\n}\n\n/**\n * When writing incrementally-computed signals it is convenient (and usually more performant) to incrementally compute the diff too.\n *\n * You can use this function to wrap the return value of a computed signal function to indicate that the diff should be used instead of calculating a new one with [[AtomOptions.computeDiff]].\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   const nextValue = count.get() * 2\n *   if (isUninitialized(prevValue)) {\n *     return nextValue\n *   }\n *   return withDiff(nextValue, nextValue - prevValue)\n * }, { historyLength: 10 })\n * ```\n *\n *\n * @param value - The value.\n * @param diff - The diff.\n * @public\n */\nexport function withDiff<Value, Diff>(value: Value, diff: Diff): WithDiff<Value, Diff> {\n\treturn new WithDiff(value, diff)\n}\n\n/**\n * Options for creating computed signals. Used when calling [[computed]].\n * @public\n */\nexport interface ComputedOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via [[Atom.set]], you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify [[AtomOptions.historyLength]].\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a - The old value\n\t * @param b - The new value\n\t * @returns\n\t */\n\tisEqual?(a: any, b: any): boolean\n}\n\n/**\n * A computed signal created via [[computed]].\n *\n * @public\n */\nexport interface Computed<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Whether this computed child is involved in an actively-running effect graph.\n\t * @public\n\t */\n\treadonly isActivelyListening: boolean\n\n\t/** @internal */\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\t/** @internal */\n\treadonly parents: Signal<any, any>[]\n\t/** @internal */\n\treadonly parentEpochs: number[]\n}\n\n/**\n * @internal\n */\nclass __UNSAFE__Computed<Value, Diff = unknown> implements Computed<Value, Diff> {\n\tlastChangedEpoch = GLOBAL_START_EPOCH\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\t/**\n\t * The epoch when the reactor was last checked.\n\t */\n\tprivate lastCheckedEpoch = GLOBAL_START_EPOCH\n\n\tparentSet = new ArraySet<Signal<any, any>>()\n\tparents: Signal<any, any>[] = []\n\tparentEpochs: number[] = []\n\n\tchildren = new ArraySet<Child>()\n\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isActivelyListening(): boolean {\n\t\treturn !this.children.isEmpty\n\t}\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t// The last-computed value of this signal.\n\tprivate state: Value = UNINITIALIZED as unknown as Value\n\t// If the signal throws an error we stash it so we can rethrow it on the next get()\n\tprivate error: null | { thrownValue: any } = null\n\n\tprivate computeDiff?: ComputeDiff<Value, Diff>\n\n\tprivate readonly isEqual: (a: any, b: any) => boolean\n\n\tconstructor(\n\t\t/**\n\t\t * The name of the signal. This is used for debugging and performance profiling purposes. It does not need to be globally unique.\n\t\t */\n\t\tpublic readonly name: string,\n\t\t/**\n\t\t * The function that computes the value of the signal.\n\t\t */\n\t\tprivate readonly derive: (\n\t\t\tpreviousValue: Value | UNINITIALIZED,\n\t\t\tlastComputedEpoch: number\n\t\t) => Value | WithDiff<Value, Diff>,\n\t\toptions?: ComputedOptions<Value, Diff>\n\t) {\n\t\tif (options?.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\t\tthis.computeDiff = options?.computeDiff\n\t\tthis.isEqual = options?.isEqual ?? equals\n\t}\n\n\t__unsafe__getWithoutCapture(ignoreErrors?: boolean): Value {\n\t\tconst isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH\n\n\t\tconst globalEpoch = getGlobalEpoch()\n\n\t\tif (\n\t\t\t!isNew &&\n\t\t\t(this.lastCheckedEpoch === globalEpoch ||\n\t\t\t\t(this.isActivelyListening &&\n\t\t\t\t\tgetIsReacting() &&\n\t\t\t\t\tthis.lastTraversedEpoch < getReactionEpoch()) ||\n\t\t\t\t!haveParentsChanged(this))\n\t\t) {\n\t\t\tthis.lastCheckedEpoch = globalEpoch\n\t\t\tif (this.error) {\n\t\t\t\tif (!ignoreErrors) {\n\t\t\t\t\tthrow this.error.thrownValue\n\t\t\t\t} else {\n\t\t\t\t\treturn this.state // will be UNINITIALIZED\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this.state\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\tconst result = this.derive(this.state, this.lastCheckedEpoch)\n\t\t\tconst newState = result instanceof WithDiff ? result.value : result\n\t\t\tconst isUninitialized = this.state === UNINITIALIZED\n\t\t\tif (isUninitialized || !this.isEqual(newState, this.state)) {\n\t\t\t\tif (this.historyBuffer && !isUninitialized) {\n\t\t\t\t\tconst diff = result instanceof WithDiff ? result.diff : undefined\n\t\t\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\t\t\tgetGlobalEpoch(),\n\t\t\t\t\t\tdiff ??\n\t\t\t\t\t\t\tthis.computeDiff?.(this.state, newState, this.lastCheckedEpoch, getGlobalEpoch()) ??\n\t\t\t\t\t\t\tRESET_VALUE\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\t\t\t\tthis.state = newState\n\t\t\t}\n\t\t\tthis.error = null\n\t\t\tthis.lastCheckedEpoch = getGlobalEpoch()\n\n\t\t\treturn this.state\n\t\t} catch (e) {\n\t\t\t// if a derived value throws an error, we reset the state to UNINITIALIZED\n\t\t\tif (this.state !== UNINITIALIZED) {\n\t\t\t\tthis.state = UNINITIALIZED as unknown as Value\n\t\t\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\t\t\t}\n\t\t\tthis.lastCheckedEpoch = getGlobalEpoch()\n\t\t\t// we also clear the history buffer if an error was thrown\n\t\t\tif (this.historyBuffer) {\n\t\t\t\tthis.historyBuffer.clear()\n\t\t\t}\n\t\t\tthis.error = { thrownValue: e }\n\t\t\t// we don't wish to propagate errors when derefed via haveParentsChanged()\n\t\t\tif (!ignoreErrors) throw e\n\t\t\treturn this.state\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n\n\tget(): Value {\n\t\ttry {\n\t\t\treturn this.__unsafe__getWithoutCapture()\n\t\t} finally {\n\t\t\t// if the deriver throws an error we still need to capture\n\t\t\tmaybeCaptureParent(this)\n\t\t}\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\t// we can ignore any errors thrown during derive\n\t\tthis.__unsafe__getWithoutCapture(true)\n\t\t// and we still need to capture this signal as a parent\n\t\tmaybeCaptureParent(this)\n\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\nexport const _Computed = singleton('Computed', () => __UNSAFE__Computed)\nexport type _Computed = InstanceType<typeof __UNSAFE__Computed>\n\nfunction computedMethodLegacyDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\t_target: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.value\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + key)\n\n\tdescriptor.value = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(key, originalMethod!.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\tdescriptor.value[isComputedMethodKey] = true\n\n\treturn descriptor\n}\n\nfunction computedGetterLegacyDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\t_target: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.get\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + key)\n\n\tdescriptor.get = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(key, originalMethod!.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\n\treturn descriptor\n}\n\nfunction computedMethodTc39Decorator<This extends object, Value>(\n\toptions: ComputedOptions<Value, any>,\n\tcompute: () => Value,\n\tcontext: ClassMethodDecoratorContext<This, () => Value>\n) {\n\tassert(context.kind === 'method', '@computed can only be used on methods')\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + String(context.name))\n\n\tconst fn = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(String(context.name), compute.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\tfn[isComputedMethodKey] = true\n\treturn fn\n}\n\nfunction computedDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\targs:\n\t\t| [target: any, key: string, descriptor: PropertyDescriptor]\n\t\t| [originalMethod: () => any, context: ClassMethodDecoratorContext]\n) {\n\tif (args.length === 2) {\n\t\tconst [originalMethod, context] = args\n\t\treturn computedMethodTc39Decorator(options, originalMethod, context)\n\t} else {\n\t\tconst [_target, key, descriptor] = args\n\t\tif (descriptor.get) {\n\t\t\tlogComputedGetterWarning()\n\t\t\treturn computedGetterLegacyDecorator(options, _target, key, descriptor)\n\t\t} else {\n\t\t\treturn computedMethodLegacyDecorator(options, _target, key, descriptor)\n\t\t}\n\t}\n}\n\nconst isComputedMethodKey = '@@__isComputedMethod__@@'\n\n/**\n * Retrieves the underlying computed instance for a given property created with the [[computed]]\n * decorator.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom(0)\n *\n *   @computed getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n *\n * const c = new Counter()\n * const remaining = getComputedInstance(c, 'getRemaining')\n * remaining.get() === 100 // true\n * c.count.set(13)\n * remaining.get() === 87 // true\n * ```\n *\n * @param obj - The object\n * @param propertyName - The property name\n * @public\n */\nexport function getComputedInstance<Obj extends object, Prop extends keyof Obj>(\n\tobj: Obj,\n\tpropertyName: Prop\n): Computed<Obj[Prop]> {\n\tconst key = Symbol.for('__@tldraw/state__computed__' + propertyName.toString())\n\tlet inst = obj[key as keyof typeof obj] as Computed<Obj[Prop]> | undefined\n\tif (!inst) {\n\t\t// deref to make sure it exists first\n\t\tconst val = obj[propertyName]\n\t\tif (typeof val === 'function' && (val as any)[isComputedMethodKey]) {\n\t\t\tval.call(obj)\n\t\t}\n\n\t\tinst = obj[key as keyof typeof obj] as Computed<Obj[Prop]> | undefined\n\t}\n\treturn inst as any\n}\n\n/**\n * Creates a computed signal.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n * const greeting = computed('greeting', () => `Hello ${name.get()}!`)\n * console.log(greeting.get()) // 'Hello John!'\n * ```\n *\n * `computed` may also be used as a decorator for creating computed getter methods.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n * ```\n *\n * You may optionally pass in a [[ComputedOptions]] when used as a decorator:\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed({isEqual: (a, b) => a === b})\n *   getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n * ```\n *\n * @param name - The name of the signal.\n * @param compute - The function that computes the value of the signal.\n * @param options - Options for the signal.\n *\n * @public\n */\nexport function computed<Value, Diff = unknown>(\n\tname: string,\n\tcompute: (\n\t\tpreviousValue: Value | typeof UNINITIALIZED,\n\t\tlastComputedEpoch: number\n\t) => Value | WithDiff<Value, Diff>,\n\toptions?: ComputedOptions<Value, Diff>\n): Computed<Value, Diff>\n/**\n * `@computed` decorator (TC39 decorators).\n * @public\n */\nexport function computed<This extends object, Value>(\n\tcompute: () => Value,\n\tcontext: ClassMethodDecoratorContext<This, () => Value>\n): () => Value\n/**\n * `@computed` decorator (legacy typescript decorator syntax).\n *\n * @public */\nexport function computed(\n\ttarget: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n): PropertyDescriptor\n/**\n * `@computed` decorator with options.\n * @public\n */\nexport function computed<Value, Diff = unknown>(\n\toptions?: ComputedOptions<Value, Diff>\n): ((target: any, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor) &\n\t(<This>(\n\t\tcompute: () => Value,\n\t\tcontext: ClassMethodDecoratorContext<This, () => Value>\n\t) => () => Value)\n\n/** @public */\nexport function computed() {\n\tif (arguments.length === 1) {\n\t\tconst options = arguments[0]\n\t\treturn (...args: any) => computedDecorator(options, args)\n\t} else if (typeof arguments[0] === 'string') {\n\t\treturn new _Computed(arguments[0], arguments[1], arguments[2])\n\t} else {\n\t\treturn computedDecorator(undefined, arguments as any)\n\t}\n}\n\n/**\n * Returns true if the given value is a computed signal.\n *\n * @param value\n * @returns {value is Computed<any>}\n * @public\n */\nexport function isComputed(value: any): value is Computed<any> {\n\treturn value && value instanceof _Computed\n}\n", "let didWarnComputedGetter = false\n\nexport function logComputedGetterWarning() {\n\tif (didWarnComputedGetter) return\n\tdidWarnComputedGetter = true\n\tconsole.warn(\n\t\t`Using \\`@computed\\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \\`@computed\\` as a decorator for methods.\n\n// Before\n@computed\nget foo() {\n\treturn 'foo'\n}\n\n// After\n@computed\ngetFoo() {\n\treturn 'foo'\n}\n`\n\t)\n}\n", "import { _Atom } from './Atom'\nimport { _Computed } from './Computed'\nimport { Signal } from './types'\n\n/**\n * @public\n */\nexport function isSignal(value: any): value is Signal<any> {\n\treturn value instanceof _Atom || value instanceof _Computed\n}\n", "// quarter of a megabyte, max possible utf-8 string size\n\n// cloudflare workers only accept messages of max 1mb\nconst MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES = 1024 * 1024\n// utf-8 is max 4 bytes per char\nconst MAX_BYTES_PER_CHAR = 4\n\n// in the (admittedly impossible) worst case, the max size is 1/4 of a megabyte\nconst MAX_SAFE_MESSAGE_SIZE = MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES / MAX_BYTES_PER_CHAR\n\n/** @internal */\nexport function chunk(msg: string, maxSafeMessageSize = MAX_SAFE_MESSAGE_SIZE) {\n\tif (msg.length < maxSafeMessageSize) {\n\t\treturn [msg]\n\t} else {\n\t\tconst chunks = []\n\t\tlet chunkNumber = 0\n\t\tlet offset = msg.length\n\t\twhile (offset > 0) {\n\t\t\tconst prefix = `${chunkNumber}_`\n\t\t\tconst chunkSize = Math.max(Math.min(maxSafeMessageSize - prefix.length, offset), 1)\n\t\t\tchunks.unshift(prefix + msg.slice(offset - chunkSize, offset))\n\t\t\toffset -= chunkSize\n\t\t\tchunkNumber++\n\t\t}\n\t\treturn chunks\n\t}\n}\n\nconst chunkRe = /^(\\d+)_(.*)$/\n\nexport class JsonChunkAssembler {\n\tstate:\n\t\t| 'idle'\n\t\t| {\n\t\t\t\tchunksReceived: string[]\n\t\t\t\ttotalChunks: number\n\t\t  } = 'idle'\n\n\thandleMessage(msg: string): { error: Error } | { stringified: string; data: object } | null {\n\t\tif (msg.startsWith('{')) {\n\t\t\tconst error = this.state === 'idle' ? undefined : new Error('Unexpected non-chunk message')\n\t\t\tthis.state = 'idle'\n\t\t\treturn error ? { error } : { data: JSON.parse(msg), stringified: msg }\n\t\t} else {\n\t\t\tconst match = chunkRe.exec(msg)!\n\t\t\tif (!match) {\n\t\t\t\tthis.state = 'idle'\n\t\t\t\treturn { error: new Error('Invalid chunk: ' + JSON.stringify(msg.slice(0, 20) + '...')) }\n\t\t\t}\n\t\t\tconst numChunksRemaining = Number(match[1])\n\t\t\tconst data = match[2]\n\n\t\t\tif (this.state === 'idle') {\n\t\t\t\tthis.state = {\n\t\t\t\t\tchunksReceived: [data],\n\t\t\t\t\ttotalChunks: numChunksRemaining + 1,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.state.chunksReceived.push(data)\n\t\t\t\tif (numChunksRemaining !== this.state.totalChunks - this.state.chunksReceived.length) {\n\t\t\t\t\tthis.state = 'idle'\n\t\t\t\t\treturn { error: new Error(`Chunks received in wrong order`) }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.state.chunksReceived.length === this.state.totalChunks) {\n\t\t\t\ttry {\n\t\t\t\t\tconst stringified = this.state.chunksReceived.join('')\n\t\t\t\t\tconst data = JSON.parse(stringified)\n\t\t\t\t\treturn { data, stringified }\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn { error: e as Error }\n\t\t\t\t} finally {\n\t\t\t\t\tthis.state = 'idle'\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null\n\t\t}\n\t}\n}\n", "import { Signal, react, transact } from '@tldraw/state'\nimport {\n\tRecordId,\n\tRecordsDiff,\n\tStore,\n\tUnknownRecord,\n\treverseRecordsDiff,\n\tsquashRecordDiffs,\n} from '@tldraw/store'\nimport { exhaustiveSwitchError, fpsThrottle, objectMapEntries, uniqueId } from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\nimport { NetworkDiff, RecordOpType, applyObjectDiff, diffRecord, getNetworkDiff } from './diff'\nimport { interval } from './interval'\nimport {\n\tTLPushRequest,\n\tTLSocketClientSentEvent,\n\tTLSocketServerSentDataEvent,\n\tTLSocketServerSentEvent,\n\tgetTlsyncProtocolVersion,\n} from './protocol'\n\n/** @internal */\nexport type SubscribingFn<T> = (cb: (val: T) => void) => () => void\n\n/**\n * This the close code that we use on the server to signal to a socket that\n * the connection is being closed because of a non-recoverable error.\n *\n * You should use this if you need to close a connection.\n *\n * @example\n * ```ts\n * socket.close(TLSyncErrorCloseEventCode, TLSyncErrorCloseEventReason.NOT_FOUND)\n * ```\n *\n * The `reason` parameter that you pass to `socket.close()` will be made available at `useSync().error.reason`\n *\n * @public\n */\nexport const TLSyncErrorCloseEventCode = 4099 as const\n\n/**\n * The set of reasons that a connection can be closed by the server\n * @public\n */\nexport const TLSyncErrorCloseEventReason = {\n\tNOT_FOUND: 'NOT_FOUND',\n\tFORBIDDEN: 'FORBIDDEN',\n\tNOT_AUTHENTICATED: 'NOT_AUTHENTICATED',\n\tUNKNOWN_ERROR: 'UNKNOWN_ERROR',\n\tCLIENT_TOO_OLD: 'CLIENT_TOO_OLD',\n\tSERVER_TOO_OLD: 'SERVER_TOO_OLD',\n\tINVALID_RECORD: 'INVALID_RECORD',\n} as const\n/**\n * The set of reasons that a connection can be closed by the server\n * @public\n */\nexport type TLSyncErrorCloseEventReason =\n\t(typeof TLSyncErrorCloseEventReason)[keyof typeof TLSyncErrorCloseEventReason]\n\n/**\n * @internal\n */\nexport type TlSocketStatusChangeEvent =\n\t| {\n\t\t\tstatus: 'online' | 'offline'\n\t  }\n\t| {\n\t\t\tstatus: 'error'\n\t\t\treason: string\n\t  }\n/** @internal */\nexport type TLSocketStatusListener = (params: TlSocketStatusChangeEvent) => void\n\n/** @internal */\nexport type TLPersistentClientSocketStatus = 'online' | 'offline' | 'error'\n/**\n * A socket that can be used to send and receive messages to the server. It should handle staying\n * open and reconnecting when the connection is lost. In actual client code this will be a wrapper\n * around a websocket or socket.io or something similar.\n *\n * @internal\n */\nexport interface TLPersistentClientSocket<R extends UnknownRecord = UnknownRecord> {\n\t/** Whether there is currently an open connection to the server. */\n\tconnectionStatus: 'online' | 'offline' | 'error'\n\t/** Send a message to the server */\n\tsendMessage(msg: TLSocketClientSentEvent<R>): void\n\t/** Attach a listener for messages sent by the server */\n\tonReceiveMessage: SubscribingFn<TLSocketServerSentEvent<R>>\n\t/** Attach a listener for connection status changes */\n\tonStatusChange: SubscribingFn<TlSocketStatusChangeEvent>\n\t/** Restart the connection */\n\trestart(): void\n}\n\nconst PING_INTERVAL = 5000\nconst MAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION = PING_INTERVAL * 2\n\n// Should connect support chunking the response to allow for large payloads?\n\n/**\n * TLSyncClient manages syncing data in a local Store with a remote server.\n *\n * It uses a git-style push/pull/rebase model.\n *\n * @internal\n */\nexport class TLSyncClient<R extends UnknownRecord, S extends Store<R> = Store<R>> {\n\t/** The last clock time from the most recent server update */\n\tprivate lastServerClock = 0\n\tprivate lastServerInteractionTimestamp = Date.now()\n\n\t/** The queue of in-flight push requests that have not yet been acknowledged by the server */\n\tprivate pendingPushRequests: { request: TLPushRequest<R>; sent: boolean }[] = []\n\n\t/**\n\t * The diff of 'unconfirmed', 'optimistic' changes that have been made locally by the user if we\n\t * take this diff, reverse it, and apply that to the store, our store will match exactly the most\n\t * recent state of the server that we know about\n\t */\n\tprivate speculativeChanges: RecordsDiff<R> = {\n\t\tadded: {} as any,\n\t\tupdated: {} as any,\n\t\tremoved: {} as any,\n\t}\n\n\tprivate disposables: Array<() => void> = []\n\n\treadonly store: S\n\treadonly socket: TLPersistentClientSocket<R>\n\n\treadonly presenceState: Signal<R | null> | undefined\n\n\t// isOnline is true when we have an open socket connection and we have\n\t// established a connection with the server room (i.e. we have received a 'connect' message)\n\tisConnectedToRoom = false\n\n\t/**\n\t * The client clock is essentially a counter for push requests Each time a push request is created\n\t * the clock is incremented. This clock is sent with the push request to the server, and the\n\t * server returns it with the response so that we can match up the response with the request.\n\t *\n\t * The clock may also be used at one point in the future to allow the client to re-send push\n\t * requests idempotently (i.e. the server will keep track of each client's clock and not execute\n\t * requests it has already handled), but at the time of writing this is neither needed nor\n\t * implemented.\n\t */\n\tprivate clientClock = 0\n\n\t/**\n\t * Called immediately after a connect acceptance has been received and processed Use this to make\n\t * any changes to the store that are required to keep it operational\n\t */\n\tpublic readonly onAfterConnect?: (self: this, details: { isReadonly: boolean }) => void\n\n\tprivate isDebugging = false\n\tprivate debug(...args: any[]) {\n\t\tif (this.isDebugging) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.debug(...args)\n\t\t}\n\t}\n\n\tprivate readonly presenceType: R['typeName'] | null\n\n\tdidCancel?: () => boolean\n\n\tconstructor(config: {\n\t\tstore: S\n\t\tsocket: TLPersistentClientSocket<R>\n\t\tpresence: Signal<R | null>\n\t\tonLoad(self: TLSyncClient<R, S>): void\n\t\tonSyncError(reason: string): void\n\t\tonAfterConnect?(self: TLSyncClient<R, S>, details: { isReadonly: boolean }): void\n\t\tdidCancel?(): boolean\n\t}) {\n\t\tthis.didCancel = config.didCancel\n\n\t\tthis.presenceType = config.store.scopedTypes.presence.values().next().value\n\n\t\tif (typeof window !== 'undefined') {\n\t\t\t;(window as any).tlsync = this\n\t\t}\n\t\tthis.store = config.store\n\t\tthis.socket = config.socket\n\t\tthis.onAfterConnect = config.onAfterConnect\n\n\t\tlet didLoad = false\n\n\t\tthis.presenceState = config.presence\n\n\t\tthis.disposables.push(\n\t\t\t// when local 'user' changes are made, send them to the server\n\t\t\t// or stash them locally in offline mode\n\t\t\tthis.store.listen(\n\t\t\t\t({ changes }) => {\n\t\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\t\tthis.debug('received store changes', { changes })\n\t\t\t\t\tthis.push(changes)\n\t\t\t\t},\n\t\t\t\t{ source: 'user', scope: 'document' }\n\t\t\t),\n\t\t\t// when the server sends us events, handle them\n\t\t\tthis.socket.onReceiveMessage((msg) => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('received message from server', msg)\n\t\t\t\tthis.handleServerEvent(msg)\n\t\t\t\t// the first time we receive a message from the server, we should trigger\n\n\t\t\t\t// one of the load callbacks\n\t\t\t\tif (!didLoad) {\n\t\t\t\t\tdidLoad = true\n\t\t\t\t\tconfig.onLoad(this)\n\t\t\t\t}\n\t\t\t}),\n\t\t\t// handle switching between online and offline\n\t\t\tthis.socket.onStatusChange((ev) => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('socket status changed', ev.status)\n\t\t\t\tif (ev.status === 'online') {\n\t\t\t\t\tthis.sendConnectMessage()\n\t\t\t\t} else {\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t\tif (ev.status === 'error') {\n\t\t\t\t\t\tdidLoad = true\n\t\t\t\t\t\tconfig.onSyncError(ev.reason)\n\t\t\t\t\t\tthis.close()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\t// Send a ping every PING_INTERVAL ms while online\n\t\t\tinterval(() => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('ping loop', { isConnectedToRoom: this.isConnectedToRoom })\n\t\t\t\tif (!this.isConnectedToRoom) return\n\t\t\t\ttry {\n\t\t\t\t\tthis.socket.sendMessage({ type: 'ping' })\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn('ping failed, resetting', error)\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t}\n\t\t\t}, PING_INTERVAL),\n\t\t\t// Check the server connection health, reset the connection if needed\n\t\t\tinterval(() => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('health check loop', { isConnectedToRoom: this.isConnectedToRoom })\n\t\t\t\tif (!this.isConnectedToRoom) return\n\t\t\t\tconst timeSinceLastServerInteraction = Date.now() - this.lastServerInteractionTimestamp\n\n\t\t\t\tif (\n\t\t\t\t\ttimeSinceLastServerInteraction <\n\t\t\t\t\tMAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION\n\t\t\t\t) {\n\t\t\t\t\tthis.debug('health check passed', { timeSinceLastServerInteraction })\n\t\t\t\t\t// last ping was recent, so no need to take any action\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconsole.warn(`Haven't heard from the server in a while, resetting connection...`)\n\t\t\t\tthis.resetConnection()\n\t\t\t}, PING_INTERVAL * 2)\n\t\t)\n\n\t\tif (this.presenceState) {\n\t\t\tthis.disposables.push(\n\t\t\t\treact('pushPresence', () => {\n\t\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\t\tthis.pushPresence(this.presenceState!.get())\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\t// if the socket is already online before this client was instantiated\n\t\t// then we should send a connect message right away\n\t\tif (this.socket.connectionStatus === 'online') {\n\t\t\tthis.sendConnectMessage()\n\t\t}\n\t}\n\n\tlatestConnectRequestId: string | null = null\n\n\t/**\n\t * This is the first message that is sent over a newly established socket connection. And we need\n\t * to wait for the response before this client can be used.\n\t */\n\tprivate sendConnectMessage() {\n\t\tif (this.isConnectedToRoom) {\n\t\t\tconsole.error('sendConnectMessage called while already connected')\n\t\t\treturn\n\t\t}\n\t\tthis.debug('sending connect message')\n\t\tthis.latestConnectRequestId = uniqueId()\n\t\tthis.socket.sendMessage({\n\t\t\ttype: 'connect',\n\t\t\tconnectRequestId: this.latestConnectRequestId,\n\t\t\tschema: this.store.schema.serialize(),\n\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\tlastServerClock: this.lastServerClock,\n\t\t})\n\t}\n\n\t/** Switch to offline mode */\n\tprivate resetConnection(hard = false) {\n\t\tthis.debug('resetting connection')\n\t\tif (hard) {\n\t\t\tthis.lastServerClock = 0\n\t\t}\n\t\t// kill all presence state\n\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\tthis.store.remove(Object.keys(this.store.serialize('presence')) as any)\n\t\t})\n\t\tthis.lastPushedPresenceState = null\n\t\tthis.isConnectedToRoom = false\n\t\tthis.pendingPushRequests = []\n\t\tthis.incomingDiffBuffer = []\n\t\tif (this.socket.connectionStatus === 'online') {\n\t\t\tthis.socket.restart()\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when the socket connection comes online, either for the first time or as the result of\n\t * a reconnect. The goal is to rebase on the server's state and fire off a new push request for\n\t * any local changes that were made while offline.\n\t */\n\tprivate didReconnect(event: Extract<TLSocketServerSentEvent<R>, { type: 'connect' }>) {\n\t\tthis.debug('did reconnect', event)\n\t\tif (event.connectRequestId !== this.latestConnectRequestId) {\n\t\t\t// ignore connect events for old connect requests\n\t\t\treturn\n\t\t}\n\t\tthis.latestConnectRequestId = null\n\n\t\tif (this.isConnectedToRoom) {\n\t\t\tconsole.error('didReconnect called while already connected')\n\t\t\tthis.resetConnection(true)\n\t\t\treturn\n\t\t}\n\t\tif (this.pendingPushRequests.length > 0) {\n\t\t\tconsole.error('pendingPushRequests should already be empty when we reconnect')\n\t\t\tthis.resetConnection(true)\n\t\t\treturn\n\t\t}\n\t\t// at the end of this process we want to have at most one pending push request\n\t\t// based on anything inside this.speculativeChanges\n\t\ttransact(() => {\n\t\t\t// Now our goal is to rebase on the server's state.\n\t\t\t// This means wiping away any peer presence data, which the server will replace in full on every connect.\n\t\t\t// If the server does not have enough history to give us a partial document state hydration we will\n\t\t\t// also need to wipe away all of our document state before hydrating with the server's state from scratch.\n\t\t\tconst stashedChanges = this.speculativeChanges\n\t\t\tthis.speculativeChanges = { added: {} as any, updated: {} as any, removed: {} as any }\n\n\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t// gather records to delete in a NetworkDiff\n\t\t\t\tconst wipeDiff: NetworkDiff<R> = {}\n\t\t\t\tconst wipeAll = event.hydrationType === 'wipe_all'\n\t\t\t\tif (!wipeAll) {\n\t\t\t\t\t// if we're only wiping presence data, undo the speculative changes first\n\t\t\t\t\tthis.store.applyDiff(reverseRecordsDiff(stashedChanges), { runCallbacks: false })\n\t\t\t\t}\n\n\t\t\t\t// now wipe all presence data and, if needed, all document data\n\t\t\t\tfor (const [id, record] of objectMapEntries(this.store.serialize('all'))) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t(wipeAll && this.store.scopedTypes.document.has(record.typeName)) ||\n\t\t\t\t\t\trecord.typeName === this.presenceType\n\t\t\t\t\t) {\n\t\t\t\t\t\twipeDiff[id] = [RecordOpType.Remove]\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// then apply the upstream changes\n\t\t\t\tthis.applyNetworkDiff({ ...wipeDiff, ...event.diff }, true)\n\n\t\t\t\tthis.isConnectedToRoom = true\n\n\t\t\t\t// now re-apply the speculative changes creating a new push request with the\n\t\t\t\t// appropriate diff\n\t\t\t\tconst speculativeChanges = this.store.filterChangesByScope(\n\t\t\t\t\tthis.store.extractingChanges(() => {\n\t\t\t\t\t\tthis.store.applyDiff(stashedChanges)\n\t\t\t\t\t}),\n\t\t\t\t\t'document'\n\t\t\t\t)\n\t\t\t\tif (speculativeChanges) this.push(speculativeChanges)\n\t\t\t})\n\n\t\t\t// this.isConnectedToRoom = true\n\t\t\t// this.store.applyDiff(stashedChanges, false)\n\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.onAfterConnect?.(this, { isReadonly: event.isReadonly })\n\t\t})\n\n\t\tthis.lastServerClock = event.serverClock\n\t}\n\n\tincomingDiffBuffer: TLSocketServerSentDataEvent<R>[] = []\n\n\t/** Handle events received from the server */\n\tprivate handleServerEvent(event: TLSocketServerSentEvent<R>) {\n\t\tthis.debug('received server event', event)\n\t\tthis.lastServerInteractionTimestamp = Date.now()\n\t\t// always update the lastServerClock when it is present\n\t\tswitch (event.type) {\n\t\t\tcase 'connect':\n\t\t\t\tthis.didReconnect(event)\n\t\t\t\tbreak\n\t\t\t// legacy v4 events\n\t\t\tcase 'patch':\n\t\t\tcase 'push_result':\n\t\t\t\tif (!this.isConnectedToRoom) break\n\t\t\t\tthis.incomingDiffBuffer.push(event)\n\t\t\t\tthis.scheduleRebase()\n\t\t\t\tbreak\n\t\t\tcase 'data':\n\t\t\t\t// wait for a connect to succeed before processing more events\n\t\t\t\tif (!this.isConnectedToRoom) break\n\t\t\t\tthis.incomingDiffBuffer.push(...event.data)\n\t\t\t\tthis.scheduleRebase()\n\t\t\t\tbreak\n\t\t\tcase 'incompatibility_error':\n\t\t\t\t// legacy unrecoverable errors\n\t\t\t\tconsole.error('incompatibility error is legacy and should no longer be sent by the server')\n\t\t\t\tbreak\n\t\t\tcase 'pong':\n\t\t\t\t// noop, we only use ping/pong to set lastSeverInteractionTimestamp\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(event)\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.debug('closing')\n\t\tthis.disposables.forEach((dispose) => dispose())\n\t\tthis.flushPendingPushRequests.cancel?.()\n\t\tthis.scheduleRebase.cancel?.()\n\t}\n\n\tlastPushedPresenceState: R | null = null\n\n\tprivate pushPresence(nextPresence: R | null) {\n\t\t// make sure we push any document changes first\n\t\tthis.store._flushHistory()\n\n\t\tif (!this.isConnectedToRoom) {\n\t\t\t// if we're offline, don't do anything\n\t\t\treturn\n\t\t}\n\n\t\tlet presence: TLPushRequest<any>['presence'] = undefined\n\t\tif (!this.lastPushedPresenceState && nextPresence) {\n\t\t\t// we don't have a last presence state, so we need to push the full state\n\t\t\tpresence = [RecordOpType.Put, nextPresence]\n\t\t} else if (this.lastPushedPresenceState && nextPresence) {\n\t\t\t// we have a last presence state, so we need to push a diff if there is one\n\t\t\tconst diff = diffRecord(this.lastPushedPresenceState, nextPresence)\n\t\t\tif (diff) {\n\t\t\t\tpresence = [RecordOpType.Patch, diff]\n\t\t\t}\n\t\t}\n\n\t\tif (!presence) return\n\t\tthis.lastPushedPresenceState = nextPresence\n\n\t\t// if there is a pending push that has not been sent and does not already include a presence update,\n\t\t// then add this presence update to it\n\t\tconst lastPush = this.pendingPushRequests.at(-1)\n\t\tif (lastPush && !lastPush.sent && !lastPush.request.presence) {\n\t\t\tlastPush.request.presence = presence\n\t\t\treturn\n\t\t}\n\n\t\t// otherwise, create a new push request\n\t\tconst req: TLPushRequest<R> = {\n\t\t\ttype: 'push',\n\t\t\tclientClock: this.clientClock++,\n\t\t\tpresence,\n\t\t}\n\n\t\tif (req) {\n\t\t\tthis.pendingPushRequests.push({ request: req, sent: false })\n\t\t\tthis.flushPendingPushRequests()\n\t\t}\n\t}\n\n\t/** Push a change to the server, or stash it locally if we're offline */\n\tprivate push(change: RecordsDiff<any>) {\n\t\tthis.debug('push', change)\n\t\t// the Store doesn't do deep equality checks when making changes\n\t\t// so it's possible that the diff passed in here is actually a no-op.\n\t\t// either way, we also don't want to send whole objects over the wire if\n\t\t// only small parts of them have changed, so we'll do a shallow-ish diff\n\t\t// which also uses deep equality checks to see if the change is actually\n\t\t// a no-op.\n\t\tconst diff = getNetworkDiff(change)\n\t\tif (!diff) return\n\n\t\t// the change is not a no-op so we'll send it to the server\n\t\t// but first let's merge the records diff into the speculative changes\n\t\tthis.speculativeChanges = squashRecordDiffs([this.speculativeChanges, change])\n\n\t\tif (!this.isConnectedToRoom) {\n\t\t\t// don't sent push requests or even store them up while offline\n\t\t\t// when we come back online we'll generate another push request from\n\t\t\t// scratch based on the speculativeChanges diff\n\t\t\treturn\n\t\t}\n\n\t\tconst pushRequest: TLPushRequest<R> = {\n\t\t\ttype: 'push',\n\t\t\tdiff,\n\t\t\tclientClock: this.clientClock++,\n\t\t}\n\n\t\tthis.pendingPushRequests.push({ request: pushRequest, sent: false })\n\n\t\t// immediately calling .send on the websocket here was causing some interaction\n\t\t// slugishness when e.g. drawing or translating shapes. Seems like it blocks\n\t\t// until the send completes. So instead we'll schedule a send to happen on some\n\t\t// tick in the near future.\n\t\tthis.flushPendingPushRequests()\n\t}\n\n\t/** Send any unsent push requests to the server */\n\tprivate flushPendingPushRequests = fpsThrottle(() => {\n\t\tthis.debug('flushing pending push requests', {\n\t\t\tisConnectedToRoom: this.isConnectedToRoom,\n\t\t\tpendingPushRequests: this.pendingPushRequests,\n\t\t})\n\t\tif (!this.isConnectedToRoom || this.store.isPossiblyCorrupted()) {\n\t\t\treturn\n\t\t}\n\t\tfor (const pendingPushRequest of this.pendingPushRequests) {\n\t\t\tif (!pendingPushRequest.sent) {\n\t\t\t\tif (this.socket.connectionStatus !== 'online') {\n\t\t\t\t\t// we went offline, so don't send anything\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.socket.sendMessage(pendingPushRequest.request)\n\t\t\t\tpendingPushRequest.sent = true\n\t\t\t}\n\t\t}\n\t})\n\n\t/**\n\t * Applies a 'network' diff to the store this does value-based equality checking so that if the\n\t * data is the same (as opposed to merely identical with ===), then no change is made and no\n\t * changes will be propagated back to store listeners\n\t */\n\tprivate applyNetworkDiff(diff: NetworkDiff<R>, runCallbacks: boolean) {\n\t\tthis.debug('applyNetworkDiff', diff)\n\t\tconst changes: RecordsDiff<R> = { added: {} as any, updated: {} as any, removed: {} as any }\n\t\ttype k = keyof typeof changes.updated\n\t\tlet hasChanges = false\n\t\tfor (const [id, op] of objectMapEntries(diff)) {\n\t\t\tif (op[0] === RecordOpType.Put) {\n\t\t\t\tconst existing = this.store.get(id as RecordId<any>)\n\t\t\t\tif (existing && !isEqual(existing, op[1])) {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.updated[id as k] = [existing, op[1]]\n\t\t\t\t} else {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.added[id as k] = op[1]\n\t\t\t\t}\n\t\t\t} else if (op[0] === RecordOpType.Patch) {\n\t\t\t\tconst record = this.store.get(id as RecordId<any>)\n\t\t\t\tif (!record) {\n\t\t\t\t\t// the record was removed upstream\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst patched = applyObjectDiff(record, op[1])\n\t\t\t\thasChanges = true\n\t\t\t\tchanges.updated[id as k] = [record, patched]\n\t\t\t} else if (op[0] === RecordOpType.Remove) {\n\t\t\t\tif (this.store.has(id as RecordId<any>)) {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.removed[id as k] = this.store.get(id as RecordId<any>)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasChanges) {\n\t\t\tthis.store.applyDiff(changes, { runCallbacks })\n\t\t}\n\t}\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tprivate rebase = () => {\n\t\t// need to make sure that our speculative changes are in sync with the actual store instance before\n\t\t// proceeding, to avoid inconsistency bugs.\n\t\tthis.store._flushHistory()\n\t\tif (this.incomingDiffBuffer.length === 0) return\n\n\t\tconst diffs = this.incomingDiffBuffer\n\t\tthis.incomingDiffBuffer = []\n\n\t\ttry {\n\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t// first undo speculative changes\n\t\t\t\tthis.store.applyDiff(reverseRecordsDiff(this.speculativeChanges), { runCallbacks: false })\n\n\t\t\t\t// then apply network diffs on top of known-to-be-synced data\n\t\t\t\tfor (const diff of diffs) {\n\t\t\t\t\tif (diff.type === 'patch') {\n\t\t\t\t\t\tthis.applyNetworkDiff(diff.diff, true)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// handling push_result\n\t\t\t\t\tif (this.pendingPushRequests.length === 0) {\n\t\t\t\t\t\tthrow new Error('Received push_result but there are no pending push requests')\n\t\t\t\t\t}\n\t\t\t\t\tif (this.pendingPushRequests[0].request.clientClock !== diff.clientClock) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Received push_result for a push request that is not at the front of the queue'\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.action === 'discard') {\n\t\t\t\t\t\tthis.pendingPushRequests.shift()\n\t\t\t\t\t} else if (diff.action === 'commit') {\n\t\t\t\t\t\tconst { request } = this.pendingPushRequests.shift()!\n\t\t\t\t\t\tif ('diff' in request && request.diff) {\n\t\t\t\t\t\t\tthis.applyNetworkDiff(request.diff, true)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.applyNetworkDiff(diff.action.rebaseWithDiff, true)\n\t\t\t\t\t\tthis.pendingPushRequests.shift()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// update the speculative diff while re-applying pending changes\n\t\t\t\ttry {\n\t\t\t\t\tthis.speculativeChanges = this.store.extractingChanges(() => {\n\t\t\t\t\t\tfor (const { request } of this.pendingPushRequests) {\n\t\t\t\t\t\t\tif (!('diff' in request) || !request.diff) continue\n\t\t\t\t\t\t\tthis.applyNetworkDiff(request.diff, true)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e)\n\t\t\t\t\t// throw away the speculative changes and start over\n\t\t\t\t\tthis.speculativeChanges = { added: {} as any, updated: {} as any, removed: {} as any }\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t}\n\t\t\t})\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.lastServerClock = diffs.at(-1)?.serverClock ?? this.lastServerClock\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.resetConnection()\n\t\t}\n\t}\n\n\tprivate scheduleRebase = fpsThrottle(this.rebase)\n}\n", "import { registerTldrawLibraryVersion } from '@tldraw/utils'\nexport type { BaseRecord, IdOf, RecordId, UnknownRecord } from './lib/BaseRecord'\nexport { IncrementalSetConstructor } from './lib/IncrementalSetConstructor'\nexport { RecordType, assertIdType, createRecordType, type RecordScope } from './lib/RecordType'\nexport {\n\tcreateEmptyRecordsDiff,\n\tisRecordsDiffEmpty,\n\treverseRecordsDiff,\n\tsquashRecordDiffs,\n\tsquashRecordDiffsMutable,\n\ttype RecordsDiff,\n} from './lib/RecordsDiff'\nexport {\n\tStore,\n\tcreateComputedCache,\n\ttype ChangeSource,\n\ttype RecordFromId,\n\ttype StoreListenerFilters,\n\ttype StoreObject,\n\ttype StoreObjectRecordType,\n} from './lib/Store'\nexport type {\n\tCollectionDiff,\n\tComputedCache,\n\tHistoryEntry,\n\tSerializedStore,\n\tStoreError,\n\tStoreListener,\n\tStoreSnapshot,\n\tStoreValidator,\n\tStoreValidators,\n} from './lib/Store'\nexport { StoreQueries, type RSIndex, type RSIndexDiff, type RSIndexMap } from './lib/StoreQueries'\nexport { StoreSchema, type StoreValidationFailure } from './lib/StoreSchema'\nexport type {\n\tSerializedSchema,\n\tSerializedSchemaV1,\n\tSerializedSchemaV2,\n\tStoreSchemaOptions,\n} from './lib/StoreSchema'\nexport {\n\tStoreSideEffects,\n\ttype StoreAfterChangeHandler,\n\ttype StoreAfterCreateHandler,\n\ttype StoreAfterDeleteHandler,\n\ttype StoreBeforeChangeHandler,\n\ttype StoreBeforeCreateHandler,\n\ttype StoreBeforeDeleteHandler,\n\ttype StoreOperationCompleteHandler,\n} from './lib/StoreSideEffects'\nexport { devFreeze } from './lib/devFreeze'\nexport { type QueryExpression, type QueryValueMatcher } from './lib/executeQuery'\nexport {\n\tMigrationFailureReason,\n\tcreateMigrationIds,\n\tcreateMigrationSequence,\n\tcreateRecordMigrationSequence,\n\t// eslint-disable-next-line deprecation/deprecation\n\tdefineMigrations,\n\tparseMigrationId,\n\ttype LegacyBaseMigrationsInfo,\n\ttype LegacyMigration,\n\ttype LegacyMigrations,\n\ttype Migration,\n\ttype MigrationId,\n\ttype MigrationResult,\n\ttype MigrationSequence,\n\ttype StandaloneDependsOn,\n} from './lib/migrate'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n", "import { CollectionDiff } from './Store'\n\n/**\n * A class that can be used to incrementally construct a set of records.\n *\n * @internal\n */\nexport class IncrementalSetConstructor<T> {\n\t/**\n\t * The next value of the set.\n\t *\n\t * @internal\n\t */\n\tprivate nextValue?: Set<T>\n\n\t/**\n\t * The diff of the set.\n\t *\n\t * @internal\n\t */\n\tprivate diff?: CollectionDiff<T>\n\n\tconstructor(\n\t\t/**\n\t\t * The previous value of the set.\n\t\t *\n\t\t * @internal\n\t\t * @readonly\n\t\t */\n\t\tprivate readonly previousValue: Set<T>\n\t) {}\n\n\t/**\n\t * Get the next value of the set.\n\t *\n\t * @public\n\t */\n\tpublic get() {\n\t\tconst numRemoved = this.diff?.removed?.size ?? 0\n\t\tconst numAdded = this.diff?.added?.size ?? 0\n\t\tif (numRemoved === 0 && numAdded === 0) {\n\t\t\treturn undefined\n\t\t}\n\t\treturn { value: this.nextValue!, diff: this.diff! }\n\t}\n\n\t/**\n\t * Add an item to the set.\n\t *\n\t * @param item - The item to add.\n\t * @param wasAlreadyPresent - Whether the item was already present in the set.\n\t * @internal\n\t */\n\tprivate _add(item: T, wasAlreadyPresent: boolean) {\n\t\tthis.nextValue ??= new Set(this.previousValue)\n\t\tthis.nextValue.add(item)\n\n\t\tthis.diff ??= {}\n\t\tif (wasAlreadyPresent) {\n\t\t\tthis.diff.removed?.delete(item)\n\t\t} else {\n\t\t\tthis.diff.added ??= new Set()\n\t\t\tthis.diff.added.add(item)\n\t\t}\n\t}\n\n\t/**\n\t * Add an item to the set.\n\t *\n\t * @param item - The item to add.\n\t * @public\n\t */\n\tadd(item: T) {\n\t\tconst wasAlreadyPresent = this.previousValue.has(item)\n\t\tif (wasAlreadyPresent) {\n\t\t\tconst wasRemoved = this.diff?.removed?.has(item)\n\t\t\t// if it wasn't removed during the lifetime of this set constructor, there's no need to add it again\n\t\t\tif (!wasRemoved) return\n\t\t\treturn this._add(item, wasAlreadyPresent)\n\t\t}\n\t\tconst isCurrentlyPresent = this.nextValue?.has(item)\n\t\t// if it's already there, no need to add it again\n\t\tif (isCurrentlyPresent) return\n\t\t// otherwise add it\n\t\tthis._add(item, wasAlreadyPresent)\n\t}\n\n\t/**\n\t * Remove an item from the set.\n\t *\n\t * @param item - The item to remove.\n\t * @param wasAlreadyPresent - Whether the item was already present in the set.\n\t * @internal\n\t */\n\tprivate _remove(item: T, wasAlreadyPresent: boolean) {\n\t\tthis.nextValue ??= new Set(this.previousValue)\n\t\tthis.nextValue.delete(item)\n\n\t\tthis.diff ??= {}\n\t\tif (wasAlreadyPresent) {\n\t\t\t// it was in the original set, so we need to add it to the removed diff\n\t\t\tthis.diff.removed ??= new Set()\n\t\t\tthis.diff.removed.add(item)\n\t\t} else {\n\t\t\t// if it was added during the lifetime of this set constructor, we need to remove it from the added diff\n\t\t\tthis.diff.added?.delete(item)\n\t\t}\n\t}\n\n\t/**\n\t * Remove an item from the set.\n\t *\n\t * @param item - The item to remove.\n\t * @public\n\t */\n\tremove(item: T) {\n\t\tconst wasAlreadyPresent = this.previousValue.has(item)\n\t\tif (!wasAlreadyPresent) {\n\t\t\tconst wasAdded = this.diff?.added?.has(item)\n\t\t\t// if it wasn't added during the lifetime of this set constructor, there's no need to remove it\n\t\t\tif (!wasAdded) return\n\t\t\treturn this._remove(item, wasAlreadyPresent)\n\t\t}\n\t\tconst hasAlreadyBeenRemoved = this.diff?.removed?.has(item)\n\t\t// if it's already removed, no need to remove it again\n\t\tif (hasAlreadyBeenRemoved) return\n\t\t// otherwise remove it\n\t\tthis._remove(item, wasAlreadyPresent)\n\t}\n}\n", "import { objectMapEntries, structuredClone, uniqueId } from '@tldraw/utils'\nimport { IdOf, UnknownRecord } from './BaseRecord'\nimport { StoreValidator } from './Store'\n\nexport type RecordTypeRecord<R extends RecordType<any, any>> = ReturnType<R['create']>\n\n/**\n * Defines the scope of the record\n *\n * session: The record belongs to a single instance of the store. It should not be synced, and any persistence logic should 'de-instance-ize' the record before persisting it, and apply the reverse when rehydrating.\n * document: The record is persisted and synced. It is available to all store instances.\n * presence: The record belongs to a single instance of the store. It may be synced to other instances, but other instances should not make changes to it. It should not be persisted.\n *\n * @public\n * */\nexport type RecordScope = 'session' | 'document' | 'presence'\n\n/**\n * A record type is a type that can be stored in a record store. It is created with\n * `createRecordType`.\n *\n * @public\n */\nexport class RecordType<\n\tR extends UnknownRecord,\n\tRequiredProperties extends keyof Omit<R, 'id' | 'typeName'>,\n> {\n\treadonly createDefaultProperties: () => Exclude<Omit<R, 'id' | 'typeName'>, RequiredProperties>\n\treadonly validator: StoreValidator<R>\n\treadonly ephemeralKeys?: { readonly [K in Exclude<keyof R, 'id' | 'typeName'>]: boolean }\n\treadonly ephemeralKeySet: ReadonlySet<string>\n\treadonly scope: RecordScope\n\n\tconstructor(\n\t\t/**\n\t\t * The unique type associated with this record.\n\t\t *\n\t\t * @public\n\t\t * @readonly\n\t\t */\n\t\tpublic readonly typeName: R['typeName'],\n\t\tconfig: {\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\treadonly createDefaultProperties: () => Exclude<\n\t\t\t\tOmit<R, 'id' | 'typeName'>,\n\t\t\t\tRequiredProperties\n\t\t\t>\n\t\t\treadonly validator?: StoreValidator<R>\n\t\t\treadonly scope?: RecordScope\n\t\t\treadonly ephemeralKeys?: { readonly [K in Exclude<keyof R, 'id' | 'typeName'>]: boolean }\n\t\t}\n\t) {\n\t\tthis.createDefaultProperties = config.createDefaultProperties\n\t\tthis.validator = config.validator ?? { validate: (r: unknown) => r as R }\n\t\tthis.scope = config.scope ?? 'document'\n\t\tthis.ephemeralKeys = config.ephemeralKeys\n\n\t\tconst ephemeralKeySet = new Set<string>()\n\t\tif (config.ephemeralKeys) {\n\t\t\tfor (const [key, isEphemeral] of objectMapEntries(config.ephemeralKeys)) {\n\t\t\t\tif (isEphemeral) ephemeralKeySet.add(key)\n\t\t\t}\n\t\t}\n\t\tthis.ephemeralKeySet = ephemeralKeySet\n\t}\n\n\t/**\n\t * Create a new record of this type.\n\t *\n\t * @param properties - The properties of the record.\n\t * @returns The new record.\n\t */\n\tcreate(properties: Pick<R, RequiredProperties> & Omit<Partial<R>, RequiredProperties>): R {\n\t\tconst result = { ...this.createDefaultProperties(), id: this.createId() } as any\n\n\t\tfor (const [k, v] of Object.entries(properties)) {\n\t\t\tif (v !== undefined) {\n\t\t\t\tresult[k] = v\n\t\t\t}\n\t\t}\n\n\t\tresult.typeName = this.typeName\n\n\t\treturn result as R\n\t}\n\n\t/**\n\t * Clone a record of this type.\n\t *\n\t * @param record - The record to clone.\n\t * @returns The cloned record.\n\t * @public\n\t */\n\tclone(record: R): R {\n\t\treturn { ...structuredClone(record), id: this.createId() }\n\t}\n\n\t/**\n\t * Create a new ID for this record type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const id = recordType.createId()\n\t * ```\n\t *\n\t * @returns The new ID.\n\t * @public\n\t */\n\tcreateId(customUniquePart?: string): IdOf<R> {\n\t\treturn (this.typeName + ':' + (customUniquePart ?? uniqueId())) as IdOf<R>\n\t}\n\n\t/**\n\t * Create a new ID for this record type based on the given ID.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const id = recordType.createCustomId('myId')\n\t * ```\n\t *\n\t * @deprecated - Use `createId` instead.\n\t * @param id - The ID to base the new ID on.\n\t * @returns The new ID.\n\t */\n\tcreateCustomId(id: string): IdOf<R> {\n\t\treturn (this.typeName + ':' + id) as IdOf<R>\n\t}\n\n\t/**\n\t * Takes an id like `user:123` and returns the part after the colon `123`\n\t *\n\t * @param id - The id\n\t * @returns\n\t */\n\tparseId(id: IdOf<R>): string {\n\t\tif (!this.isId(id)) {\n\t\t\tthrow new Error(`ID \"${id}\" is not a valid ID for type \"${this.typeName}\"`)\n\t\t}\n\n\t\treturn id.slice(this.typeName.length + 1)\n\t}\n\n\t/**\n\t * Check whether a record is an instance of this record type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const result = recordType.isInstance(someRecord)\n\t * ```\n\t *\n\t * @param record - The record to check.\n\t * @returns Whether the record is an instance of this record type.\n\t */\n\tisInstance(record?: UnknownRecord): record is R {\n\t\treturn record?.typeName === this.typeName\n\t}\n\n\t/**\n\t * Check whether an id is an id of this type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const result = recordType.isIn('someId')\n\t * ```\n\t *\n\t * @param id - The id to check.\n\t * @returns Whether the id is an id of this type.\n\t */\n\tisId(id?: string): id is IdOf<R> {\n\t\tif (!id) return false\n\t\tfor (let i = 0; i < this.typeName.length; i++) {\n\t\t\tif (id[i] !== this.typeName[i]) return false\n\t\t}\n\n\t\treturn id[this.typeName.length] === ':'\n\t}\n\n\t/**\n\t * Create a new RecordType that has the same type name as this RecordType and includes the given\n\t * default properties.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const authorType = createRecordType('author', () => ({ living: true }))\n\t * const deadAuthorType = authorType.withDefaultProperties({ living: false })\n\t * ```\n\t *\n\t * @param createDefaultProperties - A function that returns the default properties of the new RecordType.\n\t * @returns The new RecordType.\n\t */\n\twithDefaultProperties<DefaultProps extends Omit<Partial<R>, 'typeName' | 'id'>>(\n\t\tcreateDefaultProperties: () => DefaultProps\n\t): RecordType<R, Exclude<RequiredProperties, keyof DefaultProps>> {\n\t\treturn new RecordType<R, Exclude<RequiredProperties, keyof DefaultProps>>(this.typeName, {\n\t\t\tcreateDefaultProperties: createDefaultProperties as any,\n\t\t\tvalidator: this.validator,\n\t\t\tscope: this.scope,\n\t\t\tephemeralKeys: this.ephemeralKeys,\n\t\t})\n\t}\n\n\t/**\n\t * Check that the passed in record passes the validations for this type. Returns its input\n\t * correctly typed if it does, but throws an error otherwise.\n\t */\n\tvalidate(record: unknown, recordBefore?: R): R {\n\t\tif (recordBefore && this.validator.validateUsingKnownGoodVersion) {\n\t\t\treturn this.validator.validateUsingKnownGoodVersion(recordBefore, record)\n\t\t}\n\t\treturn this.validator.validate(record)\n\t}\n}\n\n/**\n * Create a record type.\n *\n * @example\n *\n * ```ts\n * const Book = createRecordType<Book>('book')\n * ```\n *\n * @param typeName - The name of the type to create.\n * @public\n */\nexport function createRecordType<R extends UnknownRecord>(\n\ttypeName: R['typeName'],\n\tconfig: {\n\t\tvalidator?: StoreValidator<R>\n\t\tscope: RecordScope\n\t\tephemeralKeys?: { readonly [K in Exclude<keyof R, 'id' | 'typeName'>]: boolean }\n\t}\n): RecordType<R, keyof Omit<R, 'id' | 'typeName'>> {\n\treturn new RecordType<R, keyof Omit<R, 'id' | 'typeName'>>(typeName, {\n\t\tcreateDefaultProperties: () => ({}) as any,\n\t\tvalidator: config.validator,\n\t\tscope: config.scope,\n\t\tephemeralKeys: config.ephemeralKeys,\n\t})\n}\n\n/**\n * Assert whether an id correspond to a record type.\n *\n * @example\n *\n * ```ts\n * assertIdType(myId, \"shape\")\n * ```\n *\n * @param id - The id to check.\n * @param type - The type of the record.\n * @public\n */\nexport function assertIdType<R extends UnknownRecord>(\n\tid: string | undefined,\n\ttype: RecordType<R, any>\n): asserts id is IdOf<R> {\n\tif (!id || !type.isId(id)) {\n\t\tthrow new Error(`string ${JSON.stringify(id)} is not a valid ${type.typeName} id`)\n\t}\n}\n", "import { objectMapEntries } from '@tldraw/utils'\nimport { IdOf, UnknownRecord } from './BaseRecord'\n\n/**\n * A diff describing the changes to a record.\n *\n * @public\n */\nexport interface RecordsDiff<R extends UnknownRecord> {\n\tadded: Record<IdOf<R>, R>\n\tupdated: Record<IdOf<R>, [from: R, to: R]>\n\tremoved: Record<IdOf<R>, R>\n}\n\n/** @internal */\nexport function createEmptyRecordsDiff<R extends UnknownRecord>(): RecordsDiff<R> {\n\treturn { added: {}, updated: {}, removed: {} } as RecordsDiff<R>\n}\n\n/** @public */\nexport function reverseRecordsDiff(diff: RecordsDiff<any>) {\n\tconst result: RecordsDiff<any> = { added: diff.removed, removed: diff.added, updated: {} }\n\tfor (const [from, to] of Object.values(diff.updated)) {\n\t\tresult.updated[from.id] = [to, from]\n\t}\n\treturn result\n}\n\n/**\n * Is a records diff empty?\n * @internal\n */\nexport function isRecordsDiffEmpty<T extends UnknownRecord>(diff: RecordsDiff<T>) {\n\treturn (\n\t\tObject.keys(diff.added).length === 0 &&\n\t\tObject.keys(diff.updated).length === 0 &&\n\t\tObject.keys(diff.removed).length === 0\n\t)\n}\n\n/**\n * Squash a collection of diffs into a single diff.\n *\n * @param diffs - An array of diffs to squash.\n * @returns A single diff that represents the squashed diffs.\n * @public\n */\nexport function squashRecordDiffs<T extends UnknownRecord>(\n\tdiffs: RecordsDiff<T>[]\n): RecordsDiff<T> {\n\tconst result = { added: {}, removed: {}, updated: {} } as RecordsDiff<T>\n\n\tsquashRecordDiffsMutable(result, diffs)\n\treturn result\n}\n\n/**\n * Apply the array `diffs` to the `target` diff, mutating it in-place.\n * @internal\n */\nexport function squashRecordDiffsMutable<T extends UnknownRecord>(\n\ttarget: RecordsDiff<T>,\n\tdiffs: RecordsDiff<T>[]\n): void {\n\tfor (const diff of diffs) {\n\t\tfor (const [id, value] of objectMapEntries(diff.added)) {\n\t\t\tif (target.removed[id]) {\n\t\t\t\tconst original = target.removed[id]\n\t\t\t\tdelete target.removed[id]\n\t\t\t\tif (original !== value) {\n\t\t\t\t\ttarget.updated[id] = [original, value]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttarget.added[id] = value\n\t\t\t}\n\t\t}\n\n\t\tfor (const [id, [_from, to]] of objectMapEntries(diff.updated)) {\n\t\t\tif (target.added[id]) {\n\t\t\t\ttarget.added[id] = to\n\t\t\t\tdelete target.updated[id]\n\t\t\t\tdelete target.removed[id]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (target.updated[id]) {\n\t\t\t\ttarget.updated[id] = [target.updated[id][0], to]\n\t\t\t\tdelete target.removed[id]\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttarget.updated[id] = diff.updated[id]\n\t\t\tdelete target.removed[id]\n\t\t}\n\n\t\tfor (const [id, value] of objectMapEntries(diff.removed)) {\n\t\t\t// the same record was added in this diff sequence, just drop it\n\t\t\tif (target.added[id]) {\n\t\t\t\tdelete target.added[id]\n\t\t\t} else if (target.updated[id]) {\n\t\t\t\ttarget.removed[id] = target.updated[id][0]\n\t\t\t\tdelete target.updated[id]\n\t\t\t} else {\n\t\t\t\ttarget.removed[id] = value\n\t\t\t}\n\t\t}\n\t}\n}\n", "import { Atom, Computed, Reactor, atom, computed, reactor, transact } from '@tldraw/state'\nimport {\n\tWeakCache,\n\tassert,\n\tfilterEntries,\n\tgetOwnProperty,\n\tobjectMapEntries,\n\tobjectMapFromEntries,\n\tobjectMapKeys,\n\tobjectMapValues,\n\tthrottleToNextFrame,\n\tuniqueId,\n} from '@tldraw/utils'\nimport { IdOf, RecordId, UnknownRecord } from './BaseRecord'\nimport { RecordScope } from './RecordType'\nimport { RecordsDiff, squashRecordDiffs } from './RecordsDiff'\nimport { StoreQueries } from './StoreQueries'\nimport { SerializedSchema, StoreSchema } from './StoreSchema'\nimport { StoreSideEffects } from './StoreSideEffects'\nimport { devFreeze } from './devFreeze'\n\n/** @public */\nexport type RecordFromId<K extends RecordId<UnknownRecord>> =\n\tK extends RecordId<infer R> ? R : never\n\n/**\n * A diff describing the changes to a collection.\n *\n * @public\n */\nexport interface CollectionDiff<T> {\n\tadded?: Set<T>\n\tremoved?: Set<T>\n}\n\n/** @public */\nexport type ChangeSource = 'user' | 'remote'\n\n/** @public */\nexport interface StoreListenerFilters {\n\tsource: ChangeSource | 'all'\n\tscope: RecordScope | 'all'\n}\n\n/**\n * An entry containing changes that originated either by user actions or remote changes.\n *\n * @public\n */\nexport interface HistoryEntry<R extends UnknownRecord = UnknownRecord> {\n\tchanges: RecordsDiff<R>\n\tsource: ChangeSource\n}\n\n/**\n * A function that will be called when the history changes.\n *\n * @public\n */\nexport type StoreListener<R extends UnknownRecord> = (entry: HistoryEntry<R>) => void\n\n/**\n * A record store is a collection of records of different types.\n *\n * @public\n */\nexport interface ComputedCache<Data, R extends UnknownRecord> {\n\tget(id: IdOf<R>): Data | undefined\n}\n\n/**\n * A serialized snapshot of the record store's values.\n *\n * @public\n */\nexport type SerializedStore<R extends UnknownRecord> = Record<IdOf<R>, R>\n\n/** @public */\nexport interface StoreSnapshot<R extends UnknownRecord> {\n\tstore: SerializedStore<R>\n\tschema: SerializedSchema\n}\n\n/** @public */\nexport interface StoreValidator<R extends UnknownRecord> {\n\tvalidate(record: unknown): R\n\tvalidateUsingKnownGoodVersion?(knownGoodVersion: R, record: unknown): R\n}\n\n/** @public */\nexport type StoreValidators<R extends UnknownRecord> = {\n\t[K in R['typeName']]: StoreValidator<Extract<R, { typeName: K }>>\n}\n\n/** @public */\nexport interface StoreError {\n\terror: Error\n\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests'\n\trecordBefore?: unknown\n\trecordAfter: unknown\n\tisExistingValidationIssue: boolean\n}\n\n/** @internal */\nexport type StoreRecord<S extends Store<any>> = S extends Store<infer R> ? R : never\n\n/**\n * A store of records.\n *\n * @public\n */\nexport class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {\n\t/**\n\t * The random id of the store.\n\t */\n\tpublic readonly id: string\n\t/**\n\t * An atom containing the store's atoms.\n\t *\n\t * @internal\n\t * @readonly\n\t */\n\tprivate readonly atoms = atom('store_atoms', {} as Record<IdOf<R>, Atom<R>>)\n\n\t/**\n\t * An atom containing the store's history.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\treadonly history: Atom<number, RecordsDiff<R>> = atom('history', 0, {\n\t\thistoryLength: 1000,\n\t})\n\n\t/**\n\t * A StoreQueries instance for this store.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\treadonly query = new StoreQueries<R>(this.atoms, this.history)\n\n\t/**\n\t * A set containing listeners that have been added to this store.\n\t *\n\t * @internal\n\t */\n\tprivate listeners = new Set<{ onHistory: StoreListener<R>; filters: StoreListenerFilters }>()\n\n\t/**\n\t * An array of history entries that have not yet been flushed.\n\t *\n\t * @internal\n\t */\n\tprivate historyAccumulator = new HistoryAccumulator<R>()\n\n\t/**\n\t * A reactor that responds to changes to the history by squashing the accumulated history and\n\t * notifying listeners of the changes.\n\t *\n\t * @internal\n\t */\n\tprivate historyReactor: Reactor\n\n\t/**\n\t * Function to dispose of any in-flight timeouts.\n\t *\n\t * @internal\n\t */\n\tprivate cancelHistoryReactor(): void {\n\t\t/* noop */\n\t}\n\n\treadonly schema: StoreSchema<R, Props>\n\n\treadonly props: Props\n\n\tpublic readonly scopedTypes: { readonly [K in RecordScope]: ReadonlySet<R['typeName']> }\n\n\tpublic readonly sideEffects = new StoreSideEffects<R>(this)\n\n\tconstructor(config: {\n\t\tid?: string\n\t\t/** The store's initial data. */\n\t\tinitialData?: SerializedStore<R>\n\t\t/**\n\t\t * A map of validators for each record type. A record's validator will be called when the record\n\t\t * is created or updated. It should throw an error if the record is invalid.\n\t\t */\n\t\tschema: StoreSchema<R, Props>\n\t\tprops: Props\n\t}) {\n\t\tconst { initialData, schema, id } = config\n\n\t\tthis.id = id ?? uniqueId()\n\t\tthis.schema = schema\n\t\tthis.props = config.props\n\n\t\tif (initialData) {\n\t\t\tthis.atoms.set(\n\t\t\t\tobjectMapFromEntries(\n\t\t\t\t\tobjectMapEntries(initialData).map(([id, record]) => [\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tatom(\n\t\t\t\t\t\t\t'atom:' + id,\n\t\t\t\t\t\t\tdevFreeze(this.schema.validateRecord(this, record, 'initialize', null))\n\t\t\t\t\t\t),\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tthis.historyReactor = reactor(\n\t\t\t'Store.historyReactor',\n\t\t\t() => {\n\t\t\t\t// deref to make sure we're subscribed regardless of whether we need to propagate\n\t\t\t\tthis.history.get()\n\t\t\t\t// If we have accumulated history, flush it and update listeners\n\t\t\t\tthis._flushHistory()\n\t\t\t},\n\t\t\t{ scheduleEffect: (cb) => (this.cancelHistoryReactor = throttleToNextFrame(cb)) }\n\t\t)\n\t\tthis.scopedTypes = {\n\t\t\tdocument: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t\tsession: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'session')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t\tpresence: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'presence')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t}\n\t}\n\n\tpublic _flushHistory() {\n\t\t// If we have accumulated history, flush it and update listeners\n\t\tif (this.historyAccumulator.hasChanges()) {\n\t\t\tconst entries = this.historyAccumulator.flush()\n\t\t\tfor (const { changes, source } of entries) {\n\t\t\t\tlet instanceChanges = null as null | RecordsDiff<R>\n\t\t\t\tlet documentChanges = null as null | RecordsDiff<R>\n\t\t\t\tlet presenceChanges = null as null | RecordsDiff<R>\n\t\t\t\tfor (const { onHistory, filters } of this.listeners) {\n\t\t\t\t\tif (filters.source !== 'all' && filters.source !== source) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif (filters.scope !== 'all') {\n\t\t\t\t\t\tif (filters.scope === 'document') {\n\t\t\t\t\t\t\tdocumentChanges ??= this.filterChangesByScope(changes, 'document')\n\t\t\t\t\t\t\tif (!documentChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: documentChanges, source })\n\t\t\t\t\t\t} else if (filters.scope === 'session') {\n\t\t\t\t\t\t\tinstanceChanges ??= this.filterChangesByScope(changes, 'session')\n\t\t\t\t\t\t\tif (!instanceChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: instanceChanges, source })\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpresenceChanges ??= this.filterChangesByScope(changes, 'presence')\n\t\t\t\t\t\t\tif (!presenceChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: presenceChanges, source })\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonHistory({ changes, source })\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.cancelHistoryReactor()\n\t}\n\n\t/**\n\t * Filters out non-document changes from a diff. Returns null if there are no changes left.\n\t * @param change - the records diff\n\t * @param scope - the records scope\n\t * @returns\n\t */\n\tfilterChangesByScope(change: RecordsDiff<R>, scope: RecordScope) {\n\t\tconst result = {\n\t\t\tadded: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),\n\t\t\tupdated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),\n\t\t\tremoved: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName)),\n\t\t}\n\t\tif (\n\t\t\tObject.keys(result.added).length === 0 &&\n\t\t\tObject.keys(result.updated).length === 0 &&\n\t\t\tObject.keys(result.removed).length === 0\n\t\t) {\n\t\t\treturn null\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Update the history with a diff of changes.\n\t *\n\t * @param changes - The changes to add to the history.\n\t */\n\tprivate updateHistory(changes: RecordsDiff<R>): void {\n\t\tthis.historyAccumulator.add({\n\t\t\tchanges,\n\t\t\tsource: this.isMergingRemoteChanges ? 'remote' : 'user',\n\t\t})\n\t\tif (this.listeners.size === 0) {\n\t\t\tthis.historyAccumulator.clear()\n\t\t}\n\t\tthis.history.set(this.history.get() + 1, changes)\n\t}\n\n\tvalidate(phase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests') {\n\t\tthis.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null))\n\t}\n\n\t/**\n\t * Add some records to the store. It's an error if they already exist.\n\t *\n\t * @param records - The records to add.\n\t * @param phaseOverride - The phase override.\n\t * @public\n\t */\n\tput(records: R[], phaseOverride?: 'initialize'): void {\n\t\tthis.atomic(() => {\n\t\t\tconst updates: Record<IdOf<UnknownRecord>, [from: R, to: R]> = {}\n\t\t\tconst additions: Record<IdOf<UnknownRecord>, R> = {}\n\n\t\t\tconst currentMap = this.atoms.__unsafe__getWithoutCapture()\n\t\t\tlet map = null as null | Record<IdOf<UnknownRecord>, Atom<R>>\n\n\t\t\t// Iterate through all records, creating, updating or removing as needed\n\t\t\tlet record: R\n\n\t\t\t// There's a chance that, despite having records, all of the values are\n\t\t\t// identical to what they were before; and so we'd end up with an \"empty\"\n\t\t\t// history entry. Let's keep track of whether we've actually made any\n\t\t\t// changes (e.g. additions, deletions, or updates that produce a new value).\n\t\t\tlet didChange = false\n\n\t\t\tconst source = this.isMergingRemoteChanges ? 'remote' : 'user'\n\n\t\t\tfor (let i = 0, n = records.length; i < n; i++) {\n\t\t\t\trecord = records[i]\n\n\t\t\t\tconst recordAtom = (map ?? currentMap)[record.id as IdOf<R>]\n\n\t\t\t\tif (recordAtom) {\n\t\t\t\t\t// If we already have an atom for this record, update its value.\n\t\t\t\t\tconst initialValue = recordAtom.__unsafe__getWithoutCapture()\n\n\t\t\t\t\t// If we have a beforeUpdate callback, run it against the initial and next records\n\t\t\t\t\trecord = this.sideEffects.handleBeforeChange(initialValue, record, source)\n\n\t\t\t\t\t// Validate the record\n\t\t\t\t\tconst validated = this.schema.validateRecord(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\trecord,\n\t\t\t\t\t\tphaseOverride ?? 'updateRecord',\n\t\t\t\t\t\tinitialValue\n\t\t\t\t\t)\n\n\t\t\t\t\tif (validated === initialValue) continue\n\n\t\t\t\t\trecordAtom.set(devFreeze(record))\n\n\t\t\t\t\tdidChange = true\n\t\t\t\t\tconst updated = recordAtom.__unsafe__getWithoutCapture()\n\t\t\t\t\tupdates[record.id] = [initialValue, updated]\n\t\t\t\t\tthis.addDiffForAfterEvent(initialValue, updated)\n\t\t\t\t} else {\n\t\t\t\t\trecord = this.sideEffects.handleBeforeCreate(record, source)\n\n\t\t\t\t\tdidChange = true\n\n\t\t\t\t\t// If we don't have an atom, create one.\n\n\t\t\t\t\t// Validate the record\n\t\t\t\t\trecord = this.schema.validateRecord(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\trecord as R,\n\t\t\t\t\t\tphaseOverride ?? 'createRecord',\n\t\t\t\t\t\tnull\n\t\t\t\t\t)\n\n\t\t\t\t\t// Mark the change as a new addition.\n\t\t\t\t\tadditions[record.id] = record\n\t\t\t\t\tthis.addDiffForAfterEvent(null, record)\n\n\t\t\t\t\t// Assign the atom to the map under the record's id.\n\t\t\t\t\tif (!map) {\n\t\t\t\t\t\tmap = { ...currentMap }\n\t\t\t\t\t}\n\t\t\t\t\tmap[record.id] = atom('atom:' + record.id, record)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the map of atoms to the store.\n\t\t\tif (map) {\n\t\t\t\tthis.atoms.set(map)\n\t\t\t}\n\n\t\t\t// If we did change, update the history\n\t\t\tif (!didChange) return\n\t\t\tthis.updateHistory({\n\t\t\t\tadded: additions,\n\t\t\t\tupdated: updates,\n\t\t\t\tremoved: {} as Record<IdOf<R>, R>,\n\t\t\t})\n\t\t})\n\t}\n\n\t/**\n\t * Remove some records from the store via their ids.\n\t *\n\t * @param ids - The ids of the records to remove.\n\t * @public\n\t */\n\tremove(ids: IdOf<R>[]): void {\n\t\tthis.atomic(() => {\n\t\t\tconst cancelled = new Set<IdOf<R>>()\n\t\t\tconst source = this.isMergingRemoteChanges ? 'remote' : 'user'\n\n\t\t\tif (this.sideEffects.isEnabled()) {\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tconst atom = this.atoms.__unsafe__getWithoutCapture()[id]\n\t\t\t\t\tif (!atom) continue\n\n\t\t\t\t\tif (this.sideEffects.handleBeforeDelete(atom.get(), source) === false) {\n\t\t\t\t\t\tcancelled.add(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet removed = undefined as undefined | RecordsDiff<R>['removed']\n\n\t\t\t// For each map in our atoms, remove the ids that we are removing.\n\t\t\tthis.atoms.update((atoms) => {\n\t\t\t\tlet result: typeof atoms | undefined = undefined\n\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tif (cancelled.has(id)) continue\n\t\t\t\t\tif (!(id in atoms)) continue\n\t\t\t\t\tif (!result) result = { ...atoms }\n\t\t\t\t\tif (!removed) removed = {} as Record<IdOf<R>, R>\n\t\t\t\t\tdelete result[id]\n\t\t\t\t\tconst record = atoms[id].get()\n\t\t\t\t\tremoved[id] = record\n\t\t\t\t\tthis.addDiffForAfterEvent(record, null)\n\t\t\t\t}\n\n\t\t\t\treturn result ?? atoms\n\t\t\t})\n\n\t\t\tif (!removed) return\n\t\t\t// Update the history with the removed records.\n\t\t\tthis.updateHistory({ added: {}, updated: {}, removed } as RecordsDiff<R>)\n\t\t})\n\t}\n\n\t/**\n\t * Get the value of a store record by its id.\n\t *\n\t * @param id - The id of the record to get.\n\t * @public\n\t */\n\tget<K extends IdOf<R>>(id: K): RecordFromId<K> | undefined {\n\t\treturn this.atoms.get()[id]?.get() as any\n\t}\n\n\t/**\n\t * Get the value of a store record by its id without updating its epoch.\n\t *\n\t * @param id - The id of the record to get.\n\t * @public\n\t */\n\tunsafeGetWithoutCapture<K extends IdOf<R>>(id: K): RecordFromId<K> | undefined {\n\t\treturn this.atoms.__unsafe__getWithoutCapture()[id]?.__unsafe__getWithoutCapture() as any\n\t}\n\n\t/**\n\t * Creates a JSON payload from the record store.\n\t *\n\t * @param scope - The scope of records to serialize. Defaults to 'document'.\n\t * @returns The record store snapshot as a JSON payload.\n\t */\n\tserialize(scope: RecordScope | 'all' = 'document'): SerializedStore<R> {\n\t\tconst result = {} as SerializedStore<R>\n\t\tfor (const [id, atom] of objectMapEntries(this.atoms.get())) {\n\t\t\tconst record = atom.get()\n\t\t\tif (scope === 'all' || this.scopedTypes[scope].has(record.typeName)) {\n\t\t\t\tresult[id as IdOf<R>] = record\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Get a serialized snapshot of the store and its schema.\n\t *\n\t * ```ts\n\t * const snapshot = store.getStoreSnapshot()\n\t * store.loadStoreSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param scope - The scope of records to serialize. Defaults to 'document'.\n\t *\n\t * @public\n\t */\n\tgetStoreSnapshot(scope: RecordScope | 'all' = 'document'): StoreSnapshot<R> {\n\t\treturn {\n\t\t\tstore: this.serialize(scope),\n\t\t\tschema: this.schema.serialize(),\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated use `getSnapshot` from the 'tldraw' package instead.\n\t */\n\tgetSnapshot(scope: RecordScope | 'all' = 'document') {\n\t\tconsole.warn(\n\t\t\t'[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead.'\n\t\t)\n\t\treturn this.getStoreSnapshot(scope)\n\t}\n\n\t/**\n\t * Migrate a serialized snapshot of the store and its schema.\n\t *\n\t * ```ts\n\t * const snapshot = store.getSnapshot()\n\t * store.migrateSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param snapshot - The snapshot to load.\n\t * @public\n\t */\n\tmigrateSnapshot(snapshot: StoreSnapshot<R>): StoreSnapshot<R> {\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot(snapshot)\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\tthrow new Error(`Failed to migrate snapshot: ${migrationResult.reason}`)\n\t\t}\n\n\t\treturn {\n\t\t\tstore: migrationResult.value,\n\t\t\tschema: this.schema.serialize(),\n\t\t}\n\t}\n\n\t/**\n\t * Load a serialized snapshot.\n\t *\n\t * ```ts\n\t * const snapshot = store.getStoreSnapshot()\n\t * store.loadStoreSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param snapshot - The snapshot to load.\n\t * @public\n\t */\n\tloadStoreSnapshot(snapshot: StoreSnapshot<R>): void {\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot(snapshot)\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\tthrow new Error(`Failed to migrate snapshot: ${migrationResult.reason}`)\n\t\t}\n\n\t\tconst prevSideEffectsEnabled = this.sideEffects.isEnabled()\n\t\ttry {\n\t\t\tthis.sideEffects.setIsEnabled(false)\n\t\t\tthis.atomic(() => {\n\t\t\t\tthis.clear()\n\t\t\t\tthis.put(Object.values(migrationResult.value))\n\t\t\t\tthis.ensureStoreIsUsable()\n\t\t\t})\n\t\t} finally {\n\t\t\tthis.sideEffects.setIsEnabled(prevSideEffectsEnabled)\n\t\t}\n\t}\n\n\t/**\n\t * @public\n\t * @deprecated use `loadSnapshot` from the 'tldraw' package instead.\n\t */\n\tloadSnapshot(snapshot: StoreSnapshot<R>) {\n\t\tconsole.warn(\n\t\t\t\"[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead.\"\n\t\t)\n\t\tthis.loadStoreSnapshot(snapshot)\n\t}\n\n\t/**\n\t * Get an array of all values in the store.\n\t *\n\t * @returns An array of all values in the store.\n\t * @public\n\t */\n\tallRecords(): R[] {\n\t\treturn objectMapValues(this.atoms.get()).map((atom) => atom.get())\n\t}\n\n\t/**\n\t * Removes all records from the store.\n\t *\n\t * @public\n\t */\n\tclear(): void {\n\t\tthis.remove(objectMapKeys(this.atoms.get()))\n\t}\n\n\t/**\n\t * Update a record. To update multiple records at once, use the `update` method of the\n\t * `TypedStore` class.\n\t *\n\t * @param id - The id of the record to update.\n\t * @param updater - A function that updates the record.\n\t */\n\tupdate<K extends IdOf<R>>(id: K, updater: (record: RecordFromId<K>) => RecordFromId<K>) {\n\t\tconst atom = this.atoms.get()[id]\n\t\tif (!atom) {\n\t\t\tconsole.error(`Record ${id} not found. This is probably an error`)\n\t\t\treturn\n\t\t}\n\n\t\tthis.put([updater(atom.__unsafe__getWithoutCapture() as any as RecordFromId<K>) as any])\n\t}\n\n\t/**\n\t * Get whether the record store has a id.\n\t *\n\t * @param id - The id of the record to check.\n\t * @public\n\t */\n\thas<K extends IdOf<R>>(id: K): boolean {\n\t\treturn !!this.atoms.get()[id]\n\t}\n\n\t/**\n\t * Add a new listener to the store.\n\t *\n\t * @param onHistory - The listener to call when the store updates.\n\t * @param filters - Filters to apply to the listener.\n\t * @returns A function to remove the listener.\n\t */\n\tlisten(onHistory: StoreListener<R>, filters?: Partial<StoreListenerFilters>) {\n\t\t// flush history so that this listener's history starts from exactly now\n\t\tthis._flushHistory()\n\n\t\tconst listener = {\n\t\t\tonHistory,\n\t\t\tfilters: {\n\t\t\t\tsource: filters?.source ?? 'all',\n\t\t\t\tscope: filters?.scope ?? 'all',\n\t\t\t},\n\t\t}\n\n\t\tthis.listeners.add(listener)\n\n\t\tif (!this.historyReactor.scheduler.isActivelyListening) {\n\t\t\tthis.historyReactor.start()\n\t\t}\n\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener)\n\n\t\t\tif (this.listeners.size === 0) {\n\t\t\t\tthis.historyReactor.stop()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isMergingRemoteChanges = false\n\n\t/**\n\t * Merge changes from a remote source without triggering listeners.\n\t *\n\t * @param fn - A function that merges the external changes.\n\t * @public\n\t */\n\tmergeRemoteChanges(fn: () => void) {\n\t\tif (this.isMergingRemoteChanges) {\n\t\t\treturn fn()\n\t\t}\n\n\t\tif (this._isInAtomicOp) {\n\t\t\tthrow new Error('Cannot merge remote changes while in atomic operation')\n\t\t}\n\n\t\ttry {\n\t\t\tthis.isMergingRemoteChanges = true\n\t\t\ttransact(fn)\n\t\t} finally {\n\t\t\tthis.isMergingRemoteChanges = false\n\t\t}\n\t}\n\n\t/**\n\t * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.\n\t */\n\textractingChanges(fn: () => void): RecordsDiff<R> {\n\t\tconst changes: Array<RecordsDiff<R>> = []\n\t\tconst dispose = this.historyAccumulator.addInterceptor((entry) => changes.push(entry.changes))\n\t\ttry {\n\t\t\ttransact(fn)\n\t\t\treturn squashRecordDiffs(changes)\n\t\t} finally {\n\t\t\tdispose()\n\t\t}\n\t}\n\n\tapplyDiff(\n\t\tdiff: RecordsDiff<R>,\n\t\t{\n\t\t\trunCallbacks = true,\n\t\t\tignoreEphemeralKeys = false,\n\t\t}: { runCallbacks?: boolean; ignoreEphemeralKeys?: boolean } = {}\n\t) {\n\t\tthis.atomic(() => {\n\t\t\tconst toPut = objectMapValues(diff.added)\n\n\t\t\tfor (const [_from, to] of objectMapValues(diff.updated)) {\n\t\t\t\tconst type = this.schema.getType(to.typeName)\n\t\t\t\tif (ignoreEphemeralKeys && type.ephemeralKeySet.size) {\n\t\t\t\t\tconst existing = this.get(to.id)\n\t\t\t\t\tif (!existing) {\n\t\t\t\t\t\ttoPut.push(to)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tlet changed: R | null = null\n\t\t\t\t\tfor (const [key, value] of Object.entries(to)) {\n\t\t\t\t\t\tif (type.ephemeralKeySet.has(key) || Object.is(value, getOwnProperty(existing, key))) {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!changed) changed = { ...existing } as R\n\t\t\t\t\t\t;(changed as any)[key] = value\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) toPut.push(changed)\n\t\t\t\t} else {\n\t\t\t\t\ttoPut.push(to)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst toRemove = objectMapKeys(diff.removed)\n\t\t\tif (toPut.length) {\n\t\t\t\tthis.put(toPut)\n\t\t\t}\n\t\t\tif (toRemove.length) {\n\t\t\t\tthis.remove(toRemove)\n\t\t\t}\n\t\t}, runCallbacks)\n\t}\n\n\t/**\n\t * Create a computed cache.\n\t *\n\t * @param name - The name of the derivation cache.\n\t * @param derive - A function used to derive the value of the cache.\n\t * @param isEqual - A function that determins equality between two records.\n\t * @public\n\t */\n\tcreateComputedCache<Result, Record extends R = R>(\n\t\tname: string,\n\t\tderive: (record: Record) => Result | undefined,\n\t\tisEqual?: (a: Record, b: Record) => boolean\n\t): ComputedCache<Result, Record> {\n\t\tconst cache = new WeakCache<Atom<any>, Computed<Result | undefined>>()\n\t\treturn {\n\t\t\tget: (id: IdOf<Record>) => {\n\t\t\t\tconst atom = this.atoms.get()[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\treturn undefined\n\t\t\t\t}\n\t\t\t\treturn cache\n\t\t\t\t\t.get(atom, () => {\n\t\t\t\t\t\tconst recordSignal = isEqual\n\t\t\t\t\t\t\t? computed(atom.name + ':equals', () => atom.get(), { isEqual })\n\t\t\t\t\t\t\t: atom\n\t\t\t\t\t\treturn computed<Result | undefined>(name + ':' + id, () => {\n\t\t\t\t\t\t\treturn derive(recordSignal.get() as Record)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.get()\n\t\t\t},\n\t\t}\n\t}\n\n\t/**\n\t * Create a computed cache from a selector\n\t *\n\t * @param name - The name of the derivation cache.\n\t * @param selector - A function that returns a subset of the original shape\n\t * @param derive - A function used to derive the value of the cache.\n\t * @public\n\t */\n\tcreateSelectedComputedCache<Selection, Result, Record extends R = R>(\n\t\tname: string,\n\t\tselector: (record: Record) => Selection | undefined,\n\t\tderive: (input: Selection) => Result | undefined\n\t): ComputedCache<Result, Record> {\n\t\tconst cache = new WeakCache<Atom<any>, Computed<Result | undefined>>()\n\t\treturn {\n\t\t\tget: (id: IdOf<Record>) => {\n\t\t\t\tconst atom = this.atoms.get()[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\treturn undefined\n\t\t\t\t}\n\n\t\t\t\treturn cache\n\t\t\t\t\t.get(atom, () => {\n\t\t\t\t\t\tconst d = computed<Selection | undefined>(name + ':' + id + ':selector', () =>\n\t\t\t\t\t\t\tselector(atom.get() as Record)\n\t\t\t\t\t\t)\n\t\t\t\t\t\treturn computed<Result | undefined>(name + ':' + id, () => derive(d.get() as Selection))\n\t\t\t\t\t})\n\t\t\t\t\t.get()\n\t\t\t},\n\t\t}\n\t}\n\n\tprivate _integrityChecker?: () => void | undefined\n\n\t/** @internal */\n\tensureStoreIsUsable() {\n\t\tthis.atomic(() => {\n\t\t\tthis._integrityChecker ??= this.schema.createIntegrityChecker(this)\n\t\t\tthis._integrityChecker?.()\n\t\t})\n\t}\n\n\tprivate _isPossiblyCorrupted = false\n\t/** @internal */\n\tmarkAsPossiblyCorrupted() {\n\t\tthis._isPossiblyCorrupted = true\n\t}\n\t/** @internal */\n\tisPossiblyCorrupted() {\n\t\treturn this._isPossiblyCorrupted\n\t}\n\n\tprivate pendingAfterEvents: Map<IdOf<R>, { before: R | null; after: R | null }> | null = null\n\tprivate addDiffForAfterEvent(before: R | null, after: R | null) {\n\t\tassert(this.pendingAfterEvents, 'must be in event operation')\n\t\tif (before === after) return\n\t\tif (before && after) assert(before.id === after.id)\n\t\tif (!before && !after) return\n\t\tconst id = (before || after)!.id\n\t\tconst existing = this.pendingAfterEvents.get(id)\n\t\tif (existing) {\n\t\t\texisting.after = after\n\t\t} else {\n\t\t\tthis.pendingAfterEvents.set(id, { before, after })\n\t\t}\n\t}\n\tprivate flushAtomicCallbacks() {\n\t\tlet updateDepth = 0\n\t\tconst source = this.isMergingRemoteChanges ? 'remote' : 'user'\n\t\twhile (this.pendingAfterEvents) {\n\t\t\tconst events = this.pendingAfterEvents\n\t\t\tthis.pendingAfterEvents = null\n\n\t\t\tif (!this.sideEffects.isEnabled()) continue\n\n\t\t\tupdateDepth++\n\t\t\tif (updateDepth > 100) {\n\t\t\t\tthrow new Error('Maximum store update depth exceeded, bailing out')\n\t\t\t}\n\n\t\t\tfor (const { before, after } of events.values()) {\n\t\t\t\tif (before && after) {\n\t\t\t\t\tthis.sideEffects.handleAfterChange(before, after, source)\n\t\t\t\t} else if (before && !after) {\n\t\t\t\t\tthis.sideEffects.handleAfterDelete(before, source)\n\t\t\t\t} else if (!before && after) {\n\t\t\t\t\tthis.sideEffects.handleAfterCreate(after, source)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.pendingAfterEvents) {\n\t\t\t\tthis.sideEffects.handleOperationComplete(source)\n\t\t\t}\n\t\t}\n\t}\n\tprivate _isInAtomicOp = false\n\t/** @internal */\n\tatomic<T>(fn: () => T, runCallbacks = true): T {\n\t\treturn transact(() => {\n\t\t\tif (this._isInAtomicOp) {\n\t\t\t\tif (!this.pendingAfterEvents) this.pendingAfterEvents = new Map()\n\t\t\t\treturn fn()\n\t\t\t}\n\n\t\t\tthis.pendingAfterEvents = new Map()\n\t\t\tconst prevSideEffectsEnabled = this.sideEffects.isEnabled()\n\t\t\tthis.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled)\n\t\t\tthis._isInAtomicOp = true\n\t\t\ttry {\n\t\t\t\tconst result = fn()\n\n\t\t\t\tthis.flushAtomicCallbacks()\n\n\t\t\t\treturn result\n\t\t\t} finally {\n\t\t\t\tthis.pendingAfterEvents = null\n\t\t\t\tthis.sideEffects.setIsEnabled(prevSideEffectsEnabled)\n\t\t\t\tthis._isInAtomicOp = false\n\t\t\t}\n\t\t})\n\t}\n\n\t/** @internal */\n\taddHistoryInterceptor(fn: (entry: HistoryEntry<R>, source: ChangeSource) => void) {\n\t\treturn this.historyAccumulator.addInterceptor((entry) =>\n\t\t\tfn(entry, this.isMergingRemoteChanges ? 'remote' : 'user')\n\t\t)\n\t}\n}\n\n/**\n * Collect all history entries by their adjacent sources.\n * For example, [user, user, remote, remote, user] would result in [user, remote, user],\n * with adjacent entries of the same source squashed into a single entry.\n *\n * @param entries - The array of history entries.\n * @returns A map of history entries by their sources.\n * @public\n */\nfunction squashHistoryEntries<T extends UnknownRecord>(\n\tentries: HistoryEntry<T>[]\n): HistoryEntry<T>[] {\n\tif (entries.length === 0) return []\n\n\tconst chunked: HistoryEntry<T>[][] = []\n\tlet chunk: HistoryEntry<T>[] = [entries[0]]\n\tlet entry: HistoryEntry<T>\n\n\tfor (let i = 1, n = entries.length; i < n; i++) {\n\t\tentry = entries[i]\n\t\tif (chunk[0].source !== entry.source) {\n\t\t\tchunked.push(chunk)\n\t\t\tchunk = []\n\t\t}\n\t\tchunk.push(entry)\n\t}\n\t// Push the last chunk\n\tchunked.push(chunk)\n\n\treturn devFreeze(\n\t\tchunked.map((chunk) => ({\n\t\t\tsource: chunk[0].source,\n\t\t\tchanges: squashRecordDiffs(chunk.map((e) => e.changes)),\n\t\t}))\n\t)\n}\n\nclass HistoryAccumulator<T extends UnknownRecord> {\n\tprivate _history: HistoryEntry<T>[] = []\n\n\tprivate _interceptors: Set<(entry: HistoryEntry<T>) => void> = new Set()\n\n\taddInterceptor(fn: (entry: HistoryEntry<T>) => void) {\n\t\tthis._interceptors.add(fn)\n\t\treturn () => {\n\t\t\tthis._interceptors.delete(fn)\n\t\t}\n\t}\n\n\tadd(entry: HistoryEntry<T>) {\n\t\tthis._history.push(entry)\n\t\tfor (const interceptor of this._interceptors) {\n\t\t\tinterceptor(entry)\n\t\t}\n\t}\n\n\tflush() {\n\t\tconst history = squashHistoryEntries(this._history)\n\t\tthis._history = []\n\t\treturn history\n\t}\n\n\tclear() {\n\t\tthis._history = []\n\t}\n\n\thasChanges() {\n\t\treturn this._history.length > 0\n\t}\n}\n\n/** @public */\nexport type StoreObject<R extends UnknownRecord> = Store<R> | { store: Store<R> }\n/** @public */\nexport type StoreObjectRecordType<Context extends StoreObject<any>> =\n\tContext extends Store<infer R> ? R : Context extends { store: Store<infer R> } ? R : never\n\n/**\n * Free version of {@link Store.createComputedCache}.\n *\n * @example\n * ```ts\n * const myCache = createComputedCache('myCache', (editor: Editor, shape: TLShape) => {\n *     return editor.getSomethingExpensive(shape)\n * })\n *\n * myCache.get(editor, shape.id)\n * ```\n *\n * @public\n */\nexport function createComputedCache<\n\tContext extends StoreObject<any>,\n\tResult,\n\tRecord extends StoreObjectRecordType<Context> = StoreObjectRecordType<Context>,\n>(\n\tname: string,\n\tderive: (context: Context, record: Record) => Result | undefined,\n\tisEqual?: (a: Record, b: Record) => boolean\n) {\n\tconst cache = new WeakCache<Context, ComputedCache<Result, Record>>()\n\treturn {\n\t\tget(context: Context, id: IdOf<Record>) {\n\t\t\tconst computedCache = cache.get(context, () => {\n\t\t\t\tconst store = (context instanceof Store ? context : context.store) as Store<Record>\n\t\t\t\treturn store.createComputedCache(name, (record) => derive(context, record), isEqual)\n\t\t\t})\n\t\t\treturn computedCache.get(id)\n\t\t},\n\t}\n}\n", "import {\n\tAtom,\n\tcomputed,\n\tComputed,\n\tEMPTY_ARRAY,\n\tisUninitialized,\n\tRESET_VALUE,\n\twithDiff,\n} from '@tldraw/state'\nimport { objectMapValues } from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\nimport { IdOf, UnknownRecord } from './BaseRecord'\nimport { executeQuery, objectMatchesQuery, QueryExpression } from './executeQuery'\nimport { IncrementalSetConstructor } from './IncrementalSetConstructor'\nimport { RecordsDiff } from './RecordsDiff'\nimport { diffSets } from './setUtils'\nimport { CollectionDiff } from './Store'\n\n/** @public */\nexport type RSIndexDiff<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R,\n> = Map<R[Property], CollectionDiff<IdOf<R>>>\n\n/** @public */\nexport type RSIndexMap<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R,\n> = Map<R[Property], Set<IdOf<R>>>\n\n/** @public */\nexport type RSIndex<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R,\n> = Computed<RSIndexMap<R, Property>, RSIndexDiff<R, Property>>\n\n/**\n * A class that provides a 'namespace' for the various kinds of indexes one may wish to derive from\n * the record store.\n * @public\n */\nexport class StoreQueries<R extends UnknownRecord> {\n\tconstructor(\n\t\tprivate readonly atoms: Atom<Record<IdOf<R>, Atom<R>>>,\n\t\tprivate readonly history: Atom<number, RecordsDiff<R>>\n\t) {}\n\n\t/**\n\t * A cache of derivations (indexes).\n\t *\n\t * @internal\n\t */\n\tprivate indexCache = new Map<string, RSIndex<R>>()\n\n\t/**\n\t * A cache of derivations (filtered histories).\n\t *\n\t * @internal\n\t */\n\tprivate historyCache = new Map<string, Computed<number, RecordsDiff<R>>>()\n\n\t/**\n\t * Create a derivation that contains the history for a given type\n\t *\n\t * @param typeName - The name of the type to filter by.\n\t * @returns A derivation that returns the ids of all records of the given type.\n\t * @public\n\t */\n\tpublic filterHistory<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName\n\t): Computed<number, RecordsDiff<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tif (this.historyCache.has(typeName)) {\n\t\t\treturn this.historyCache.get(typeName) as any\n\t\t}\n\n\t\tconst filtered = computed<number, RecordsDiff<S>>(\n\t\t\t'filterHistory:' + typeName,\n\t\t\t(lastValue, lastComputedEpoch) => {\n\t\t\t\tif (isUninitialized(lastValue)) {\n\t\t\t\t\treturn this.history.get()\n\t\t\t\t}\n\n\t\t\t\tconst diff = this.history.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (diff === RESET_VALUE) return this.history.get()\n\n\t\t\t\tconst res = { added: {}, removed: {}, updated: {} } as RecordsDiff<S>\n\t\t\t\tlet numAdded = 0\n\t\t\t\tlet numRemoved = 0\n\t\t\t\tlet numUpdated = 0\n\n\t\t\t\tfor (const changes of diff) {\n\t\t\t\t\tfor (const added of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (added.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.removed[added.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tconst original = res.removed[added.id as IdOf<S>]\n\t\t\t\t\t\t\t\tdelete res.removed[added.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumRemoved--\n\t\t\t\t\t\t\t\tif (original !== added) {\n\t\t\t\t\t\t\t\t\tres.updated[added.id as IdOf<S>] = [original, added as S]\n\t\t\t\t\t\t\t\t\tnumUpdated++\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.added[added.id as IdOf<S>] = added as S\n\t\t\t\t\t\t\t\tnumAdded++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const [from, to] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (to.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.added[to.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tres.added[to.id as IdOf<S>] = to as S\n\t\t\t\t\t\t\t} else if (res.updated[to.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tres.updated[to.id as IdOf<S>] = [res.updated[to.id as IdOf<S>][0], to as S]\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.updated[to.id as IdOf<S>] = [from as S, to as S]\n\t\t\t\t\t\t\t\tnumUpdated++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const removed of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (removed.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.added[removed.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\t// was added during this diff sequence, so just undo the add\n\t\t\t\t\t\t\t\tdelete res.added[removed.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumAdded--\n\t\t\t\t\t\t\t} else if (res.updated[removed.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\t// remove oldest version\n\t\t\t\t\t\t\t\tres.removed[removed.id as IdOf<S>] = res.updated[removed.id as IdOf<S>][0]\n\t\t\t\t\t\t\t\tdelete res.updated[removed.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumUpdated--\n\t\t\t\t\t\t\t\tnumRemoved++\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.removed[removed.id as IdOf<S>] = removed as S\n\t\t\t\t\t\t\t\tnumRemoved++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (numAdded || numRemoved || numUpdated) {\n\t\t\t\t\treturn withDiff(this.history.get(), res)\n\t\t\t\t} else {\n\t\t\t\t\treturn lastValue\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ historyLength: 100 }\n\t\t)\n\n\t\tthis.historyCache.set(typeName, filtered)\n\n\t\treturn filtered\n\t}\n\n\t/**\n\t * Create a derivation that returns an index on a property for the given type.\n\t *\n\t * @param typeName - The name of the type.\n\t * @param property - The name of the property.\n\t * @public\n\t */\n\tpublic index<\n\t\tTypeName extends R['typeName'],\n\t\tProperty extends string & keyof Extract<R, { typeName: TypeName }>,\n\t>(typeName: TypeName, property: Property): RSIndex<Extract<R, { typeName: TypeName }>, Property> {\n\t\tconst cacheKey = typeName + ':' + property\n\n\t\tif (this.indexCache.has(cacheKey)) {\n\t\t\treturn this.indexCache.get(cacheKey) as any\n\t\t}\n\n\t\tconst index = this.__uncached_createIndex(typeName, property)\n\n\t\tthis.indexCache.set(cacheKey, index as any)\n\n\t\treturn index\n\t}\n\n\t/**\n\t * Create a derivation that returns an index on a property for the given type.\n\t *\n\t * @param typeName - The name of the type?.\n\t * @param property - The name of the property?.\n\t * @internal\n\t */\n\t__uncached_createIndex<\n\t\tTypeName extends R['typeName'],\n\t\tProperty extends string & keyof Extract<R, { typeName: TypeName }>,\n\t>(typeName: TypeName, property: Property): RSIndex<Extract<R, { typeName: TypeName }>, Property> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tconst typeHistory = this.filterHistory(typeName)\n\n\t\tconst fromScratch = () => {\n\t\t\t// deref typeHistory early so that the first time the incremental version runs\n\t\t\t// it gets a diff to work with instead of having to bail to this from-scratch version\n\t\t\ttypeHistory.get()\n\t\t\tconst res = new Map<S[Property], Set<IdOf<S>>>()\n\t\t\tfor (const atom of objectMapValues(this.atoms.get())) {\n\t\t\t\tconst record = atom.get()\n\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\tif (!res.has(value)) {\n\t\t\t\t\t\tres.set(value, new Set())\n\t\t\t\t\t}\n\t\t\t\t\tres.get(value)!.add(record.id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res\n\t\t}\n\n\t\treturn computed<RSIndexMap<S, Property>, RSIndexDiff<S, Property>>(\n\t\t\t'index:' + typeName + ':' + property,\n\t\t\t(prevValue, lastComputedEpoch) => {\n\t\t\t\tif (isUninitialized(prevValue)) return fromScratch()\n\n\t\t\t\tconst history = typeHistory.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (history === RESET_VALUE) {\n\t\t\t\t\treturn fromScratch()\n\t\t\t\t}\n\n\t\t\t\tconst setConstructors = new Map<any, IncrementalSetConstructor<IdOf<S>>>()\n\n\t\t\t\tconst add = (value: S[Property], id: IdOf<S>) => {\n\t\t\t\t\tlet setConstructor = setConstructors.get(value)\n\t\t\t\t\tif (!setConstructor)\n\t\t\t\t\t\tsetConstructor = new IncrementalSetConstructor<IdOf<S>>(\n\t\t\t\t\t\t\tprevValue.get(value) ?? new Set()\n\t\t\t\t\t\t)\n\t\t\t\t\tsetConstructor.add(id)\n\t\t\t\t\tsetConstructors.set(value, setConstructor)\n\t\t\t\t}\n\n\t\t\t\tconst remove = (value: S[Property], id: IdOf<S>) => {\n\t\t\t\t\tlet set = setConstructors.get(value)\n\t\t\t\t\tif (!set) set = new IncrementalSetConstructor<IdOf<S>>(prevValue.get(value) ?? new Set())\n\t\t\t\t\tset.remove(id)\n\t\t\t\t\tsetConstructors.set(value, set)\n\t\t\t\t}\n\n\t\t\t\tfor (const changes of history) {\n\t\t\t\t\tfor (const record of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\t\t\tadd(value, record.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [from, to] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (to.typeName === typeName) {\n\t\t\t\t\t\t\tconst prev = (from as S)[property]\n\t\t\t\t\t\t\tconst next = (to as S)[property]\n\t\t\t\t\t\t\tif (prev !== next) {\n\t\t\t\t\t\t\t\tremove(prev, to.id)\n\t\t\t\t\t\t\t\tadd(next, to.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const record of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\t\t\tremove(value, record.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet nextValue: undefined | RSIndexMap<S, Property> = undefined\n\t\t\t\tlet nextDiff: undefined | RSIndexDiff<S, Property> = undefined\n\n\t\t\t\tfor (const [value, setConstructor] of setConstructors) {\n\t\t\t\t\tconst result = setConstructor.get()\n\t\t\t\t\tif (!result) continue\n\t\t\t\t\tif (!nextValue) nextValue = new Map(prevValue)\n\t\t\t\t\tif (!nextDiff) nextDiff = new Map()\n\t\t\t\t\tif (result.value.size === 0) {\n\t\t\t\t\t\tnextValue.delete(value)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextValue.set(value, result.value)\n\t\t\t\t\t}\n\t\t\t\t\tnextDiff.set(value, result.diff)\n\t\t\t\t}\n\n\t\t\t\tif (nextValue && nextDiff) {\n\t\t\t\t\treturn withDiff(nextValue, nextDiff)\n\t\t\t\t}\n\n\t\t\t\treturn prevValue\n\t\t\t},\n\t\t\t{ historyLength: 100 }\n\t\t)\n\t}\n\n\t/**\n\t * Create a derivation that will return a signle record matching the given query.\n\t *\n\t * It will return undefined if there is no matching record\n\t *\n\t * @param typeName - The name of the type?\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\trecord<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'record:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<Extract<R, { typeName: TypeName }> | undefined> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = this.ids(typeName, queryCreator, name)\n\n\t\treturn computed<S | undefined>(name, () => {\n\t\t\tfor (const id of ids.get()) {\n\t\t\t\treturn this.atoms.get()[id]?.get() as S\n\t\t\t}\n\t\t\treturn undefined\n\t\t})\n\t}\n\n\t/**\n\t * Create a derivation that will return an array of records matching the given query\n\t *\n\t * @param typeName - The name of the type?\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\trecords<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'records:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<Array<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = this.ids(typeName, queryCreator, 'ids:' + name)\n\n\t\treturn computed<S[]>(name, () => {\n\t\t\treturn [...ids.get()].map((id) => {\n\t\t\t\tconst atom = this.atoms.get()[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\tthrow new Error('no atom found for record id: ' + id)\n\t\t\t\t}\n\t\t\t\treturn atom.get() as S\n\t\t\t})\n\t\t})\n\t}\n\n\t/**\n\t * Create a derivation that will return the ids of all records of the given type.\n\t *\n\t * @param typeName - The name of the type.\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\tids<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'ids:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<\n\t\tSet<IdOf<Extract<R, { typeName: TypeName }>>>,\n\t\tCollectionDiff<IdOf<Extract<R, { typeName: TypeName }>>>\n\t> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tconst typeHistory = this.filterHistory(typeName)\n\n\t\tconst fromScratch = () => {\n\t\t\t// deref type history early to allow first incremental update to use diffs\n\t\t\ttypeHistory.get()\n\t\t\tconst query: QueryExpression<S> = queryCreator()\n\t\t\tif (Object.keys(query).length === 0) {\n\t\t\t\treturn new Set<IdOf<S>>(\n\t\t\t\t\tobjectMapValues(this.atoms.get()).flatMap((v) => {\n\t\t\t\t\t\tconst r = v.get()\n\t\t\t\t\t\tif (r.typeName === typeName) {\n\t\t\t\t\t\t\treturn r.id\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn []\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn executeQuery(this, typeName, query)\n\t\t}\n\n\t\tconst fromScratchWithDiff = (prevValue: Set<IdOf<S>>) => {\n\t\t\tconst nextValue = fromScratch()\n\t\t\tconst diff = diffSets(prevValue, nextValue)\n\t\t\tif (diff) {\n\t\t\t\treturn withDiff(nextValue, diff)\n\t\t\t} else {\n\t\t\t\treturn prevValue\n\t\t\t}\n\t\t}\n\t\tconst cachedQuery = computed('ids_query:' + name, queryCreator, {\n\t\t\tisEqual,\n\t\t})\n\n\t\treturn computed(\n\t\t\t'query:' + name,\n\t\t\t(prevValue, lastComputedEpoch) => {\n\t\t\t\tconst query = cachedQuery.get()\n\t\t\t\tif (isUninitialized(prevValue)) {\n\t\t\t\t\treturn fromScratch()\n\t\t\t\t}\n\n\t\t\t\t// if the query changed since last time this ran then we need to start again\n\t\t\t\tif (lastComputedEpoch < cachedQuery.lastChangedEpoch) {\n\t\t\t\t\treturn fromScratchWithDiff(prevValue)\n\t\t\t\t}\n\n\t\t\t\t// otherwise iterate over the changes from the store and apply them to the previous value if needed\n\t\t\t\tconst history = typeHistory.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (history === RESET_VALUE) {\n\t\t\t\t\treturn fromScratchWithDiff(prevValue)\n\t\t\t\t}\n\n\t\t\t\tconst setConstructor = new IncrementalSetConstructor<IdOf<S>>(\n\t\t\t\t\tprevValue\n\t\t\t\t) as IncrementalSetConstructor<IdOf<S>>\n\n\t\t\t\tfor (const changes of history) {\n\t\t\t\t\tfor (const added of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (added.typeName === typeName && objectMatchesQuery(query, added)) {\n\t\t\t\t\t\t\tsetConstructor.add(added.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [_, updated] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (updated.typeName === typeName) {\n\t\t\t\t\t\t\tif (objectMatchesQuery(query, updated)) {\n\t\t\t\t\t\t\t\tsetConstructor.add(updated.id)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetConstructor.remove(updated.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const removed of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (removed.typeName === typeName) {\n\t\t\t\t\t\t\tsetConstructor.remove(removed.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst result = setConstructor.get()\n\t\t\t\tif (!result) {\n\t\t\t\t\treturn prevValue\n\t\t\t\t}\n\n\t\t\t\treturn withDiff(result.value, result.diff)\n\t\t\t},\n\t\t\t{ historyLength: 50 }\n\t\t)\n\t}\n\n\texec<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tquery: QueryExpression<Extract<R, { typeName: TypeName }>>\n\t): Array<Extract<R, { typeName: TypeName }>> {\n\t\tconst ids = executeQuery(this, typeName, query)\n\t\tif (ids.size === 0) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\t\tconst atoms = this.atoms.get()\n\t\treturn [...ids].map((id) => atoms[id].get() as Extract<R, { typeName: TypeName }>)\n\t}\n}\n", "import { IdOf, UnknownRecord } from './BaseRecord'\nimport { intersectSets } from './setUtils'\nimport { StoreQueries } from './StoreQueries'\n\n/** @public */\nexport type QueryValueMatcher<T> = { eq: T } | { neq: T } | { gt: number }\n\n/** @public */\nexport type QueryExpression<R extends object> = {\n\t[k in keyof R & string]?: QueryValueMatcher<R[k]>\n\t// todo: handle nesting\n\t// | (R[k] extends object ? { match: QueryExpression<R[k]> } : never)\n}\n\nexport function objectMatchesQuery<T extends object>(query: QueryExpression<T>, object: T) {\n\tfor (const [key, _matcher] of Object.entries(query)) {\n\t\tconst matcher = _matcher as QueryValueMatcher<T>\n\t\tconst value = object[key as keyof T]\n\t\t// if you add matching logic here, make sure you also update executeQuery,\n\t\t// where initial data is pulled out of the indexes, since that requires different\n\t\t// matching logic\n\t\tif ('eq' in matcher && value !== matcher.eq) return false\n\t\tif ('neq' in matcher && value === matcher.neq) return false\n\t\tif ('gt' in matcher && (typeof value !== 'number' || value <= matcher.gt)) return false\n\t}\n\treturn true\n}\n\nexport function executeQuery<R extends UnknownRecord, TypeName extends R['typeName']>(\n\tstore: StoreQueries<R>,\n\ttypeName: TypeName,\n\tquery: QueryExpression<Extract<R, { typeName: TypeName }>>\n): Set<IdOf<Extract<R, { typeName: TypeName }>>> {\n\tconst matchIds = Object.fromEntries(Object.keys(query).map((key) => [key, new Set()]))\n\n\tfor (const [k, matcher] of Object.entries(query)) {\n\t\tif ('eq' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tconst ids = index.get().get(matcher.eq)\n\t\t\tif (ids) {\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('neq' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tfor (const [value, ids] of index.get()) {\n\t\t\t\tif (value !== matcher.neq) {\n\t\t\t\t\tfor (const id of ids) {\n\t\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('gt' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tfor (const [value, ids] of index.get()) {\n\t\t\t\tif (value > matcher.gt) {\n\t\t\t\t\tfor (const id of ids) {\n\t\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn intersectSets(Object.values(matchIds)) as Set<IdOf<Extract<R, { typeName: TypeName }>>>\n}\n", "import { CollectionDiff } from './Store'\n\n/**\n * Combine multiple sets into a single set containing only the common elements of all sets.\n *\n * @param sets - The sets to combine.\n */\nexport function intersectSets<T>(sets: Set<T>[]) {\n\tif (sets.length === 0) return new Set<T>()\n\tconst first = sets[0]\n\tconst rest = sets.slice(1)\n\tconst result = new Set<T>()\n\n\tfor (const val of first) {\n\t\tif (rest.every((set) => set.has(val))) {\n\t\t\tresult.add(val)\n\t\t}\n\t}\n\n\treturn result\n}\n\n/**\n * Calculates a diff between two sets.\n *\n * @param prev - The previous set\n * @param next - The next set\n */\nexport function diffSets<T>(prev: Set<T>, next: Set<T>): CollectionDiff<T> | undefined {\n\tconst result: CollectionDiff<T> = {}\n\n\tfor (const val of next) {\n\t\tif (!prev.has(val)) {\n\t\t\tresult.added ??= new Set()\n\t\t\tresult.added.add(val)\n\t\t}\n\t}\n\n\tfor (const val of prev) {\n\t\tif (!next.has(val)) {\n\t\t\tresult.removed ??= new Set()\n\t\t\tresult.removed.add(val)\n\t\t}\n\t}\n\n\treturn result.added || result.removed ? result : undefined\n}\n", "import { UnknownRecord } from './BaseRecord'\nimport { Store } from './Store'\n\n/** @public */\nexport type StoreBeforeCreateHandler<R extends UnknownRecord> = (\n\trecord: R,\n\tsource: 'remote' | 'user'\n) => R\n/** @public */\nexport type StoreAfterCreateHandler<R extends UnknownRecord> = (\n\trecord: R,\n\tsource: 'remote' | 'user'\n) => void\n/** @public */\nexport type StoreBeforeChangeHandler<R extends UnknownRecord> = (\n\tprev: R,\n\tnext: R,\n\tsource: 'remote' | 'user'\n) => R\n/** @public */\nexport type StoreAfterChangeHandler<R extends UnknownRecord> = (\n\tprev: R,\n\tnext: R,\n\tsource: 'remote' | 'user'\n) => void\n/** @public */\nexport type StoreBeforeDeleteHandler<R extends UnknownRecord> = (\n\trecord: R,\n\tsource: 'remote' | 'user'\n) => void | false\n/** @public */\nexport type StoreAfterDeleteHandler<R extends UnknownRecord> = (\n\trecord: R,\n\tsource: 'remote' | 'user'\n) => void\n\n/** @public */\nexport type StoreOperationCompleteHandler = (source: 'remote' | 'user') => void\n\n/**\n * The side effect manager (aka a \"correct state enforcer\") is responsible\n * for making sure that the editor's state is always correct. This includes\n * things like: deleting a shape if its parent is deleted; unbinding\n * arrows when their binding target is deleted; etc.\n *\n * @public\n */\nexport class StoreSideEffects<R extends UnknownRecord> {\n\tconstructor(private readonly store: Store<R>) {}\n\n\tprivate _beforeCreateHandlers: { [K in string]?: StoreBeforeCreateHandler<any>[] } = {}\n\tprivate _afterCreateHandlers: { [K in string]?: StoreAfterCreateHandler<any>[] } = {}\n\tprivate _beforeChangeHandlers: { [K in string]?: StoreBeforeChangeHandler<any>[] } = {}\n\tprivate _afterChangeHandlers: { [K in string]?: StoreAfterChangeHandler<any>[] } = {}\n\tprivate _beforeDeleteHandlers: { [K in string]?: StoreBeforeDeleteHandler<any>[] } = {}\n\tprivate _afterDeleteHandlers: { [K in string]?: StoreAfterDeleteHandler<any>[] } = {}\n\tprivate _operationCompleteHandlers: StoreOperationCompleteHandler[] = []\n\n\tprivate _isEnabled = true\n\t/** @internal */\n\tisEnabled() {\n\t\treturn this._isEnabled\n\t}\n\t/** @internal */\n\tsetIsEnabled(enabled: boolean) {\n\t\tthis._isEnabled = enabled\n\t}\n\n\t/** @internal */\n\thandleBeforeCreate(record: R, source: 'remote' | 'user') {\n\t\tif (!this._isEnabled) return record\n\n\t\tconst handlers = this._beforeCreateHandlers[record.typeName] as StoreBeforeCreateHandler<R>[]\n\t\tif (handlers) {\n\t\t\tlet r = record\n\t\t\tfor (const handler of handlers) {\n\t\t\t\tr = handler(r, source)\n\t\t\t}\n\t\t\treturn r\n\t\t}\n\n\t\treturn record\n\t}\n\n\t/** @internal */\n\thandleAfterCreate(record: R, source: 'remote' | 'user') {\n\t\tif (!this._isEnabled) return\n\n\t\tconst handlers = this._afterCreateHandlers[record.typeName] as StoreAfterCreateHandler<R>[]\n\t\tif (handlers) {\n\t\t\tfor (const handler of handlers) {\n\t\t\t\thandler(record, source)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\thandleBeforeChange(prev: R, next: R, source: 'remote' | 'user') {\n\t\tif (!this._isEnabled) return next\n\n\t\tconst handlers = this._beforeChangeHandlers[next.typeName] as StoreBeforeChangeHandler<R>[]\n\t\tif (handlers) {\n\t\t\tlet r = next\n\t\t\tfor (const handler of handlers) {\n\t\t\t\tr = handler(prev, r, source)\n\t\t\t}\n\t\t\treturn r\n\t\t}\n\n\t\treturn next\n\t}\n\n\t/** @internal */\n\thandleAfterChange(prev: R, next: R, source: 'remote' | 'user') {\n\t\tif (!this._isEnabled) return\n\n\t\tconst handlers = this._afterChangeHandlers[next.typeName] as StoreAfterChangeHandler<R>[]\n\t\tif (handlers) {\n\t\t\tfor (const handler of handlers) {\n\t\t\t\thandler(prev, next, source)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\thandleBeforeDelete(record: R, source: 'remote' | 'user') {\n\t\tif (!this._isEnabled) return true\n\n\t\tconst handlers = this._beforeDeleteHandlers[record.typeName] as StoreBeforeDeleteHandler<R>[]\n\t\tif (handlers) {\n\t\t\tfor (const handler of handlers) {\n\t\t\t\tif (handler(record, source) === false) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\t/** @internal */\n\thandleAfterDelete(record: R, source: 'remote' | 'user') {\n\t\tif (!this._isEnabled) return\n\n\t\tconst handlers = this._afterDeleteHandlers[record.typeName] as StoreAfterDeleteHandler<R>[]\n\t\tif (handlers) {\n\t\t\tfor (const handler of handlers) {\n\t\t\t\thandler(record, source)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\thandleOperationComplete(source: 'remote' | 'user') {\n\t\tif (!this._isEnabled) return\n\n\t\tfor (const handler of this._operationCompleteHandlers) {\n\t\t\thandler(source)\n\t\t}\n\t}\n\n\t/**\n\t * Internal helper for registering a bunch of side effects at once and keeping them organized.\n\t * @internal\n\t */\n\tregister(handlersByType: {\n\t\t[T in R as T['typeName']]?: {\n\t\t\tbeforeCreate?: StoreBeforeCreateHandler<T>\n\t\t\tafterCreate?: StoreAfterCreateHandler<T>\n\t\t\tbeforeChange?: StoreBeforeChangeHandler<T>\n\t\t\tafterChange?: StoreAfterChangeHandler<T>\n\t\t\tbeforeDelete?: StoreBeforeDeleteHandler<T>\n\t\t\tafterDelete?: StoreAfterDeleteHandler<T>\n\t\t}\n\t}) {\n\t\tconst disposes: (() => void)[] = []\n\t\tfor (const [type, handlers] of Object.entries(handlersByType) as any) {\n\t\t\tif (handlers?.beforeCreate) {\n\t\t\t\tdisposes.push(this.registerBeforeCreateHandler(type, handlers.beforeCreate))\n\t\t\t}\n\t\t\tif (handlers?.afterCreate) {\n\t\t\t\tdisposes.push(this.registerAfterCreateHandler(type, handlers.afterCreate))\n\t\t\t}\n\t\t\tif (handlers?.beforeChange) {\n\t\t\t\tdisposes.push(this.registerBeforeChangeHandler(type, handlers.beforeChange))\n\t\t\t}\n\t\t\tif (handlers?.afterChange) {\n\t\t\t\tdisposes.push(this.registerAfterChangeHandler(type, handlers.afterChange))\n\t\t\t}\n\t\t\tif (handlers?.beforeDelete) {\n\t\t\t\tdisposes.push(this.registerBeforeDeleteHandler(type, handlers.beforeDelete))\n\t\t\t}\n\t\t\tif (handlers?.afterDelete) {\n\t\t\t\tdisposes.push(this.registerAfterDeleteHandler(type, handlers.afterDelete))\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\tfor (const dispose of disposes) dispose()\n\t\t}\n\t}\n\n\t/**\n\t * Register a handler to be called before a record of a certain type is created. Return a\n\t * modified record from the handler to change the record that will be created.\n\t *\n\t * Use this handle only to modify the creation of the record itself. If you want to trigger a\n\t * side-effect on a different record (for example, moving one shape when another is created),\n\t * use {@link StoreSideEffects.registerAfterCreateHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {\n\t *     // only modify shapes created by the user\n\t *     if (source !== 'user') return shape\n\t *\n\t *     //by default, arrow shapes have no label. Let's make sure they always have a label.\n\t *     if (shape.type === 'arrow') {\n\t *         return {...shape, props: {...shape.props, text: 'an arrow'}}\n\t *     }\n\t *\n\t *     // other shapes get returned unmodified\n\t *     return shape\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t *\n\t * @returns A callback that removes the handler.\n\t */\n\tregisterBeforeCreateHandler<T extends R['typeName']>(\n\t\ttypeName: T,\n\t\thandler: StoreBeforeCreateHandler<R & { typeName: T }>\n\t) {\n\t\tconst handlers = this._beforeCreateHandlers[typeName] as StoreBeforeCreateHandler<any>[]\n\t\tif (!handlers) this._beforeCreateHandlers[typeName] = []\n\t\tthis._beforeCreateHandlers[typeName]!.push(handler)\n\t\treturn () => remove(this._beforeCreateHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called after a record is created. This is useful for side-effects\n\t * that would update _other_ records. If you want to modify the record being created use\n\t * {@link StoreSideEffects.registerBeforeCreateHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {\n\t *     // Automatically create a shape when a page is created\n\t *     editor.createShape({\n\t *         id: createShapeId(),\n\t *         type: 'text',\n\t *         props: { text: page.name },\n\t *     })\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t *\n\t * @returns A callback that removes the handler.\n\t */\n\tregisterAfterCreateHandler<T extends R['typeName']>(\n\t\ttypeName: T,\n\t\thandler: StoreAfterCreateHandler<R & { typeName: T }>\n\t) {\n\t\tconst handlers = this._afterCreateHandlers[typeName] as StoreAfterCreateHandler<any>[]\n\t\tif (!handlers) this._afterCreateHandlers[typeName] = []\n\t\tthis._afterCreateHandlers[typeName]!.push(handler)\n\t\treturn () => remove(this._afterCreateHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called before a record is changed. The handler is given the old and\n\t * new record - you can return a modified record to apply a different update, or the old record\n\t * to block the update entirely.\n\t *\n\t * Use this handler only for intercepting updates to the record itself. If you want to update\n\t * other records in response to a change, use\n\t * {@link StoreSideEffects.registerAfterChangeHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {\n\t *     if (next.isLocked && !prev.isLocked) {\n\t *         // prevent shapes from ever being locked:\n\t *         return prev\n\t *     }\n\t *     // other types of change are allowed\n\t *     return next\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t *\n\t * @returns A callback that removes the handler.\n\t */\n\tregisterBeforeChangeHandler<T extends R['typeName']>(\n\t\ttypeName: T,\n\t\thandler: StoreBeforeChangeHandler<R & { typeName: T }>\n\t) {\n\t\tconst handlers = this._beforeChangeHandlers[typeName] as StoreBeforeChangeHandler<any>[]\n\t\tif (!handlers) this._beforeChangeHandlers[typeName] = []\n\t\tthis._beforeChangeHandlers[typeName]!.push(handler)\n\t\treturn () => remove(this._beforeChangeHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called after a record is changed. This is useful for side-effects\n\t * that would update _other_ records - if you want to modify the record being changed, use\n\t * {@link StoreSideEffects.registerBeforeChangeHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {\n\t *     if (next.props.color === 'red') {\n\t *         // there can only be one red shape at a time:\n\t *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)\n\t *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))\n\t *     }\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t *\n\t * @returns A callback that removes the handler.\n\t */\n\tregisterAfterChangeHandler<T extends R['typeName']>(\n\t\ttypeName: T,\n\t\thandler: StoreAfterChangeHandler<R & { typeName: T }>\n\t) {\n\t\tconst handlers = this._afterChangeHandlers[typeName] as StoreAfterChangeHandler<any>[]\n\t\tif (!handlers) this._afterChangeHandlers[typeName] = []\n\t\tthis._afterChangeHandlers[typeName]!.push(handler as StoreAfterChangeHandler<any>)\n\t\treturn () => remove(this._afterChangeHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called before a record is deleted. The handler can return `false` to\n\t * prevent the deletion.\n\t *\n\t * Use this handler only for intercepting deletions of the record itself. If you want to do\n\t * something to other records in response to a deletion, use\n\t * {@link StoreSideEffects.registerAfterDeleteHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {\n\t *     if (shape.props.color === 'red') {\n\t *         // prevent red shapes from being deleted\n\t * \t       return false\n\t *     }\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t *\n\t * @returns A callback that removes the handler.\n\t */\n\tregisterBeforeDeleteHandler<T extends R['typeName']>(\n\t\ttypeName: T,\n\t\thandler: StoreBeforeDeleteHandler<R & { typeName: T }>\n\t) {\n\t\tconst handlers = this._beforeDeleteHandlers[typeName] as StoreBeforeDeleteHandler<any>[]\n\t\tif (!handlers) this._beforeDeleteHandlers[typeName] = []\n\t\tthis._beforeDeleteHandlers[typeName]!.push(handler as StoreBeforeDeleteHandler<any>)\n\t\treturn () => remove(this._beforeDeleteHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called after a record is deleted. This is useful for side-effects\n\t * that would update _other_ records - if you want to block the deletion of the record itself,\n\t * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {\n\t *     // if the last shape in a frame is deleted, delete the frame too:\n\t *     const parentFrame = editor.getShape(shape.parentId)\n\t *     if (!parentFrame || parentFrame.type !== 'frame') return\n\t *\n\t *     const siblings = editor.getSortedChildIdsForParent(parentFrame)\n\t *     if (siblings.length === 0) {\n\t *         editor.deleteShape(parentFrame.id)\n\t *     }\n\t * })\n\t * ```\n\t *\n\t * @param typeName - The type of record to listen for\n\t * @param handler - The handler to call\n\t *\n\t * @returns A callback that removes the handler.\n\t */\n\tregisterAfterDeleteHandler<T extends R['typeName']>(\n\t\ttypeName: T,\n\t\thandler: StoreAfterDeleteHandler<R & { typeName: T }>\n\t) {\n\t\tconst handlers = this._afterDeleteHandlers[typeName] as StoreAfterDeleteHandler<any>[]\n\t\tif (!handlers) this._afterDeleteHandlers[typeName] = []\n\t\tthis._afterDeleteHandlers[typeName]!.push(handler as StoreAfterDeleteHandler<any>)\n\t\treturn () => remove(this._afterDeleteHandlers[typeName]!, handler)\n\t}\n\n\t/**\n\t * Register a handler to be called when a store completes an atomic operation.\n\t *\n\t * @example\n\t * ```ts\n\t * let count = 0\n\t *\n\t * editor.sideEffects.registerOperationCompleteHandler(() => count++)\n\t *\n\t * editor.selectAll()\n\t * expect(count).toBe(1)\n\t *\n\t * editor.store.atomic(() => {\n\t *\teditor.selectNone()\n\t * \teditor.selectAll()\n\t * })\n\t *\n\t * expect(count).toBe(2)\n\t * ```\n\t *\n\t * @param handler - The handler to call\n\t *\n\t * @returns A callback that removes the handler.\n\t *\n\t * @public\n\t */\n\tregisterOperationCompleteHandler(handler: StoreOperationCompleteHandler) {\n\t\tthis._operationCompleteHandlers.push(handler)\n\t\treturn () => remove(this._operationCompleteHandlers, handler)\n\t}\n}\n\nfunction remove(array: any[], item: any) {\n\tconst index = array.indexOf(item)\n\tif (index >= 0) {\n\t\tarray.splice(index, 1)\n\t}\n}\n", "import { STRUCTURED_CLONE_OBJECT_PROTOTYPE } from '@tldraw/utils'\n\n/**\n * Freeze an object when in development mode. Copied from\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n *\n * @example\n *\n * ```ts\n * const frozen = devFreeze({ a: 1 })\n * ```\n *\n * @param object - The object to freeze.\n * @returns The frozen object when in development mode, or else the object when in other modes.\n * @public\n */\nexport function devFreeze<T>(object: T): T {\n\tif (process.env.NODE_ENV === 'production') {\n\t\treturn object\n\t}\n\tconst proto = Object.getPrototypeOf(object)\n\tif (\n\t\tproto &&\n\t\t!(\n\t\t\tArray.isArray(object) ||\n\t\t\tproto === Object.prototype ||\n\t\t\tproto === null ||\n\t\t\tproto === STRUCTURED_CLONE_OBJECT_PROTOTYPE\n\t\t)\n\t) {\n\t\tconsole.error('cannot include non-js data in a record', object)\n\t\tthrow new Error('cannot include non-js data in a record')\n\t}\n\n\t// Retrieve the property names defined on object\n\tconst propNames = Object.getOwnPropertyNames(object)\n\n\t// Recursively freeze properties before freezing self\n\tfor (const name of propNames) {\n\t\tconst value = (object as any)[name]\n\n\t\tif (value && typeof value === 'object') {\n\t\t\tdevFreeze(value)\n\t\t}\n\t}\n\n\treturn Object.freeze(object)\n}\n", "import {\n\tResult,\n\tassert,\n\texhaustiveSwitchError,\n\tgetOwnProperty,\n\tstructuredClone,\n} from '@tldraw/utils'\nimport { UnknownRecord } from './BaseRecord'\nimport { RecordType } from './RecordType'\nimport { SerializedStore, Store, StoreSnapshot } from './Store'\nimport {\n\tMigration,\n\tMigrationFailureReason,\n\tMigrationId,\n\tMigrationResult,\n\tMigrationSequence,\n\tparseMigrationId,\n\tsortMigrations,\n\tvalidateMigrations,\n} from './migrate'\n\n/** @public */\nexport interface SerializedSchemaV1 {\n\t/** Schema version is the version for this type you're looking at right now */\n\tschemaVersion: 1\n\t/**\n\t * Store version is the version for the structure of the store. e.g. higher level structure like\n\t * removing or renaming a record type.\n\t */\n\tstoreVersion: number\n\t/** Record versions are the versions for each record type. e.g. adding a new field to a record */\n\trecordVersions: Record<\n\t\tstring,\n\t\t| {\n\t\t\t\tversion: number\n\t\t  }\n\t\t| {\n\t\t\t\t// subtypes are used for migrating shape and asset props\n\t\t\t\tversion: number\n\t\t\t\tsubTypeVersions: Record<string, number>\n\t\t\t\tsubTypeKey: string\n\t\t  }\n\t>\n}\n\n/** @public */\nexport interface SerializedSchemaV2 {\n\tschemaVersion: 2\n\tsequences: {\n\t\t[sequenceId: string]: number\n\t}\n}\n\n/** @public */\nexport type SerializedSchema = SerializedSchemaV1 | SerializedSchemaV2\n\nexport function upgradeSchema(schema: SerializedSchema): Result<SerializedSchemaV2, string> {\n\tif (schema.schemaVersion > 2 || schema.schemaVersion < 1) return Result.err('Bad schema version')\n\tif (schema.schemaVersion === 2) return Result.ok(schema as SerializedSchemaV2)\n\tconst result: SerializedSchemaV2 = {\n\t\tschemaVersion: 2,\n\t\tsequences: {\n\t\t\t'com.tldraw.store': schema.storeVersion,\n\t\t},\n\t}\n\n\tfor (const [typeName, recordVersion] of Object.entries(schema.recordVersions)) {\n\t\tresult.sequences[`com.tldraw.${typeName}`] = recordVersion.version\n\t\tif ('subTypeKey' in recordVersion) {\n\t\t\tfor (const [subType, version] of Object.entries(recordVersion.subTypeVersions)) {\n\t\t\t\tresult.sequences[`com.tldraw.${typeName}.${subType}`] = version\n\t\t\t}\n\t\t}\n\t}\n\treturn Result.ok(result)\n}\n\n/** @public */\nexport interface StoreValidationFailure<R extends UnknownRecord> {\n\terror: unknown\n\tstore: Store<R>\n\trecord: R\n\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests'\n\trecordBefore: R | null\n}\n\n/** @public */\nexport interface StoreSchemaOptions<R extends UnknownRecord, P> {\n\tmigrations?: MigrationSequence[]\n\t/** @public */\n\tonValidationFailure?(data: StoreValidationFailure<R>): R\n\t/** @internal */\n\tcreateIntegrityChecker?(store: Store<R, P>): void\n}\n\n/** @public */\nexport class StoreSchema<R extends UnknownRecord, P = unknown> {\n\tstatic create<R extends UnknownRecord, P = unknown>(\n\t\t// HACK: making this param work with RecordType is an enormous pain\n\t\t// let's just settle for making sure each typeName has a corresponding RecordType\n\t\t// and accept that this function won't be able to infer the record type from it's arguments\n\t\ttypes: { [TypeName in R['typeName']]: { createId: any } },\n\t\toptions?: StoreSchemaOptions<R, P>\n\t): StoreSchema<R, P> {\n\t\treturn new StoreSchema<R, P>(types as any, options ?? {})\n\t}\n\n\treadonly migrations: Record<string, MigrationSequence> = {}\n\treadonly sortedMigrations: readonly Migration[]\n\n\tprivate constructor(\n\t\tpublic readonly types: {\n\t\t\t[Record in R as Record['typeName']]: RecordType<R, any>\n\t\t},\n\t\tprivate readonly options: StoreSchemaOptions<R, P>\n\t) {\n\t\tfor (const m of options.migrations ?? []) {\n\t\t\tassert(!this.migrations[m.sequenceId], `Duplicate migration sequenceId ${m.sequenceId}`)\n\t\t\tvalidateMigrations(m)\n\t\t\tthis.migrations[m.sequenceId] = m\n\t\t}\n\t\tconst allMigrations = Object.values(this.migrations).flatMap((m) => m.sequence)\n\t\tthis.sortedMigrations = sortMigrations(allMigrations)\n\n\t\tfor (const migration of this.sortedMigrations) {\n\t\t\tif (!migration.dependsOn?.length) continue\n\t\t\tfor (const dep of migration.dependsOn) {\n\t\t\t\tconst depMigration = allMigrations.find((m) => m.id === dep)\n\t\t\t\tassert(depMigration, `Migration '${migration.id}' depends on missing migration '${dep}'`)\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidateRecord(\n\t\tstore: Store<R>,\n\t\trecord: R,\n\t\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests',\n\t\trecordBefore: R | null\n\t): R {\n\t\ttry {\n\t\t\tconst recordType = getOwnProperty(this.types, record.typeName)\n\t\t\tif (!recordType) {\n\t\t\t\tthrow new Error(`Missing definition for record type ${record.typeName}`)\n\t\t\t}\n\t\t\treturn recordType.validate(record, recordBefore ?? undefined)\n\t\t} catch (error: unknown) {\n\t\t\tif (this.options.onValidationFailure) {\n\t\t\t\treturn this.options.onValidationFailure({\n\t\t\t\t\tstore,\n\t\t\t\t\trecord,\n\t\t\t\t\tphase,\n\t\t\t\t\trecordBefore,\n\t\t\t\t\terror,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthrow error\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: use a weakmap to store the result of this function\n\tpublic getMigrationsSince(persistedSchema: SerializedSchema): Result<Migration[], string> {\n\t\tconst upgradeResult = upgradeSchema(persistedSchema)\n\t\tif (!upgradeResult.ok) {\n\t\t\treturn upgradeResult\n\t\t}\n\t\tconst schema = upgradeResult.value\n\t\tconst sequenceIdsToInclude = new Set(\n\t\t\t// start with any shared sequences\n\t\t\tObject.keys(schema.sequences).filter((sequenceId) => this.migrations[sequenceId])\n\t\t)\n\n\t\t// also include any sequences that are not in the persisted schema but are marked as postHoc\n\t\tfor (const sequenceId in this.migrations) {\n\t\t\tif (schema.sequences[sequenceId] === undefined && this.migrations[sequenceId].retroactive) {\n\t\t\t\tsequenceIdsToInclude.add(sequenceId)\n\t\t\t}\n\t\t}\n\n\t\tif (sequenceIdsToInclude.size === 0) {\n\t\t\treturn Result.ok([])\n\t\t}\n\n\t\tconst allMigrationsToInclude = new Set<MigrationId>()\n\t\tfor (const sequenceId of sequenceIdsToInclude) {\n\t\t\tconst theirVersion = schema.sequences[sequenceId]\n\t\t\tif (\n\t\t\t\t(typeof theirVersion !== 'number' && this.migrations[sequenceId].retroactive) ||\n\t\t\t\ttheirVersion === 0\n\t\t\t) {\n\t\t\t\tfor (const migration of this.migrations[sequenceId].sequence) {\n\t\t\t\t\tallMigrationsToInclude.add(migration.id)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconst theirVersionId = `${sequenceId}/${theirVersion}`\n\t\t\tconst idx = this.migrations[sequenceId].sequence.findIndex((m) => m.id === theirVersionId)\n\t\t\t// todo: better error handling\n\t\t\tif (idx === -1) {\n\t\t\t\treturn Result.err('Incompatible schema?')\n\t\t\t}\n\t\t\tfor (const migration of this.migrations[sequenceId].sequence.slice(idx + 1)) {\n\t\t\t\tallMigrationsToInclude.add(migration.id)\n\t\t\t}\n\t\t}\n\n\t\t// collect any migrations\n\t\treturn Result.ok(this.sortedMigrations.filter(({ id }) => allMigrationsToInclude.has(id)))\n\t}\n\n\tmigratePersistedRecord(\n\t\trecord: R,\n\t\tpersistedSchema: SerializedSchema,\n\t\tdirection: 'up' | 'down' = 'up'\n\t): MigrationResult<R> {\n\t\tconst migrations = this.getMigrationsSince(persistedSchema)\n\t\tif (!migrations.ok) {\n\t\t\t// TODO: better error\n\t\t\tconsole.error('Error migrating record', migrations.error)\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.MigrationError }\n\t\t}\n\t\tlet migrationsToApply = migrations.value\n\t\tif (migrationsToApply.length === 0) {\n\t\t\treturn { type: 'success', value: record }\n\t\t}\n\n\t\tif (migrationsToApply.some((m) => m.scope === 'store')) {\n\t\t\treturn {\n\t\t\t\ttype: 'error',\n\t\t\t\treason:\n\t\t\t\t\tdirection === 'down'\n\t\t\t\t\t\t? MigrationFailureReason.TargetVersionTooOld\n\t\t\t\t\t\t: MigrationFailureReason.TargetVersionTooNew,\n\t\t\t}\n\t\t}\n\n\t\tif (direction === 'down') {\n\t\t\tif (!migrationsToApply.every((m) => m.down)) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'error',\n\t\t\t\t\treason: MigrationFailureReason.TargetVersionTooOld,\n\t\t\t\t}\n\t\t\t}\n\t\t\tmigrationsToApply = migrationsToApply.slice().reverse()\n\t\t}\n\n\t\trecord = structuredClone(record)\n\t\ttry {\n\t\t\tfor (const migration of migrationsToApply) {\n\t\t\t\tif (migration.scope === 'store') throw new Error(/* won't happen, just for TS */)\n\t\t\t\tconst shouldApply = migration.filter ? migration.filter(record) : true\n\t\t\t\tif (!shouldApply) continue\n\t\t\t\tconst result = migration[direction]!(record)\n\t\t\t\tif (result) {\n\t\t\t\t\trecord = structuredClone(result) as any\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('Error migrating record', e)\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.MigrationError }\n\t\t}\n\n\t\treturn { type: 'success', value: record }\n\t}\n\n\tmigrateStoreSnapshot(snapshot: StoreSnapshot<R>): MigrationResult<SerializedStore<R>> {\n\t\tlet { store } = snapshot\n\t\tconst migrations = this.getMigrationsSince(snapshot.schema)\n\t\tif (!migrations.ok) {\n\t\t\t// TODO: better error\n\t\t\tconsole.error('Error migrating store', migrations.error)\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.MigrationError }\n\t\t}\n\t\tconst migrationsToApply = migrations.value\n\t\tif (migrationsToApply.length === 0) {\n\t\t\treturn { type: 'success', value: store }\n\t\t}\n\n\t\tstore = structuredClone(store)\n\n\t\ttry {\n\t\t\tfor (const migration of migrationsToApply) {\n\t\t\t\tif (migration.scope === 'record') {\n\t\t\t\t\tfor (const [id, record] of Object.entries(store)) {\n\t\t\t\t\t\tconst shouldApply = migration.filter ? migration.filter(record as UnknownRecord) : true\n\t\t\t\t\t\tif (!shouldApply) continue\n\t\t\t\t\t\tconst result = migration.up!(record as any)\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tstore[id as keyof typeof store] = structuredClone(result) as any\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (migration.scope === 'store') {\n\t\t\t\t\tconst result = migration.up!(store)\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tstore = structuredClone(result) as any\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\texhaustiveSwitchError(migration)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error('Error migrating store', e)\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.MigrationError }\n\t\t}\n\n\t\treturn { type: 'success', value: store }\n\t}\n\n\t/** @internal */\n\tcreateIntegrityChecker(store: Store<R, P>): (() => void) | undefined {\n\t\treturn this.options.createIntegrityChecker?.(store) ?? undefined\n\t}\n\n\tserialize(): SerializedSchemaV2 {\n\t\treturn {\n\t\t\tschemaVersion: 2,\n\t\t\tsequences: Object.fromEntries(\n\t\t\t\tObject.values(this.migrations).map(({ sequenceId, sequence }) => [\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tsequence.length ? parseMigrationId(sequence.at(-1)!.id).version : 0,\n\t\t\t\t])\n\t\t\t),\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!\n\t */\n\tserializeEarliestVersion(): SerializedSchema {\n\t\treturn {\n\t\t\tschemaVersion: 2,\n\t\t\tsequences: Object.fromEntries(\n\t\t\t\tObject.values(this.migrations).map(({ sequenceId }) => [sequenceId, 0])\n\t\t\t),\n\t\t}\n\t}\n\n\t/** @internal */\n\tgetType(typeName: string) {\n\t\tconst type = getOwnProperty(this.types, typeName)\n\t\tassert(type, 'record type does not exists')\n\t\treturn type\n\t}\n}\n", "import { assert, objectMapEntries } from '@tldraw/utils'\nimport { UnknownRecord } from './BaseRecord'\nimport { SerializedStore } from './Store'\n\nlet didWarn = false\n\n/**\n * @public\n * @deprecated use `createShapePropsMigrationSequence` instead. See [the docs](https://tldraw.dev/docs/persistence#Updating-legacy-shape-migrations-defineMigrations) for how to migrate.\n */\nexport function defineMigrations(opts: {\n\tfirstVersion?: number\n\tcurrentVersion?: number\n\tmigrators?: Record<number, LegacyMigration>\n\tsubTypeKey?: string\n\tsubTypeMigrations?: Record<string, LegacyBaseMigrationsInfo>\n}): LegacyMigrations {\n\tconst { currentVersion, firstVersion, migrators = {}, subTypeKey, subTypeMigrations } = opts\n\tif (!didWarn) {\n\t\tconsole.warn(\n\t\t\t`The 'defineMigrations' function is deprecated and will be removed in a future release. Use the new migrations API instead. See the migration guide for more info: https://tldraw.dev/docs/persistence#Updating-legacy-shape-migrations-defineMigrations`\n\t\t)\n\t\tdidWarn = true\n\t}\n\n\t// Some basic guards against impossible version combinations, some of which will be caught by TypeScript\n\tif (typeof currentVersion === 'number' && typeof firstVersion === 'number') {\n\t\tif ((currentVersion as number) === (firstVersion as number)) {\n\t\t\tthrow Error(`Current version is equal to initial version.`)\n\t\t} else if (currentVersion < firstVersion) {\n\t\t\tthrow Error(`Current version is lower than initial version.`)\n\t\t}\n\t}\n\n\treturn {\n\t\tfirstVersion: (firstVersion as number) ?? 0, // defaults\n\t\tcurrentVersion: (currentVersion as number) ?? 0, // defaults\n\t\tmigrators,\n\t\tsubTypeKey,\n\t\tsubTypeMigrations,\n\t}\n}\n\nfunction squashDependsOn(sequence: Array<Migration | StandaloneDependsOn>): Migration[] {\n\tconst result: Migration[] = []\n\tfor (let i = sequence.length - 1; i >= 0; i--) {\n\t\tconst elem = sequence[i]\n\t\tif (!('id' in elem)) {\n\t\t\tconst dependsOn = elem.dependsOn\n\t\t\tconst prev = result[0]\n\t\t\tif (prev) {\n\t\t\t\tresult[0] = {\n\t\t\t\t\t...prev,\n\t\t\t\t\tdependsOn: dependsOn.concat(prev.dependsOn ?? []),\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult.unshift(elem)\n\t\t}\n\t}\n\treturn result\n}\n\n/**\n * Creates a migration sequence.\n * See the [migration guide](https://tldraw.dev/docs/persistence#Migrations) for more info on how to use this API.\n * @public\n */\nexport function createMigrationSequence({\n\tsequence,\n\tsequenceId,\n\tretroactive = true,\n}: {\n\tsequenceId: string\n\tretroactive?: boolean\n\tsequence: Array<Migration | StandaloneDependsOn>\n}): MigrationSequence {\n\tconst migrations: MigrationSequence = {\n\t\tsequenceId,\n\t\tretroactive,\n\t\tsequence: squashDependsOn(sequence),\n\t}\n\tvalidateMigrations(migrations)\n\treturn migrations\n}\n\n/**\n * Creates a named set of migration ids given a named set of version numbers and a sequence id.\n *\n * See the [migration guide](https://tldraw.dev/docs/persistence#Migrations) for more info on how to use this API.\n * @public\n * @public\n */\nexport function createMigrationIds<\n\tconst ID extends string,\n\tconst Versions extends Record<string, number>,\n>(sequenceId: ID, versions: Versions): { [K in keyof Versions]: `${ID}/${Versions[K]}` } {\n\treturn Object.fromEntries(\n\t\tobjectMapEntries(versions).map(([key, version]) => [key, `${sequenceId}/${version}`] as const)\n\t) as any\n}\n\n/** @internal */\nexport function createRecordMigrationSequence(opts: {\n\trecordType: string\n\tfilter?(record: UnknownRecord): boolean\n\tretroactive?: boolean\n\tsequenceId: string\n\tsequence: Omit<Extract<Migration, { scope: 'record' }>, 'scope'>[]\n}): MigrationSequence {\n\tconst sequenceId = opts.sequenceId\n\treturn createMigrationSequence({\n\t\tsequenceId,\n\t\tretroactive: opts.retroactive ?? true,\n\t\tsequence: opts.sequence.map((m) =>\n\t\t\t'id' in m\n\t\t\t\t? {\n\t\t\t\t\t\t...m,\n\t\t\t\t\t\tscope: 'record',\n\t\t\t\t\t\tfilter: (r: UnknownRecord) =>\n\t\t\t\t\t\t\tr.typeName === opts.recordType &&\n\t\t\t\t\t\t\t(m.filter?.(r) ?? true) &&\n\t\t\t\t\t\t\t(opts.filter?.(r) ?? true),\n\t\t\t\t\t}\n\t\t\t\t: m\n\t\t),\n\t})\n}\n\n/** @public */\nexport interface LegacyMigration<Before = any, After = any> {\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tup: (oldState: Before) => After\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tdown: (newState: After) => Before\n}\n\n/** @public */\nexport type MigrationId = `${string}/${number}`\n\n/** @public */\nexport interface StandaloneDependsOn {\n\treadonly dependsOn: readonly MigrationId[]\n}\n\n/** @public */\nexport type Migration = {\n\treadonly id: MigrationId\n\treadonly dependsOn?: readonly MigrationId[] | undefined\n} & (\n\t| {\n\t\t\treadonly scope: 'record'\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\treadonly filter?: (record: UnknownRecord) => boolean\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\treadonly up: (oldState: UnknownRecord) => void | UnknownRecord\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\treadonly down?: (newState: UnknownRecord) => void | UnknownRecord\n\t  }\n\t| {\n\t\t\treadonly scope: 'store'\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\treadonly up: (\n\t\t\t\toldState: SerializedStore<UnknownRecord>\n\t\t\t) => void | SerializedStore<UnknownRecord>\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\treadonly down?: (\n\t\t\t\tnewState: SerializedStore<UnknownRecord>\n\t\t\t) => void | SerializedStore<UnknownRecord>\n\t  }\n)\n\n/** @public */\nexport interface LegacyBaseMigrationsInfo {\n\tfirstVersion: number\n\tcurrentVersion: number\n\tmigrators: { [version: number]: LegacyMigration }\n}\n\n/** @public */\nexport interface LegacyMigrations extends LegacyBaseMigrationsInfo {\n\tsubTypeKey?: string\n\tsubTypeMigrations?: Record<string, LegacyBaseMigrationsInfo>\n}\n\n/** @public */\nexport interface MigrationSequence {\n\tsequenceId: string\n\t/**\n\t * retroactive should be true if the migrations should be applied to snapshots that were created before\n\t * this migration sequence was added to the schema.\n\t *\n\t * In general:\n\t *\n\t * - retroactive should be true when app developers create their own new migration sequences.\n\t * - retroactive should be false when library developers ship a migration sequence. When you install a library for the first time, any migrations that were added in the library before that point should generally _not_ be applied to your existing data.\n\t */\n\tretroactive: boolean\n\tsequence: Migration[]\n}\n\nexport function sortMigrations(migrations: Migration[]): Migration[] {\n\t// we do a topological sort using dependsOn and implicit dependencies between migrations in the same sequence\n\tconst byId = new Map(migrations.map((m) => [m.id, m]))\n\tconst isProcessing = new Set<MigrationId>()\n\n\tconst result: Migration[] = []\n\n\tfunction process(m: Migration) {\n\t\tassert(!isProcessing.has(m.id), `Circular dependency in migrations: ${m.id}`)\n\t\tisProcessing.add(m.id)\n\n\t\tconst { version, sequenceId } = parseMigrationId(m.id)\n\t\tconst parent = byId.get(`${sequenceId}/${version - 1}`)\n\t\tif (parent) {\n\t\t\tprocess(parent)\n\t\t}\n\n\t\tif (m.dependsOn) {\n\t\t\tfor (const dep of m.dependsOn) {\n\t\t\t\tconst depMigration = byId.get(dep)\n\t\t\t\tif (depMigration) {\n\t\t\t\t\tprocess(depMigration)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbyId.delete(m.id)\n\t\tresult.push(m)\n\t}\n\n\tfor (const m of byId.values()) {\n\t\tprocess(m)\n\t}\n\n\treturn result\n}\n\n/** @internal */\nexport function parseMigrationId(id: MigrationId): { sequenceId: string; version: number } {\n\tconst [sequenceId, version] = id.split('/')\n\treturn { sequenceId, version: parseInt(version) }\n}\n\nfunction validateMigrationId(id: string, expectedSequenceId?: string) {\n\tif (expectedSequenceId) {\n\t\tassert(\n\t\t\tid.startsWith(expectedSequenceId + '/'),\n\t\t\t`Every migration in sequence '${expectedSequenceId}' must have an id starting with '${expectedSequenceId}/'. Got invalid id: '${id}'`\n\t\t)\n\t}\n\n\tassert(id.match(/^(.*?)\\/(0|[1-9]\\d*)$/), `Invalid migration id: '${id}'`)\n}\n\nexport function validateMigrations(migrations: MigrationSequence) {\n\tassert(\n\t\t!migrations.sequenceId.includes('/'),\n\t\t`sequenceId cannot contain a '/', got ${migrations.sequenceId}`\n\t)\n\tassert(migrations.sequenceId.length, 'sequenceId must be a non-empty string')\n\n\tif (migrations.sequence.length === 0) {\n\t\treturn\n\t}\n\n\tvalidateMigrationId(migrations.sequence[0].id, migrations.sequenceId)\n\tlet n = parseMigrationId(migrations.sequence[0].id).version\n\tassert(\n\t\tn === 1,\n\t\t`Expected the first migrationId to be '${migrations.sequenceId}/1' but got '${migrations.sequence[0].id}'`\n\t)\n\tfor (let i = 1; i < migrations.sequence.length; i++) {\n\t\tconst id = migrations.sequence[i].id\n\t\tvalidateMigrationId(id, migrations.sequenceId)\n\t\tconst m = parseMigrationId(id).version\n\t\tassert(\n\t\t\tm === n + 1,\n\t\t\t`Migration id numbers must increase in increments of 1, expected ${migrations.sequenceId}/${n + 1} but got '${migrations.sequence[i].id}'`\n\t\t)\n\t\tn = m\n\t}\n}\n\n/** @public */\nexport type MigrationResult<T> =\n\t| { type: 'success'; value: T }\n\t| { type: 'error'; reason: MigrationFailureReason }\n\n/** @public */\nexport enum MigrationFailureReason {\n\tIncompatibleSubtype = 'incompatible-subtype',\n\tUnknownType = 'unknown-type',\n\tTargetVersionTooNew = 'target-version-too-new',\n\tTargetVersionTooOld = 'target-version-too-old',\n\tMigrationError = 'migration-error',\n\tUnrecognizedSubtype = 'unrecognized-subtype',\n}\n", "import { RecordsDiff, UnknownRecord } from '@tldraw/store'\nimport { objectMapEntries, objectMapValues } from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\n\n/** @internal */\nexport const RecordOpType = {\n\tPut: 'put',\n\tPatch: 'patch',\n\tRemove: 'remove',\n} as const\n\n/** @internal */\nexport type RecordOpType = (typeof RecordOpType)[keyof typeof RecordOpType]\n\n/** @internal */\nexport type RecordOp<R extends UnknownRecord> =\n\t| [typeof RecordOpType.Put, R]\n\t| [typeof RecordOpType.Patch, ObjectDiff]\n\t| [typeof RecordOpType.Remove]\n\n/**\n * A one-way (non-reversible) diff designed for small json footprint. These are mainly intended to\n * be sent over the wire. Either as push requests from the client to the server, or as patch\n * operations in the opposite direction.\n *\n * Each key in this object is the id of a record that has been added, updated, or removed.\n *\n * @internal\n */\nexport interface NetworkDiff<R extends UnknownRecord> {\n\t[id: string]: RecordOp<R>\n}\n\n/**\n * Converts a (reversible, verbose) RecordsDiff into a (non-reversible, concise) NetworkDiff\n *\n *@internal\n */\nexport function getNetworkDiff<R extends UnknownRecord>(\n\tdiff: RecordsDiff<R>\n): NetworkDiff<R> | null {\n\tlet res: NetworkDiff<R> | null = null\n\n\tfor (const [k, v] of objectMapEntries(diff.added)) {\n\t\tif (!res) res = {}\n\t\tres[k] = [RecordOpType.Put, v]\n\t}\n\n\tfor (const [from, to] of objectMapValues(diff.updated)) {\n\t\tconst diff = diffRecord(from, to)\n\t\tif (diff) {\n\t\t\tif (!res) res = {}\n\t\t\tres[to.id] = [RecordOpType.Patch, diff]\n\t\t}\n\t}\n\n\tfor (const removed of Object.keys(diff.removed)) {\n\t\tif (!res) res = {}\n\t\tres[removed] = [RecordOpType.Remove]\n\t}\n\n\treturn res\n}\n\n/** @internal */\nexport const ValueOpType = {\n\tPut: 'put',\n\tDelete: 'delete',\n\tAppend: 'append',\n\tPatch: 'patch',\n} as const\n/** @internal */\nexport type ValueOpType = (typeof ValueOpType)[keyof typeof ValueOpType]\n\n/** @internal */\nexport type PutOp = [type: typeof ValueOpType.Put, value: unknown]\n/** @internal */\nexport type AppendOp = [type: typeof ValueOpType.Append, values: unknown[], offset: number]\n/** @internal */\nexport type PatchOp = [type: typeof ValueOpType.Patch, diff: ObjectDiff]\n/** @internal */\nexport type DeleteOp = [type: typeof ValueOpType.Delete]\n\n/** @internal */\nexport type ValueOp = PutOp | AppendOp | PatchOp | DeleteOp\n\n/** @internal */\nexport interface ObjectDiff {\n\t[k: string]: ValueOp\n}\n\n/** @internal */\nexport function diffRecord(prev: object, next: object): ObjectDiff | null {\n\treturn diffObject(prev, next, new Set(['props']))\n}\n\nfunction diffObject(prev: object, next: object, nestedKeys?: Set<string>): ObjectDiff | null {\n\tif (prev === next) {\n\t\treturn null\n\t}\n\tlet result: ObjectDiff | null = null\n\tfor (const key of Object.keys(prev)) {\n\t\t// if key is not in next then it was deleted\n\t\tif (!(key in next)) {\n\t\t\tif (!result) result = {}\n\t\t\tresult[key] = [ValueOpType.Delete]\n\t\t\tcontinue\n\t\t}\n\t\t// if key is in both places, then compare values\n\t\tconst prevVal = (prev as any)[key]\n\t\tconst nextVal = (next as any)[key]\n\t\tif (!isEqual(prevVal, nextVal)) {\n\t\t\tif (nestedKeys?.has(key) && prevVal && nextVal) {\n\t\t\t\tconst diff = diffObject(prevVal, nextVal)\n\t\t\t\tif (diff) {\n\t\t\t\t\tif (!result) result = {}\n\t\t\t\t\tresult[key] = [ValueOpType.Patch, diff]\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(nextVal) && Array.isArray(prevVal)) {\n\t\t\t\tconst op = diffArray(prevVal, nextVal)\n\t\t\t\tif (op) {\n\t\t\t\t\tif (!result) result = {}\n\t\t\t\t\tresult[key] = op\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!result) result = {}\n\t\t\t\tresult[key] = [ValueOpType.Put, nextVal]\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key of Object.keys(next)) {\n\t\t// if key is in next but not in prev then it was added\n\t\tif (!(key in prev)) {\n\t\t\tif (!result) result = {}\n\t\t\tresult[key] = [ValueOpType.Put, (next as any)[key]]\n\t\t}\n\t}\n\treturn result\n}\n\nfunction diffValue(valueA: unknown, valueB: unknown): ValueOp | null {\n\tif (Object.is(valueA, valueB)) return null\n\tif (Array.isArray(valueA) && Array.isArray(valueB)) {\n\t\treturn diffArray(valueA, valueB)\n\t} else if (!valueA || !valueB || typeof valueA !== 'object' || typeof valueB !== 'object') {\n\t\treturn isEqual(valueA, valueB) ? null : [ValueOpType.Put, valueB]\n\t} else {\n\t\tconst diff = diffObject(valueA, valueB)\n\t\treturn diff ? [ValueOpType.Patch, diff] : null\n\t}\n}\n\nfunction diffArray(prevArray: unknown[], nextArray: unknown[]): PutOp | AppendOp | PatchOp | null {\n\tif (Object.is(prevArray, nextArray)) return null\n\t// if lengths are equal, check for patch operation\n\tif (prevArray.length === nextArray.length) {\n\t\t// bail out if more than len/5 items need patching\n\t\tconst maxPatchIndexes = Math.max(prevArray.length / 5, 1)\n\t\tconst toPatchIndexes = []\n\t\tfor (let i = 0; i < prevArray.length; i++) {\n\t\t\tif (!isEqual(prevArray[i], nextArray[i])) {\n\t\t\t\ttoPatchIndexes.push(i)\n\t\t\t\tif (toPatchIndexes.length > maxPatchIndexes) {\n\t\t\t\t\treturn [ValueOpType.Put, nextArray]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (toPatchIndexes.length === 0) {\n\t\t\t// same length and no items changed, so no diff\n\t\t\treturn null\n\t\t}\n\t\tconst diff: ObjectDiff = {}\n\t\tfor (const i of toPatchIndexes) {\n\t\t\tconst prevItem = prevArray[i]\n\t\t\tconst nextItem = nextArray[i]\n\t\t\tif (!prevItem || !nextItem) {\n\t\t\t\tdiff[i] = [ValueOpType.Put, nextItem]\n\t\t\t} else if (typeof prevItem === 'object' && typeof nextItem === 'object') {\n\t\t\t\tconst op = diffValue(prevItem, nextItem)\n\t\t\t\tif (op) {\n\t\t\t\t\tdiff[i] = op\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdiff[i] = [ValueOpType.Put, nextItem]\n\t\t\t}\n\t\t}\n\t\treturn [ValueOpType.Patch, diff]\n\t}\n\n\t// if lengths are not equal, check for append operation, and bail out\n\t// to replace whole array if any shared elems changed\n\tfor (let i = 0; i < prevArray.length; i++) {\n\t\tif (!isEqual(prevArray[i], nextArray[i])) {\n\t\t\treturn [ValueOpType.Put, nextArray]\n\t\t}\n\t}\n\n\treturn [ValueOpType.Append, nextArray.slice(prevArray.length), prevArray.length]\n}\n\n/** @internal */\nexport function applyObjectDiff<T extends object>(object: T, objectDiff: ObjectDiff): T {\n\t// don't patch nulls\n\tif (!object || typeof object !== 'object') return object\n\tconst isArray = Array.isArray(object)\n\tlet newObject: any | undefined = undefined\n\tconst set = (k: any, v: any) => {\n\t\tif (!newObject) {\n\t\t\tif (isArray) {\n\t\t\t\tnewObject = [...object]\n\t\t\t} else {\n\t\t\t\tnewObject = { ...object }\n\t\t\t}\n\t\t}\n\t\tif (isArray) {\n\t\t\tnewObject[Number(k)] = v\n\t\t} else {\n\t\t\tnewObject[k] = v\n\t\t}\n\t}\n\tfor (const [key, op] of Object.entries(objectDiff)) {\n\t\tswitch (op[0]) {\n\t\t\tcase ValueOpType.Put: {\n\t\t\t\tconst value = op[1]\n\t\t\t\tif (!isEqual(object[key as keyof T], value)) {\n\t\t\t\t\tset(key, value)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Append: {\n\t\t\t\tconst values = op[1]\n\t\t\t\tconst offset = op[2]\n\t\t\t\tconst arr = object[key as keyof T]\n\t\t\t\tif (Array.isArray(arr) && arr.length === offset) {\n\t\t\t\t\tset(key, [...arr, ...values])\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Patch: {\n\t\t\t\tif (object[key as keyof T] && typeof object[key as keyof T] === 'object') {\n\t\t\t\t\tconst diff = op[1]\n\t\t\t\t\tconst patched = applyObjectDiff(object[key as keyof T] as object, diff)\n\t\t\t\t\tif (patched !== object[key as keyof T]) {\n\t\t\t\t\t\tset(key, patched)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Delete: {\n\t\t\t\tif (key in object) {\n\t\t\t\t\tif (!newObject) {\n\t\t\t\t\t\tif (isArray) {\n\t\t\t\t\t\t\tconsole.error(\"Can't delete array item yet (this should never happen)\")\n\t\t\t\t\t\t\tnewObject = [...object]\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewObject = { ...object }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelete newObject[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newObject ?? object\n}\n", "export function interval(cb: () => void, timeout: number) {\n\tconst i = setInterval(cb, timeout)\n\treturn () => clearInterval(i)\n}\n", "import { SerializedSchema, UnknownRecord } from '@tldraw/store'\nimport { NetworkDiff, ObjectDiff, RecordOpType } from './diff'\n\nconst TLSYNC_PROTOCOL_VERSION = 7\n\n/** @internal */\nexport function getTlsyncProtocolVersion() {\n\treturn TLSYNC_PROTOCOL_VERSION\n}\n\n/**\n * @internal\n * @deprecated Replaced by websocket .close status/reason\n */\nexport const TLIncompatibilityReason = {\n\tClientTooOld: 'clientTooOld',\n\tServerTooOld: 'serverTooOld',\n\tInvalidRecord: 'invalidRecord',\n\tInvalidOperation: 'invalidOperation',\n} as const\n\n/**\n * @internal\n * @deprecated replaced by websocket .close status/reason\n */\nexport type TLIncompatibilityReason =\n\t// eslint-disable-next-line deprecation/deprecation\n\t(typeof TLIncompatibilityReason)[keyof typeof TLIncompatibilityReason]\n\n/** @internal */\nexport type TLSocketServerSentEvent<R extends UnknownRecord> =\n\t| {\n\t\t\ttype: 'connect'\n\t\t\thydrationType: 'wipe_all' | 'wipe_presence'\n\t\t\tconnectRequestId: string\n\t\t\tprotocolVersion: number\n\t\t\tschema: SerializedSchema\n\t\t\tdiff: NetworkDiff<R>\n\t\t\tserverClock: number\n\t\t\tisReadonly: boolean\n\t  }\n\t| {\n\t\t\ttype: 'incompatibility_error'\n\t\t\t// eslint-disable-next-line deprecation/deprecation\n\t\t\treason: TLIncompatibilityReason\n\t  }\n\t| {\n\t\t\ttype: 'pong'\n\t  }\n\t| { type: 'data'; data: TLSocketServerSentDataEvent<R>[] }\n\t| TLSocketServerSentDataEvent<R>\n\n/** @internal */\nexport type TLSocketServerSentDataEvent<R extends UnknownRecord> =\n\t| {\n\t\t\ttype: 'patch'\n\t\t\tdiff: NetworkDiff<R>\n\t\t\tserverClock: number\n\t  }\n\t| {\n\t\t\ttype: 'push_result'\n\t\t\tclientClock: number\n\t\t\tserverClock: number\n\t\t\taction: 'discard' | 'commit' | { rebaseWithDiff: NetworkDiff<R> }\n\t  }\n\n/** @internal */\nexport interface TLPushRequest<R extends UnknownRecord> {\n\ttype: 'push'\n\tclientClock: number\n\tdiff?: NetworkDiff<R>\n\tpresence?: [typeof RecordOpType.Patch, ObjectDiff] | [typeof RecordOpType.Put, R]\n}\n\n/** @internal */\nexport interface TLConnectRequest {\n\ttype: 'connect'\n\tconnectRequestId: string\n\tlastServerClock: number\n\tprotocolVersion: number\n\tschema: SerializedSchema\n}\n\n/** @internal */\nexport interface TLPingRequest {\n\ttype: 'ping'\n}\n\n/** @internal */\nexport type TLSocketClientSentEvent<R extends UnknownRecord> =\n\t| TLPushRequest<R>\n\t| TLConnectRequest\n\t| TLPingRequest\n", "import { SerializedSchema, UnknownRecord } from '@tldraw/store'\nimport { TLRoomSocket } from './TLSyncRoom'\nimport { TLSocketServerSentDataEvent } from './protocol'\n\n/** @internal */\nexport const RoomSessionState = {\n\tAwaitingConnectMessage: 'awaiting-connect-message',\n\tAwaitingRemoval: 'awaiting-removal',\n\tConnected: 'connected',\n} as const\n\n/** @internal */\nexport type RoomSessionState = (typeof RoomSessionState)[keyof typeof RoomSessionState]\n\nexport const SESSION_START_WAIT_TIME = 10000\nexport const SESSION_REMOVAL_WAIT_TIME = 10000\nexport const SESSION_IDLE_TIMEOUT = 20000\n\n/** @internal */\nexport type RoomSession<R extends UnknownRecord, Meta> =\n\t| {\n\t\t\tstate: typeof RoomSessionState.AwaitingConnectMessage\n\t\t\tsessionId: string\n\t\t\tpresenceId: string | null\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\tsessionStartTime: number\n\t\t\tmeta: Meta\n\t\t\tisReadonly: boolean\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n\t| {\n\t\t\tstate: typeof RoomSessionState.AwaitingRemoval\n\t\t\tsessionId: string\n\t\t\tpresenceId: string | null\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\tcancellationTime: number\n\t\t\tmeta: Meta\n\t\t\tisReadonly: boolean\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n\t| {\n\t\t\tstate: typeof RoomSessionState.Connected\n\t\t\tsessionId: string\n\t\t\tpresenceId: string | null\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\tserializedSchema: SerializedSchema\n\t\t\tlastInteractionTime: number\n\t\t\tdebounceTimer: ReturnType<typeof setTimeout> | null\n\t\t\toutstandingDataMessages: TLSocketServerSentDataEvent<R>[]\n\t\t\tmeta: Meta\n\t\t\tisReadonly: boolean\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n", "import { TLSyncErrorCloseEventReason } from './TLSyncClient'\n\n/** @public */\nexport class TLRemoteSyncError extends Error {\n\toverride name = 'RemoteSyncError'\n\tconstructor(public readonly reason: TLSyncErrorCloseEventReason | string) {\n\t\tsuper(`sync error: ${reason}`)\n\t}\n}\n", "import type { StoreSchema, UnknownRecord } from '@tldraw/store'\nimport { TLStoreSnapshot, createTLSchema } from '@tldraw/tlschema'\nimport { objectMapValues, structuredClone } from '@tldraw/utils'\nimport { RoomSessionState } from './RoomSession'\nimport { ServerSocketAdapter, WebSocketMinimal } from './ServerSocketAdapter'\nimport { TLSyncErrorCloseEventReason } from './TLSyncClient'\nimport { RoomSnapshot, RoomStoreMethods, TLSyncRoom } from './TLSyncRoom'\nimport { JsonChunkAssembler } from './chunk'\nimport { TLSocketServerSentEvent } from './protocol'\n\n// TODO: structured logging support\n/** @public */\nexport interface TLSyncLog {\n\twarn?(...args: any[]): void\n\terror?(...args: any[]): void\n}\n\n/** @public */\nexport class TLSocketRoom<R extends UnknownRecord = UnknownRecord, SessionMeta = void> {\n\tprivate room: TLSyncRoom<R, SessionMeta>\n\tprivate readonly sessions = new Map<\n\t\tstring,\n\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t{ assembler: JsonChunkAssembler; socket: WebSocketMinimal; unlisten: () => void }\n\t>()\n\treadonly log?: TLSyncLog\n\n\tconstructor(\n\t\tpublic readonly opts: {\n\t\t\tinitialSnapshot?: RoomSnapshot | TLStoreSnapshot\n\t\t\tschema?: StoreSchema<R, any>\n\t\t\t// how long to wait for a client to communicate before disconnecting them\n\t\t\tclientTimeout?: number\n\t\t\tlog?: TLSyncLog\n\t\t\t// a callback that is called when a client is disconnected\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonSessionRemoved?: (\n\t\t\t\troom: TLSocketRoom<R, SessionMeta>,\n\t\t\t\targs: { sessionId: string; numSessionsRemaining: number; meta: SessionMeta }\n\t\t\t) => void\n\t\t\t// a callback that is called whenever a message is sent\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonBeforeSendMessage?: (args: {\n\t\t\t\tsessionId: string\n\t\t\t\t/** @internal keep the protocol private for now */\n\t\t\t\tmessage: TLSocketServerSentEvent<R>\n\t\t\t\tstringified: string\n\t\t\t\tmeta: SessionMeta\n\t\t\t}) => void\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonAfterReceiveMessage?: (args: {\n\t\t\t\tsessionId: string\n\t\t\t\t/** @internal keep the protocol private for now */\n\t\t\t\tmessage: TLSocketServerSentEvent<R>\n\t\t\t\tstringified: string\n\t\t\t\tmeta: SessionMeta\n\t\t\t}) => void\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonDataChange?: () => void\n\t\t}\n\t) {\n\t\tconst initialSnapshot =\n\t\t\topts.initialSnapshot && 'store' in opts.initialSnapshot\n\t\t\t\t? convertStoreSnapshotToRoomSnapshot(opts.initialSnapshot!)\n\t\t\t\t: opts.initialSnapshot\n\n\t\tthis.room = new TLSyncRoom<R, SessionMeta>({\n\t\t\tschema: opts.schema ?? (createTLSchema() as any),\n\t\t\tsnapshot: initialSnapshot,\n\t\t\tonDataChange: opts.onDataChange,\n\t\t\tlog: opts.log,\n\t\t})\n\t\tthis.room.events.on('session_removed', (args) => {\n\t\t\tthis.sessions.delete(args.sessionId)\n\t\t\tif (this.opts.onSessionRemoved) {\n\t\t\t\tthis.opts.onSessionRemoved(this, {\n\t\t\t\t\tsessionId: args.sessionId,\n\t\t\t\t\tnumSessionsRemaining: this.room.sessions.size,\n\t\t\t\t\tmeta: args.meta,\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t\tthis.log = 'log' in opts ? opts.log : { error: console.error }\n\t}\n\n\t/**\n\t * Returns the number of active sessions.\n\t * Note that this is not the same as the number of connected sockets!\n\t * Sessions time out a few moments after sockets close, to smooth over network hiccups.\n\t *\n\t * @returns the number of active sessions\n\t */\n\tgetNumActiveSessions() {\n\t\treturn this.room.sessions.size\n\t}\n\n\t/**\n\t * Call this when a client establishes a new socket connection.\n\t *\n\t * - `sessionId` is a unique ID for a browser tab. This is passed as a query param by the useSync hook.\n\t * - `socket` is a WebSocket-like object that the server uses to communicate with the client.\n\t * - `isReadonly` is an optional boolean that can be set to true if the client should not be able to make changes to the document. They will still be able to send presence updates.\n\t * - `meta` is an optional object that can be used to store additional information about the session.\n\t *\n\t * @param opts - The options object\n\t */\n\thandleSocketConnect(\n\t\topts: {\n\t\t\tsessionId: string\n\t\t\tsocket: WebSocketMinimal\n\t\t\tisReadonly?: boolean\n\t\t} & (SessionMeta extends void ? object : { meta: SessionMeta })\n\t) {\n\t\tconst { sessionId, socket, isReadonly = false } = opts\n\t\tconst handleSocketMessage = (event: MessageEvent) =>\n\t\t\tthis.handleSocketMessage(sessionId, event.data)\n\t\tconst handleSocketError = this.handleSocketError.bind(this, sessionId)\n\t\tconst handleSocketClose = this.handleSocketClose.bind(this, sessionId)\n\n\t\tthis.sessions.set(sessionId, {\n\t\t\tassembler: new JsonChunkAssembler(),\n\t\t\tsocket,\n\t\t\tunlisten: () => {\n\t\t\t\tsocket.removeEventListener?.('message', handleSocketMessage)\n\t\t\t\tsocket.removeEventListener?.('close', handleSocketClose)\n\t\t\t\tsocket.removeEventListener?.('error', handleSocketError)\n\t\t\t},\n\t\t})\n\n\t\tthis.room.handleNewSession({\n\t\t\tsessionId,\n\t\t\tisReadonly,\n\t\t\tsocket: new ServerSocketAdapter({\n\t\t\t\tws: socket,\n\t\t\t\tonBeforeSendMessage: this.opts.onBeforeSendMessage\n\t\t\t\t\t? (message, stringified) =>\n\t\t\t\t\t\t\tthis.opts.onBeforeSendMessage!({\n\t\t\t\t\t\t\t\tsessionId,\n\t\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\t\tstringified,\n\t\t\t\t\t\t\t\tmeta: this.room.sessions.get(sessionId)?.meta as SessionMeta,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t: undefined,\n\t\t\t}),\n\t\t\tmeta: 'meta' in opts ? (opts.meta as any) : undefined,\n\t\t})\n\n\t\tsocket.addEventListener?.('message', handleSocketMessage)\n\t\tsocket.addEventListener?.('close', handleSocketClose)\n\t\tsocket.addEventListener?.('error', handleSocketError)\n\t}\n\n\t/**\n\t * If executing in a server environment where sockets do not have instance-level listeners\n\t * (e.g. Bun.serve, Cloudflare Worker with WebSocket hibernation), you should call this\n\t * method when messages are received. See our self-hosting example for Bun.serve for an example.\n\t *\n\t * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)\n\t * @param message - The message received from the client.\n\t */\n\thandleSocketMessage(sessionId: string, message: string | AllowSharedBufferSource) {\n\t\tconst assembler = this.sessions.get(sessionId)?.assembler\n\t\tif (!assembler) {\n\t\t\tthis.log?.warn?.('Received message from unknown session', sessionId)\n\t\t\treturn\n\t\t}\n\n\t\ttry {\n\t\t\tconst messageString =\n\t\t\t\ttypeof message === 'string' ? message : new TextDecoder().decode(message)\n\t\t\tconst res = assembler.handleMessage(messageString)\n\t\t\tif (!res) {\n\t\t\t\t// not enough chunks yet\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif ('data' in res) {\n\t\t\t\t// need to do this first in case the session gets removed as a result of handling the message\n\t\t\t\tif (this.opts.onAfterReceiveMessage) {\n\t\t\t\t\tconst session = this.room.sessions.get(sessionId)\n\t\t\t\t\tif (session) {\n\t\t\t\t\t\tthis.opts.onAfterReceiveMessage({\n\t\t\t\t\t\t\tsessionId,\n\t\t\t\t\t\t\tmessage: res.data as any,\n\t\t\t\t\t\t\tstringified: res.stringified,\n\t\t\t\t\t\t\tmeta: session.meta,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.room.handleMessage(sessionId, res.data as any)\n\t\t\t} else {\n\t\t\t\tthis.log?.error?.('Error assembling message', res.error)\n\t\t\t\t// close the socket to reset the connection\n\t\t\t\tthis.handleSocketError(sessionId)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.log?.error?.(e)\n\t\t\t// here we use rejectSession rather than removeSession to support legacy clients\n\t\t\t// that use the old incompatibility_error close event\n\t\t\tthis.room.rejectSession(sessionId, TLSyncErrorCloseEventReason.UNKNOWN_ERROR)\n\t\t}\n\t}\n\n\t/**\n\t * If executing in a server environment where sockets do not have instance-level listeners,\n\t * call this when a socket error occurs.\n\t * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)\n\t */\n\thandleSocketError(sessionId: string) {\n\t\tthis.room.handleClose(sessionId)\n\t}\n\n\t/**\n\t * If executing in a server environment where sockets do not have instance-level listeners,\n\t * call this when a socket is closed.\n\t * @param sessionId - The id of the session. (should match the one used when calling handleSocketConnect)\n\t */\n\thandleSocketClose(sessionId: string) {\n\t\tthis.room.handleClose(sessionId)\n\t}\n\n\t/**\n\t * Returns the current 'clock' of the document.\n\t * The clock is an integer that increments every time the document changes.\n\t * The clock is stored as part of the snapshot of the document for consistency purposes.\n\t *\n\t * @returns The clock\n\t */\n\tgetCurrentDocumentClock() {\n\t\treturn this.room.documentClock\n\t}\n\n\t/**\n\t * Returns a deeply cloned record from the store, if available.\n\t * @param id - The id of the record\n\t * @returns the cloned record\n\t */\n\tgetRecord(id: string) {\n\t\treturn structuredClone(this.room.state.get().documents[id]?.state)\n\t}\n\n\t/**\n\t * Returns a list of the sessions in the room.\n\t */\n\tgetSessions(): Array<{\n\t\tsessionId: string\n\t\tisConnected: boolean\n\t\tisReadonly: boolean\n\t\tmeta: SessionMeta\n\t}> {\n\t\treturn [...this.room.sessions.values()].map((session) => {\n\t\t\treturn {\n\t\t\t\tsessionId: session.sessionId,\n\t\t\t\tisConnected: session.state === RoomSessionState.Connected,\n\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\tmeta: session.meta,\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Return a snapshot of the document state, including clock-related bookkeeping.\n\t * You can store this and load it later on when initializing a TLSocketRoom.\n\t * You can also pass a snapshot to {@link TLSocketRoom#loadSnapshot} if you need to revert to a previous state.\n\t * @returns The snapshot\n\t */\n\tgetCurrentSnapshot() {\n\t\treturn this.room.getSnapshot()\n\t}\n\n\t/**\n\t * Load a snapshot of the document state, overwriting the current state.\n\t * @param snapshot - The snapshot to load\n\t */\n\tloadSnapshot(snapshot: RoomSnapshot | TLStoreSnapshot) {\n\t\tif ('store' in snapshot) {\n\t\t\tsnapshot = convertStoreSnapshotToRoomSnapshot(snapshot)\n\t\t}\n\t\tconst oldRoom = this.room\n\t\tconst oldIds = oldRoom.getSnapshot().documents.map((d) => d.state.id)\n\t\tconst newIds = new Set(snapshot.documents.map((d) => d.state.id))\n\t\tconst removedIds = oldIds.filter((id) => !newIds.has(id))\n\n\t\tconst tombstones = { ...snapshot.tombstones }\n\t\tremovedIds.forEach((id) => {\n\t\t\ttombstones[id] = oldRoom.clock + 1\n\t\t})\n\t\tnewIds.forEach((id) => {\n\t\t\tdelete tombstones[id]\n\t\t})\n\n\t\tconst newRoom = new TLSyncRoom<R, SessionMeta>({\n\t\t\tschema: oldRoom.schema,\n\t\t\tsnapshot: {\n\t\t\t\tclock: oldRoom.clock + 1,\n\t\t\t\tdocuments: snapshot.documents.map((d) => ({\n\t\t\t\t\tlastChangedClock: oldRoom.clock + 1,\n\t\t\t\t\tstate: d.state,\n\t\t\t\t})),\n\t\t\t\tschema: snapshot.schema,\n\t\t\t\ttombstones,\n\t\t\t},\n\t\t\tlog: this.log,\n\t\t})\n\n\t\t// replace room with new one and kick out all the clients\n\t\tthis.room = newRoom\n\t\toldRoom.close()\n\t}\n\n\t/**\n\t * Allow applying changes to the store inside of a transaction.\n\t *\n\t * You can get values from the store by id with `store.get(id)`.\n\t * These values are safe to mutate, but to commit the changes you must call `store.put(...)` with the updated value.\n\t * You can get all values in the store with `store.getAll()`.\n\t * You can also delete values with `store.delete(id)`.\n\t *\n\t * @example\n\t * ```ts\n\t * room.updateStore(store => {\n\t *   const shape = store.get('shape:abc123')\n\t *   shape.meta.approved = true\n\t *   store.put(shape)\n\t * })\n\t * ```\n\t *\n\t * Changes to the store inside the callback are isolated from changes made by other clients until the transaction commits.\n\t *\n\t * @param updater - A function that will be called with a store object that can be used to make changes.\n\t * @returns A promise that resolves when the transaction is complete.\n\t */\n\tasync updateStore(updater: (store: RoomStoreMethods<R>) => void | Promise<void>) {\n\t\treturn this.room.updateStore(updater)\n\t}\n\n\t/**\n\t * Immediately remove a session from the room, and close its socket if not already closed.\n\t *\n\t * The client will attempt to reconnect unless you provide a `fatalReason` parameter.\n\t *\n\t * The `fatalReason` parameter will be available in the return value of the `useSync` hook as `useSync().error.reason`.\n\t *\n\t * @param sessionId - The id of the session to remove\n\t * @param fatalReason - The reason message to use when calling .close on the underlying websocket\n\t */\n\tcloseSession(sessionId: string, fatalReason?: TLSyncErrorCloseEventReason | string) {\n\t\tthis.room.rejectSession(sessionId, fatalReason)\n\t}\n\n\t/**\n\t * Close the room and disconnect all clients. Call this before discarding the room instance or shutting down the server.\n\t */\n\tclose() {\n\t\tthis.room.close()\n\t}\n\n\t/**\n\t * @returns true if the room is closed\n\t */\n\tisClosed() {\n\t\treturn this.room.isClosed()\n\t}\n}\n\n/** @public */\nexport type OmitVoid<T, KS extends keyof T = keyof T> = {\n\t[K in KS extends any ? (void extends T[KS] ? never : KS) : never]: T[K]\n}\n\nfunction convertStoreSnapshotToRoomSnapshot(snapshot: TLStoreSnapshot): RoomSnapshot {\n\treturn {\n\t\tclock: 0,\n\t\tdocuments: objectMapValues(snapshot.store).map((state) => ({\n\t\t\tstate,\n\t\t\tlastChangedClock: 0,\n\t\t})),\n\t\tschema: snapshot.schema,\n\t\ttombstones: {},\n\t}\n}\n", "import { registerTldrawLibraryVersion } from '@tldraw/utils'\nexport {\n\ttype TLAssetContext,\n\ttype TLAssetStore,\n\ttype TLSerializedStore,\n\ttype TLStore,\n\ttype TLStoreProps,\n\ttype TLStoreSchema,\n\ttype TLStoreSnapshot,\n} from './TLStore'\nexport { assetIdValidator, createAssetValidator, type TLBaseAsset } from './assets/TLBaseAsset'\nexport { type TLBookmarkAsset } from './assets/TLBookmarkAsset'\nexport { type TLImageAsset } from './assets/TLImageAsset'\nexport { type TLVideoAsset } from './assets/TLVideoAsset'\nexport {\n\tarrowBindingMigrations,\n\tarrowBindingProps,\n\ttype TLArrowBinding,\n\ttype TLArrowBindingProps,\n} from './bindings/TLArrowBinding'\nexport {\n\tbindingIdValidator,\n\tcreateBindingValidator,\n\ttype TLBaseBinding,\n} from './bindings/TLBaseBinding'\nexport { createPresenceStateDerivation } from './createPresenceStateDerivation'\nexport {\n\tcreateTLSchema,\n\tdefaultBindingSchemas,\n\tdefaultShapeSchemas,\n\ttype SchemaPropsInfo,\n\ttype TLSchema,\n} from './createTLSchema'\nexport {\n\tTL_CANVAS_UI_COLOR_TYPES,\n\tcanvasUiColorTypeValidator,\n\ttype TLCanvasUiColor,\n} from './misc/TLColor'\nexport { TL_CURSOR_TYPES, type TLCursor, type TLCursorType } from './misc/TLCursor'\nexport { TL_HANDLE_TYPES, type TLHandle, type TLHandleType } from './misc/TLHandle'\nexport { opacityValidator, type TLOpacityType } from './misc/TLOpacity'\nexport { TL_SCRIBBLE_STATES, scribbleValidator, type TLScribble } from './misc/TLScribble'\nexport {\n\tboxModelValidator,\n\tvecModelValidator,\n\ttype BoxModel,\n\ttype VecModel,\n} from './misc/geometry-types'\nexport { idValidator } from './misc/id-validator'\nexport {\n\tAssetRecordType,\n\tassetMigrations,\n\tassetValidator,\n\ttype TLAsset,\n\ttype TLAssetId,\n\ttype TLAssetPartial,\n\ttype TLAssetShape,\n} from './records/TLAsset'\nexport {\n\tcreateBindingId,\n\tcreateBindingPropsMigrationIds,\n\tcreateBindingPropsMigrationSequence,\n\tisBinding,\n\tisBindingId,\n\trootBindingMigrations,\n\ttype TLBinding,\n\ttype TLBindingCreate,\n\ttype TLBindingId,\n\ttype TLBindingUpdate,\n\ttype TLDefaultBinding,\n\ttype TLUnknownBinding,\n} from './records/TLBinding'\nexport { CameraRecordType, type TLCamera, type TLCameraId } from './records/TLCamera'\nexport { DocumentRecordType, TLDOCUMENT_ID, type TLDocument } from './records/TLDocument'\nexport {\n\tTLINSTANCE_ID,\n\tpluckPreservingValues,\n\ttype TLInstance,\n\ttype TLInstanceId,\n} from './records/TLInstance'\nexport {\n\tPageRecordType,\n\tisPageId,\n\tpageIdValidator,\n\ttype TLPage,\n\ttype TLPageId,\n} from './records/TLPage'\nexport {\n\tInstancePageStateRecordType,\n\ttype TLInstancePageState,\n\ttype TLInstancePageStateId,\n} from './records/TLPageState'\nexport {\n\tPointerRecordType,\n\tTLPOINTER_ID,\n\ttype TLPointer,\n\ttype TLPointerId,\n} from './records/TLPointer'\nexport {\n\tInstancePresenceRecordType,\n\ttype TLInstancePresence,\n\ttype TLInstancePresenceID,\n} from './records/TLPresence'\nexport { type TLRecord } from './records/TLRecord'\nexport {\n\tcreateShapeId,\n\tcreateShapePropsMigrationIds,\n\tcreateShapePropsMigrationSequence,\n\tgetShapePropKeysByStyle,\n\tisShape,\n\tisShapeId,\n\trootShapeMigrations,\n\ttype TLDefaultShape,\n\ttype TLParentId,\n\ttype TLShape,\n\ttype TLShapeId,\n\ttype TLShapePartial,\n\ttype TLUnknownShape,\n} from './records/TLShape'\nexport {\n\ttype RecordProps,\n\ttype RecordPropsType,\n\ttype TLPropsMigration,\n\ttype TLPropsMigrations,\n} from './recordsWithProps'\nexport {\n\tArrowShapeArrowheadEndStyle,\n\tArrowShapeArrowheadStartStyle,\n\tarrowShapeMigrations,\n\tarrowShapeProps,\n\ttype TLArrowShape,\n\ttype TLArrowShapeArrowheadStyle,\n\ttype TLArrowShapeProps,\n} from './shapes/TLArrowShape'\nexport {\n\tcreateShapeValidator,\n\tparentIdValidator,\n\tshapeIdValidator,\n\ttype TLBaseShape,\n} from './shapes/TLBaseShape'\nexport {\n\tbookmarkShapeMigrations,\n\tbookmarkShapeProps,\n\ttype TLBookmarkShape,\n\ttype TLBookmarkShapeProps,\n} from './shapes/TLBookmarkShape'\nexport {\n\tdrawShapeMigrations,\n\tdrawShapeProps,\n\ttype TLDrawShape,\n\ttype TLDrawShapeProps,\n\ttype TLDrawShapeSegment,\n} from './shapes/TLDrawShape'\nexport {\n\tembedShapeMigrations,\n\tembedShapeProps,\n\ttype TLEmbedShape,\n\ttype TLEmbedShapeProps,\n} from './shapes/TLEmbedShape'\nexport {\n\tframeShapeMigrations,\n\tframeShapeProps,\n\ttype TLFrameShape,\n\ttype TLFrameShapeProps,\n} from './shapes/TLFrameShape'\nexport {\n\tGeoShapeGeoStyle,\n\tgeoShapeMigrations,\n\tgeoShapeProps,\n\ttype TLGeoShape,\n\ttype TLGeoShapeGeoStyle,\n\ttype TLGeoShapeProps,\n} from './shapes/TLGeoShape'\nexport {\n\tgroupShapeMigrations,\n\tgroupShapeProps,\n\ttype TLGroupShape,\n\ttype TLGroupShapeProps,\n} from './shapes/TLGroupShape'\nexport {\n\thighlightShapeMigrations,\n\thighlightShapeProps,\n\ttype TLHighlightShape,\n\ttype TLHighlightShapeProps,\n} from './shapes/TLHighlightShape'\nexport {\n\tImageShapeCrop,\n\timageShapeMigrations,\n\timageShapeProps,\n\ttype TLImageShape,\n\ttype TLImageShapeCrop,\n\ttype TLImageShapeProps,\n} from './shapes/TLImageShape'\nexport {\n\tLineShapeSplineStyle,\n\tlineShapeMigrations,\n\tlineShapeProps,\n\ttype TLLineShape,\n\ttype TLLineShapePoint,\n\ttype TLLineShapeProps,\n\ttype TLLineShapeSplineStyle,\n} from './shapes/TLLineShape'\nexport {\n\tnoteShapeMigrations,\n\tnoteShapeProps,\n\ttype TLNoteShape,\n\ttype TLNoteShapeProps,\n} from './shapes/TLNoteShape'\nexport {\n\ttextShapeMigrations,\n\ttextShapeProps,\n\ttype TLTextShape,\n\ttype TLTextShapeProps,\n} from './shapes/TLTextShape'\nexport {\n\tvideoShapeMigrations,\n\tvideoShapeProps,\n\ttype TLVideoShape,\n\ttype TLVideoShapeProps,\n} from './shapes/TLVideoShape'\nexport { EnumStyleProp, StyleProp, type StylePropValue } from './styles/StyleProp'\nexport {\n\tDefaultColorStyle,\n\tDefaultColorThemePalette,\n\tdefaultColorNames,\n\tgetDefaultColorTheme,\n\ttype TLDefaultColorStyle,\n\ttype TLDefaultColorTheme,\n\ttype TLDefaultColorThemeColor,\n} from './styles/TLColorStyle'\nexport { DefaultDashStyle, type TLDefaultDashStyle } from './styles/TLDashStyle'\nexport { DefaultFillStyle, type TLDefaultFillStyle } from './styles/TLFillStyle'\nexport {\n\tDefaultFontFamilies,\n\tDefaultFontStyle,\n\ttype TLDefaultFontStyle,\n} from './styles/TLFontStyle'\nexport {\n\tDefaultHorizontalAlignStyle,\n\ttype TLDefaultHorizontalAlignStyle,\n} from './styles/TLHorizontalAlignStyle'\nexport { DefaultSizeStyle, type TLDefaultSizeStyle } from './styles/TLSizeStyle'\nexport { DefaultTextAlignStyle, type TLDefaultTextAlignStyle } from './styles/TLTextAlignStyle'\nexport {\n\tDefaultVerticalAlignStyle,\n\ttype TLDefaultVerticalAlignStyle,\n} from './styles/TLVerticalAlignStyle'\nexport {\n\tLANGUAGES,\n\tgetDefaultTranslationLocale,\n\ttype TLLanguage,\n} from './translations/translations'\nexport { type SetValue } from './util-types'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n", "import { BaseRecord } from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\nimport { TLAssetId } from '../records/TLAsset'\n\n/** @public */\nexport interface TLBaseAsset<Type extends string, Props> extends BaseRecord<'asset', TLAssetId> {\n\ttype: Type\n\tprops: Props\n\tmeta: JsonObject\n}\n\n/**\n * A validator for asset record type Ids.\n *\n * @public */\nexport const assetIdValidator = idValidator<TLAssetId>('asset')\n\n/**\n * Create a validator for an asset record type.\n *\n * @param type - The type of the asset\n * @param props - The validator for the asset's props\n *\n * @public */\nexport function createAssetValidator<Type extends string, Props extends JsonObject>(\n\ttype: Type,\n\tprops: T.Validator<Props>\n) {\n\treturn T.object<{\n\t\tid: TLAssetId\n\t\ttypeName: 'asset'\n\t\ttype: Type\n\t\tprops: Props\n\t\tmeta: JsonObject\n\t}>({\n\t\tid: assetIdValidator,\n\t\ttypeName: T.literal('asset'),\n\t\ttype: T.literal(type),\n\t\tprops,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n}\n", "import { registerTldrawLibraryVersion } from '@tldraw/utils'\nimport * as T from './lib/validation'\n\nexport {\n\tArrayOfValidator,\n\tDictValidator,\n\tObjectValidator,\n\tUnionValidator,\n\tValidator,\n\ttype ExtractOptionalKeys,\n\ttype ExtractRequiredKeys,\n\ttype UnionValidatorConfig,\n} from './lib/validation'\nexport { T }\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n", "import {\n\tExpand,\n\tIndexKey,\n\tJsonValue,\n\tSTRUCTURED_CLONE_OBJECT_PROTOTYPE,\n\texhaustiveSwitchError,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tvalidateIndexKey,\n} from '@tldraw/utils'\n\n/** @public */\nexport type ValidatorFn<T> = (value: unknown) => T\n/** @public */\nexport type ValidatorUsingKnownGoodVersionFn<In, Out = In> = (\n\tknownGoodValue: In,\n\tvalue: unknown\n) => Out\n\n/** @public */\nexport interface Validatable<T> {\n\tvalidate(value: unknown): T\n\t/**\n\t * This is a performance optimizing version of validate that can use a previous\n\t * version of the value to avoid revalidating every part of the new value if\n\t * any part of it has not changed since the last validation.\n\t *\n\t * If the value has not changed but is not referentially equal, the function\n\t * should return the previous value.\n\t * @returns\n\t */\n\tvalidateUsingKnownGoodVersion?(knownGoodValue: T, newValue: unknown): T\n}\n\nfunction formatPath(path: ReadonlyArray<number | string>): string | null {\n\tif (!path.length) {\n\t\treturn null\n\t}\n\n\tlet formattedPath = ''\n\tfor (const item of path) {\n\t\tif (typeof item === 'number') {\n\t\t\tformattedPath += `.${item}`\n\t\t} else if (item.startsWith('(')) {\n\t\t\tif (formattedPath.endsWith(')')) {\n\t\t\t\tformattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`\n\t\t\t} else {\n\t\t\t\tformattedPath += item\n\t\t\t}\n\t\t} else {\n\t\t\tformattedPath += `.${item}`\n\t\t}\n\t}\n\n\t// N.B. We don't want id's in the path because they make grouping in Sentry tough.\n\tformattedPath = formattedPath.replace(/id = [^,]+, /, '').replace(/id = [^)]+/, '')\n\n\tif (formattedPath.startsWith('.')) {\n\t\treturn formattedPath.slice(1)\n\t}\n\treturn formattedPath\n}\n\n/** @public */\nexport class ValidationError extends Error {\n\toverride name = 'ValidationError'\n\n\tconstructor(\n\t\tpublic readonly rawMessage: string,\n\t\tpublic readonly path: ReadonlyArray<number | string> = []\n\t) {\n\t\tconst formattedPath = formatPath(path)\n\t\tconst indentedMessage = rawMessage\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => (i === 0 ? line : `  ${line}`))\n\t\t\t.join('\\n')\n\t\tsuper(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage)\n\t}\n}\n\nfunction prefixError<T>(path: string | number, fn: () => T): T {\n\ttry {\n\t\treturn fn()\n\t} catch (err) {\n\t\tif (err instanceof ValidationError) {\n\t\t\tthrow new ValidationError(err.rawMessage, [path, ...err.path])\n\t\t}\n\t\tthrow new ValidationError((err as Error).toString(), [path])\n\t}\n}\n\nfunction typeToString(value: unknown): string {\n\tif (value === null) return 'null'\n\tif (Array.isArray(value)) return 'an array'\n\tconst type = typeof value\n\tswitch (type) {\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\tcase 'function':\n\t\tcase 'number':\n\t\tcase 'string':\n\t\tcase 'symbol':\n\t\t\treturn `a ${type}`\n\t\tcase 'object':\n\t\t\treturn `an ${type}`\n\t\tcase 'undefined':\n\t\t\treturn 'undefined'\n\t\tdefault:\n\t\t\texhaustiveSwitchError(type)\n\t}\n}\n\n/** @public */\nexport type TypeOf<V extends Validatable<any>> = V extends Validatable<infer T> ? T : never\n\n/** @public */\nexport class Validator<T> implements Validatable<T> {\n\tconstructor(\n\t\treadonly validationFn: ValidatorFn<T>,\n\t\treadonly validateUsingKnownGoodVersionFn?: ValidatorUsingKnownGoodVersionFn<T>\n\t) {}\n\n\t/**\n\t * Asserts that the passed value is of the correct type and returns it. The returned value is\n\t * guaranteed to be referentially equal to the passed value.\n\t */\n\tvalidate(value: unknown): T {\n\t\tconst validated = this.validationFn(value)\n\t\tif (process.env.NODE_ENV !== 'production' && !Object.is(value, validated)) {\n\t\t\tthrow new ValidationError('Validator functions must return the same value they were passed')\n\t\t}\n\t\treturn validated\n\t}\n\n\tvalidateUsingKnownGoodVersion(knownGoodValue: T, newValue: unknown): T {\n\t\tif (Object.is(knownGoodValue, newValue)) {\n\t\t\treturn knownGoodValue as T\n\t\t}\n\n\t\tif (this.validateUsingKnownGoodVersionFn) {\n\t\t\treturn this.validateUsingKnownGoodVersionFn(knownGoodValue, newValue)\n\t\t}\n\n\t\treturn this.validate(newValue)\n\t}\n\n\t/** Checks that the passed value is of the correct type. */\n\tisValid(value: unknown): value is T {\n\t\ttry {\n\t\t\tthis.validate(value)\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new validator that also accepts null or undefined. The resulting value will always be\n\t * null.\n\t */\n\tnullable(): Validator<T | null> {\n\t\treturn nullable(this)\n\t}\n\n\t/**\n\t * Returns a new validator that also accepts null or undefined. The resulting value will always be\n\t * null.\n\t */\n\toptional(): Validator<T | undefined> {\n\t\treturn optional(this)\n\t}\n\n\t/**\n\t * Refine this validation to a new type. The passed-in validation function should throw an error\n\t * if the value can't be converted to the new type, or return the new type otherwise.\n\t */\n\trefine<U>(otherValidationFn: (value: T) => U): Validator<U> {\n\t\treturn new Validator(\n\t\t\t(value) => {\n\t\t\t\treturn otherValidationFn(this.validate(value))\n\t\t\t},\n\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tconst validated = this.validateUsingKnownGoodVersion(knownGoodValue as any, newValue)\n\t\t\t\tif (Object.is(knownGoodValue, validated)) {\n\t\t\t\t\treturn knownGoodValue\n\t\t\t\t}\n\t\t\t\treturn otherValidationFn(validated)\n\t\t\t}\n\t\t)\n\t}\n\n\t/**\n\t * Refine this validation with an additional check that doesn't change the resulting value.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const numberLessThan10Validator = T.number.check((value) => {\n\t * \tif (value >= 10) {\n\t * \t\tthrow new ValidationError(`Expected number less than 10, got ${value}`)\n\t * \t}\n\t * })\n\t * ```\n\t */\n\tcheck(name: string, checkFn: (value: T) => void): Validator<T>\n\tcheck(checkFn: (value: T) => void): Validator<T>\n\tcheck(nameOrCheckFn: string | ((value: T) => void), checkFn?: (value: T) => void): Validator<T> {\n\t\tif (typeof nameOrCheckFn === 'string') {\n\t\t\treturn this.refine((value) => {\n\t\t\t\tprefixError(`(check ${nameOrCheckFn})`, () => checkFn!(value))\n\t\t\t\treturn value\n\t\t\t})\n\t\t} else {\n\t\t\treturn this.refine((value) => {\n\t\t\t\tnameOrCheckFn(value)\n\t\t\t\treturn value\n\t\t\t})\n\t\t}\n\t}\n}\n\n/** @public */\nexport class ArrayOfValidator<T> extends Validator<T[]> {\n\tconstructor(readonly itemValidator: Validatable<T>) {\n\t\tsuper(\n\t\t\t(value) => {\n\t\t\t\tconst arr = array.validate(value)\n\t\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\t\tprefixError(i, () => itemValidator.validate(arr[i]))\n\t\t\t\t}\n\t\t\t\treturn arr as T[]\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (!itemValidator.validateUsingKnownGoodVersion) return this.validate(newValue)\n\t\t\t\tconst arr = array.validate(newValue)\n\t\t\t\tlet isDifferent = knownGoodValue.length !== arr.length\n\t\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\t\tconst item = arr[i]\n\t\t\t\t\tif (i >= knownGoodValue.length) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tprefixError(i, () => itemValidator.validate(item))\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(knownGoodValue[i], item)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checkedItem = prefixError(i, () =>\n\t\t\t\t\t\titemValidator.validateUsingKnownGoodVersion!(knownGoodValue[i], item)\n\t\t\t\t\t)\n\t\t\t\t\tif (!Object.is(checkedItem, knownGoodValue[i])) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as T[]) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n\n\tnonEmpty() {\n\t\treturn this.check((value) => {\n\t\t\tif (value.length === 0) {\n\t\t\t\tthrow new ValidationError('Expected a non-empty array')\n\t\t\t}\n\t\t})\n\t}\n\n\tlengthGreaterThan1() {\n\t\treturn this.check((value) => {\n\t\t\tif (value.length <= 1) {\n\t\t\t\tthrow new ValidationError('Expected an array with length greater than 1')\n\t\t\t}\n\t\t})\n\t}\n}\n\n/** @public */\nexport class ObjectValidator<Shape extends object> extends Validator<Shape> {\n\tconstructor(\n\t\tpublic readonly config: {\n\t\t\treadonly [K in keyof Shape]: Validatable<Shape[K]>\n\t\t},\n\t\tprivate readonly shouldAllowUnknownProperties = false\n\t) {\n\t\tsuper(\n\t\t\t(object) => {\n\t\t\t\tif (typeof object !== 'object' || object === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(object)}`)\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, validator] of Object.entries(config)) {\n\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\t;(validator as Validatable<unknown>).validate(getOwnProperty(object, key))\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (!shouldAllowUnknownProperties) {\n\t\t\t\t\tfor (const key of Object.keys(object)) {\n\t\t\t\t\t\tif (!hasOwnProperty(config, key)) {\n\t\t\t\t\t\t\tthrow new ValidationError(`Unexpected property`, [key])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn object as Shape\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (typeof newValue !== 'object' || newValue === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(newValue)}`)\n\t\t\t\t}\n\n\t\t\t\tlet isDifferent = false\n\n\t\t\t\tfor (const [key, validator] of Object.entries(config)) {\n\t\t\t\t\tconst prev = getOwnProperty(knownGoodValue, key)\n\t\t\t\t\tconst next = getOwnProperty(newValue, key)\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checked = prefixError(key, () => {\n\t\t\t\t\t\tconst validatable = validator as Validatable<unknown>\n\t\t\t\t\t\tif (validatable.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\t\treturn validatable.validateUsingKnownGoodVersion(prev, next)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn validatable.validate(next)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!shouldAllowUnknownProperties) {\n\t\t\t\t\tfor (const key of Object.keys(newValue)) {\n\t\t\t\t\t\tif (!hasOwnProperty(config, key)) {\n\t\t\t\t\t\t\tthrow new ValidationError(`Unexpected property`, [key])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as Shape) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n\n\tallowUnknownProperties() {\n\t\treturn new ObjectValidator(this.config, true)\n\t}\n\n\t/**\n\t * Extend an object validator by adding additional properties.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const animalValidator = T.object({\n\t * \tname: T.string,\n\t * })\n\t * const catValidator = animalValidator.extend({\n\t * \tmeowVolume: T.number,\n\t * })\n\t * ```\n\t */\n\textend<Extension extends Record<string, unknown>>(extension: {\n\t\treadonly [K in keyof Extension]: Validatable<Extension[K]>\n\t}): ObjectValidator<Shape & Extension> {\n\t\treturn new ObjectValidator({ ...this.config, ...extension }) as any as ObjectValidator<\n\t\t\tShape & Extension\n\t\t>\n\t}\n}\n\n// pass this into itself e.g. Config extends UnionObjectSchemaConfig<Key, Config>\n/** @public */\nexport type UnionValidatorConfig<Key extends string, Config> = {\n\treadonly [Variant in keyof Config]: Validatable<any> & {\n\t\tvalidate(input: any): { readonly [K in Key]: Variant }\n\t}\n}\n/** @public */\nexport class UnionValidator<\n\tKey extends string,\n\tConfig extends UnionValidatorConfig<Key, Config>,\n\tUnknownValue = never,\n> extends Validator<TypeOf<Config[keyof Config]> | UnknownValue> {\n\tconstructor(\n\t\tprivate readonly key: Key,\n\t\tprivate readonly config: Config,\n\t\tprivate readonly unknownValueValidation: (value: object, variant: string) => UnknownValue,\n\t\tprivate readonly useNumberKeys: boolean\n\t) {\n\t\tsuper(\n\t\t\t(input) => {\n\t\t\t\tthis.expectObject(input)\n\n\t\t\t\tconst { matchingSchema, variant } = this.getMatchingSchemaAndVariant(input)\n\t\t\t\tif (matchingSchema === undefined) {\n\t\t\t\t\treturn this.unknownValueValidation(input, variant)\n\t\t\t\t}\n\n\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input))\n\t\t\t},\n\t\t\t(prevValue, newValue) => {\n\t\t\t\tthis.expectObject(newValue)\n\t\t\t\tthis.expectObject(prevValue)\n\n\t\t\t\tconst { matchingSchema, variant } = this.getMatchingSchemaAndVariant(newValue)\n\t\t\t\tif (matchingSchema === undefined) {\n\t\t\t\t\treturn this.unknownValueValidation(newValue, variant)\n\t\t\t\t}\n\n\t\t\t\tif (getOwnProperty(prevValue, key) !== getOwnProperty(newValue, key)) {\n\t\t\t\t\t// the type has changed so bail out and do a regular validation\n\t\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(newValue))\n\t\t\t\t}\n\n\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => {\n\t\t\t\t\tif (matchingSchema.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\treturn matchingSchema.validateUsingKnownGoodVersion(prevValue, newValue)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn matchingSchema.validate(newValue)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t)\n\t}\n\n\tprivate expectObject(value: unknown): asserts value is object {\n\t\tif (typeof value !== 'object' || value === null) {\n\t\t\tthrow new ValidationError(`Expected an object, got ${typeToString(value)}`, [])\n\t\t}\n\t}\n\n\tprivate getMatchingSchemaAndVariant(object: object): {\n\t\tmatchingSchema: Validatable<any> | undefined\n\t\tvariant: string\n\t} {\n\t\tconst variant = getOwnProperty(object, this.key) as string & keyof Config\n\t\tif (!this.useNumberKeys && typeof variant !== 'string') {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected a string for key \"${this.key}\", got ${typeToString(variant)}`\n\t\t\t)\n\t\t} else if (this.useNumberKeys && !Number.isFinite(Number(variant))) {\n\t\t\tthrow new ValidationError(`Expected a number for key \"${this.key}\", got \"${variant as any}\"`)\n\t\t}\n\n\t\tconst matchingSchema = hasOwnProperty(this.config, variant) ? this.config[variant] : undefined\n\t\treturn { matchingSchema, variant }\n\t}\n\n\tvalidateUnknownVariants<Unknown>(\n\t\tunknownValueValidation: (value: object, variant: string) => Unknown\n\t): UnionValidator<Key, Config, Unknown> {\n\t\treturn new UnionValidator(this.key, this.config, unknownValueValidation, this.useNumberKeys)\n\t}\n}\n\n/** @public */\nexport class DictValidator<Key extends string, Value> extends Validator<Record<Key, Value>> {\n\tconstructor(\n\t\tpublic readonly keyValidator: Validatable<Key>,\n\t\tpublic readonly valueValidator: Validatable<Value>\n\t) {\n\t\tsuper(\n\t\t\t(object) => {\n\t\t\t\tif (typeof object !== 'object' || object === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(object)}`)\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, value] of Object.entries(object)) {\n\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\tkeyValidator.validate(key)\n\t\t\t\t\t\tvalueValidator.validate(value)\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\treturn object as Record<Key, Value>\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (typeof newValue !== 'object' || newValue === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(newValue)}`)\n\t\t\t\t}\n\n\t\t\t\tlet isDifferent = false\n\n\t\t\t\tfor (const [key, value] of Object.entries(newValue)) {\n\t\t\t\t\tif (!hasOwnProperty(knownGoodValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\t\tkeyValidator.validate(key)\n\t\t\t\t\t\t\tvalueValidator.validate(value)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst prev = getOwnProperty(knownGoodValue, key)\n\t\t\t\t\tconst next = value\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checked = prefixError(key, () => {\n\t\t\t\t\t\tif (valueValidator.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\t\treturn valueValidator.validateUsingKnownGoodVersion(prev as any, next)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn valueValidator.validate(next)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as Record<Key, Value>) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n}\n\nfunction typeofValidator<T>(type: string): Validator<T> {\n\treturn new Validator((value) => {\n\t\tif (typeof value !== type) {\n\t\t\tthrow new ValidationError(`Expected ${type}, got ${typeToString(value)}`)\n\t\t}\n\t\treturn value as T\n\t})\n}\n\n/**\n * Validation that accepts any value. Useful as a starting point for building your own custom\n * validations.\n *\n * @public\n */\nexport const unknown = new Validator((value) => value)\n/**\n * Validation that accepts any value. Generally this should be avoided, but you can use it as an\n * escape hatch if you want to work without validations for e.g. a prototype.\n *\n * @public\n */\nexport const any = new Validator((value): any => value)\n\n/**\n * Validates that a value is a string.\n *\n * @public\n */\nexport const string = typeofValidator<string>('string')\n\n/**\n * Validates that a value is a finite non-NaN number.\n *\n * @public\n */\nexport const number = typeofValidator<number>('number').check((number) => {\n\tif (Number.isNaN(number)) {\n\t\tthrow new ValidationError('Expected a number, got NaN')\n\t}\n\tif (!Number.isFinite(number)) {\n\t\tthrow new ValidationError(`Expected a finite number, got ${number}`)\n\t}\n})\n/**\n * Fails if value \\< 0\n *\n * @public\n */\nexport const positiveNumber = number.check((value) => {\n\tif (value < 0) throw new ValidationError(`Expected a positive number, got ${value}`)\n})\n/**\n * Fails if value \\<= 0\n *\n * @public\n */\nexport const nonZeroNumber = number.check((value) => {\n\tif (value <= 0) throw new ValidationError(`Expected a non-zero positive number, got ${value}`)\n})\n/**\n * Fails if number is not an integer\n *\n * @public\n */\nexport const integer = number.check((value) => {\n\tif (!Number.isInteger(value)) throw new ValidationError(`Expected an integer, got ${value}`)\n})\n/**\n * Fails if value \\< 0 and is not an integer\n *\n * @public\n */\nexport const positiveInteger = integer.check((value) => {\n\tif (value < 0) throw new ValidationError(`Expected a positive integer, got ${value}`)\n})\n/**\n * Fails if value \\<= 0 and is not an integer\n *\n * @public\n */\nexport const nonZeroInteger = integer.check((value) => {\n\tif (value <= 0) throw new ValidationError(`Expected a non-zero positive integer, got ${value}`)\n})\n\n/**\n * Validates that a value is boolean.\n *\n * @public\n */\nexport const boolean = typeofValidator<boolean>('boolean')\n/**\n * Validates that a value is a bigint.\n *\n * @public\n */\nexport const bigint = typeofValidator<bigint>('bigint')\n/**\n * Validates that a value matches another that was passed in.\n *\n * @example\n *\n * ```ts\n * const trueValidator = T.literal(true)\n * ```\n *\n * @public\n */\nexport function literal<T extends string | number | boolean>(expectedValue: T): Validator<T> {\n\treturn new Validator((actualValue) => {\n\t\tif (actualValue !== expectedValue) {\n\t\t\tthrow new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`)\n\t\t}\n\t\treturn expectedValue\n\t})\n}\n\n/**\n * Validates that a value is an array. To check the contents of the array, use T.arrayOf.\n *\n * @public\n */\nexport const array = new Validator<unknown[]>((value) => {\n\tif (!Array.isArray(value)) {\n\t\tthrow new ValidationError(`Expected an array, got ${typeToString(value)}`)\n\t}\n\treturn value\n})\n\n/**\n * Validates that a value is an array whose contents matches the passed-in validator.\n *\n * @public\n */\nexport function arrayOf<T>(itemValidator: Validatable<T>): ArrayOfValidator<T> {\n\treturn new ArrayOfValidator(itemValidator)\n}\n\n/** @public */\nexport const unknownObject = new Validator<Record<string, unknown>>((value) => {\n\tif (typeof value !== 'object' || value === null) {\n\t\tthrow new ValidationError(`Expected object, got ${typeToString(value)}`)\n\t}\n\treturn value as Record<string, unknown>\n})\n\n/** @public */\nexport type ExtractRequiredKeys<T extends object> = {\n\t[K in keyof T]: undefined extends T[K] ? never : K\n}[keyof T]\n\n/** @public */\nexport type ExtractOptionalKeys<T extends object> = {\n\t[K in keyof T]: undefined extends T[K] ? K : never\n}[keyof T]\n\n/**\n * Validate an object has a particular shape.\n *\n * @public\n */\nexport function object<Shape extends object>(config: {\n\treadonly [K in keyof Shape]: Validatable<Shape[K]>\n}): ObjectValidator<\n\tExpand<\n\t\t{ [P in ExtractRequiredKeys<Shape>]: Shape[P] } & {\n\t\t\t[P in ExtractOptionalKeys<Shape>]?: Shape[P]\n\t\t}\n\t>\n> {\n\treturn new ObjectValidator(config) as any\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t(Object.getPrototypeOf(value) === Object.prototype ||\n\t\t\tObject.getPrototypeOf(value) === null ||\n\t\t\tObject.getPrototypeOf(value) === STRUCTURED_CLONE_OBJECT_PROTOTYPE)\n\t)\n}\n\nfunction isValidJson(value: any): value is JsonValue {\n\tif (\n\t\tvalue === null ||\n\t\ttypeof value === 'number' ||\n\t\ttypeof value === 'string' ||\n\t\ttypeof value === 'boolean'\n\t) {\n\t\treturn true\n\t}\n\n\tif (Array.isArray(value)) {\n\t\treturn value.every(isValidJson)\n\t}\n\n\tif (isPlainObject(value)) {\n\t\treturn Object.values(value).every(isValidJson)\n\t}\n\n\treturn false\n}\n\n/**\n * Validate that a value is valid JSON.\n *\n * @public\n */\nexport const jsonValue: Validator<JsonValue> = new Validator<JsonValue>(\n\t(value): JsonValue => {\n\t\tif (isValidJson(value)) {\n\t\t\treturn value as JsonValue\n\t\t}\n\n\t\tthrow new ValidationError(`Expected json serializable value, got ${typeof value}`)\n\t},\n\t(knownGoodValue, newValue) => {\n\t\tif (Array.isArray(knownGoodValue) && Array.isArray(newValue)) {\n\t\t\tlet isDifferent = knownGoodValue.length !== newValue.length\n\t\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\t\tif (i >= knownGoodValue.length) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tjsonValue.validate(newValue[i])\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst prev = knownGoodValue[i]\n\t\t\t\tconst next = newValue[i]\n\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst checked = jsonValue.validateUsingKnownGoodVersion!(prev, next)\n\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isDifferent ? (newValue as JsonValue) : knownGoodValue\n\t\t} else if (isPlainObject(knownGoodValue) && isPlainObject(newValue)) {\n\t\t\tlet isDifferent = false\n\t\t\tfor (const key of Object.keys(newValue)) {\n\t\t\t\tif (!hasOwnProperty(knownGoodValue, key)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tjsonValue.validate(newValue[key])\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst prev = knownGoodValue[key]\n\t\t\t\tconst next = newValue[key]\n\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst checked = jsonValue.validateUsingKnownGoodVersion!(prev!, next)\n\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isDifferent ? (newValue as JsonValue) : knownGoodValue\n\t\t} else {\n\t\t\treturn jsonValue.validate(newValue)\n\t\t}\n\t}\n)\n\n/**\n * Validate an object has a particular shape.\n *\n * @public\n */\nexport function jsonDict(): DictValidator<string, JsonValue> {\n\treturn dict(string, jsonValue)\n}\n\n/**\n * Validation that an option is a dict with particular keys and values.\n *\n * @public\n */\nexport function dict<Key extends string, Value>(\n\tkeyValidator: Validatable<Key>,\n\tvalueValidator: Validatable<Value>\n): DictValidator<Key, Value> {\n\treturn new DictValidator(keyValidator, valueValidator)\n}\n\n/**\n * Validate a union of several object types. Each object must have a property matching `key` which\n * should be a unique string.\n *\n * @example\n *\n * ```ts\n * const catValidator = T.object({ kind: T.literal('cat'), meow: T.boolean })\n * const dogValidator = T.object({ kind: T.literal('dog'), bark: T.boolean })\n * const animalValidator = T.union('kind', { cat: catValidator, dog: dogValidator })\n * ```\n *\n * @public\n */\nexport function union<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(\n\tkey: Key,\n\tconfig: Config\n): UnionValidator<Key, Config> {\n\treturn new UnionValidator(\n\t\tkey,\n\t\tconfig,\n\t\t(_unknownValue, unknownVariant) => {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected one of ${Object.keys(config)\n\t\t\t\t\t.map((key) => JSON.stringify(key))\n\t\t\t\t\t.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,\n\t\t\t\t[key]\n\t\t\t)\n\t\t},\n\t\tfalse\n\t)\n}\n\n/**\n * @internal\n */\nexport function numberUnion<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(\n\tkey: Key,\n\tconfig: Config\n): UnionValidator<Key, Config> {\n\treturn new UnionValidator(\n\t\tkey,\n\t\tconfig,\n\t\t(unknownValue, unknownVariant) => {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected one of ${Object.keys(config)\n\t\t\t\t\t.map((key) => JSON.stringify(key))\n\t\t\t\t\t.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,\n\t\t\t\t[key]\n\t\t\t)\n\t\t},\n\t\ttrue\n\t)\n}\n\n/**\n * A named object with an ID. Errors will be reported as being part of the object with the given\n * name.\n *\n * @public\n */\nexport function model<T extends { readonly id: string }>(\n\tname: string,\n\tvalidator: Validatable<T>\n): Validator<T> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\treturn prefixError(name, () => validator.validate(value))\n\t\t},\n\t\t(prevValue, newValue) => {\n\t\t\treturn prefixError(name, () => {\n\t\t\t\tif (validator.validateUsingKnownGoodVersion) {\n\t\t\t\t\treturn validator.validateUsingKnownGoodVersion(prevValue, newValue)\n\t\t\t\t} else {\n\t\t\t\t\treturn validator.validate(newValue)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t)\n}\n\n/** @public */\nexport function setEnum<T>(values: ReadonlySet<T>): Validator<T> {\n\treturn new Validator((value) => {\n\t\tif (!values.has(value as T)) {\n\t\t\tconst valuesString = Array.from(values, (value) => JSON.stringify(value)).join(' or ')\n\t\t\tthrow new ValidationError(`Expected ${valuesString}, got ${value}`)\n\t\t}\n\t\treturn value as T\n\t})\n}\n\n/** @public */\nexport function optional<T>(validator: Validatable<T>): Validator<T | undefined> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\tif (value === undefined) return undefined\n\t\t\treturn validator.validate(value)\n\t\t},\n\t\t(knownGoodValue, newValue) => {\n\t\t\tif (knownGoodValue === undefined && newValue === undefined) return undefined\n\t\t\tif (newValue === undefined) return undefined\n\t\t\tif (validator.validateUsingKnownGoodVersion && knownGoodValue !== undefined) {\n\t\t\t\treturn validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)\n\t\t\t}\n\t\t\treturn validator.validate(newValue)\n\t\t}\n\t)\n}\n\n/** @public */\nexport function nullable<T>(validator: Validatable<T>): Validator<T | null> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\tif (value === null) return null\n\t\t\treturn validator.validate(value)\n\t\t},\n\t\t(knownGoodValue, newValue) => {\n\t\t\tif (newValue === null) return null\n\t\t\tif (validator.validateUsingKnownGoodVersion && knownGoodValue !== null) {\n\t\t\t\treturn validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)\n\t\t\t}\n\t\t\treturn validator.validate(newValue)\n\t\t}\n\t)\n}\n\n/** @public */\nexport function literalEnum<const Values extends readonly unknown[]>(\n\t...values: Values\n): Validator<Values[number]> {\n\treturn setEnum(new Set(values))\n}\n\nfunction parseUrl(str: string) {\n\ttry {\n\t\treturn new URL(str)\n\t} catch (error) {\n\t\tif (str.startsWith('/') || str.startsWith('./')) {\n\t\t\ttry {\n\t\t\t\treturn new URL(str, 'http://example.com')\n\t\t\t} catch (error) {\n\t\t\t\tthrow new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)\n\t\t\t}\n\t\t}\n\t\tthrow new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)\n\t}\n}\n\nconst validLinkProtocols = new Set(['http:', 'https:', 'mailto:'])\n\n/**\n * Validates that a value is a url safe to use as a link.\n *\n * @public\n */\nexport const linkUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!validLinkProtocols.has(url.protocol.toLowerCase())) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n// N.B. asset: is a reference to the local indexedDB object store.\nconst validSrcProtocols = new Set(['http:', 'https:', 'data:', 'asset:'])\n\n/**\n * Validates that a valid is a url safe to load as an asset.\n *\n * @public\n */\nexport const srcUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!validSrcProtocols.has(url.protocol.toLowerCase())) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n/**\n * Validates an http(s) url\n *\n * @public\n */\nexport const httpUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!url.protocol.toLowerCase().match(/^https?:$/)) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n/**\n * Validates that a value is an IndexKey.\n * @public\n */\nexport const indexKey = string.refine<IndexKey>((key) => {\n\ttry {\n\t\tvalidateIndexKey(key)\n\t\treturn key\n\t} catch {\n\t\tthrow new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`)\n\t}\n})\n\n/**\n * Validate a value against one of two types.\n *\n * @public\n */\nexport function or<T1, T2>(v1: Validatable<T1>, v2: Validatable<T2>): Validator<T1 | T2> {\n\treturn new Validator((value) => {\n\t\ttry {\n\t\t\treturn v1.validate(value)\n\t\t} catch {\n\t\t\treturn v2.validate(value)\n\t\t}\n\t})\n}\n", "import type { RecordId, UnknownRecord } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\n\n/** @public */\nexport function idValidator<Id extends RecordId<UnknownRecord>>(\n\tprefix: Id['__type__']['typeName']\n): T.Validator<Id> {\n\treturn T.string.refine((id) => {\n\t\tif (!id.startsWith(`${prefix}:`)) {\n\t\t\tthrow new Error(`${prefix} ID must start with \"${prefix}:\"`)\n\t\t}\n\t\treturn id as Id\n\t})\n}\n", "import { T } from '@tldraw/validate'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport { createBindingPropsMigrationSequence } from '../records/TLBinding'\nimport { RecordProps } from '../recordsWithProps'\nimport { arrowShapeVersions } from '../shapes/TLArrowShape'\nimport { TLBaseBinding } from './TLBaseBinding'\n\n/** @public */\nexport interface TLArrowBindingProps {\n\tterminal: 'start' | 'end'\n\tnormalizedAnchor: VecModel\n\t/**\n\t * exact is whether the arrow head 'enters' the bound shape to point directly at the binding\n\t * anchor point\n\t */\n\tisExact: boolean\n\t/**\n\t * precise is whether to bind to the normalizedAnchor, or to the middle of the shape\n\t */\n\tisPrecise: boolean\n}\n\n/** @public */\nexport const arrowBindingProps: RecordProps<TLArrowBinding> = {\n\tterminal: T.literalEnum('start', 'end'),\n\tnormalizedAnchor: vecModelValidator,\n\tisExact: T.boolean,\n\tisPrecise: T.boolean,\n}\n\n/** @public */\nexport type TLArrowBinding = TLBaseBinding<'arrow', TLArrowBindingProps>\n\nexport const arrowBindingVersions = {} as const\n\n/** @public */\nexport const arrowBindingMigrations = createBindingPropsMigrationSequence({\n\tsequence: [{ dependsOn: [arrowShapeVersions.ExtractBindings] }],\n})\n", "import { T } from '@tldraw/validate'\n\n/**\n * A serializable model for 2D boxes.\n *\n * @public */\nexport interface BoxModel {\n\tx: number\n\ty: number\n\tw: number\n\th: number\n}\n\n/**\n * A serializable model for 2D vectors.\n *\n * @public */\nexport interface VecModel {\n\tx: number\n\ty: number\n\tz?: number\n}\n\n/** @public */\nexport const vecModelValidator: T.ObjectValidator<VecModel> = T.object({\n\tx: T.number,\n\ty: T.number,\n\tz: T.number.optional(),\n})\n\n/** @public */\nexport const boxModelValidator: T.ObjectValidator<BoxModel> = T.object({\n\tx: T.number,\n\ty: T.number,\n\tw: T.number,\n\th: T.number,\n})\n", "import {\n\tRecordId,\n\tUnknownRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n} from '@tldraw/store'\nimport { Expand, mapObjectMapValues, uniqueId } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { TLArrowBinding } from '../bindings/TLArrowBinding'\nimport { TLBaseBinding, createBindingValidator } from '../bindings/TLBaseBinding'\nimport { SchemaPropsInfo } from '../createTLSchema'\nimport { TLPropsMigrations } from '../recordsWithProps'\n\n/**\n * The default set of bindings that are available in the editor.\n *\n * @public */\nexport type TLDefaultBinding = TLArrowBinding\n\n/**\n * A type for a binding that is available in the editor but whose type is\n * unknown\u2014either one of the editor's default bindings or else a custom binding.\n *\n * @public */\nexport type TLUnknownBinding = TLBaseBinding<string, object>\n\n/**\n * The set of all bindings that are available in the editor, including unknown bindings.\n *\n * @public\n */\nexport type TLBinding = TLDefaultBinding | TLUnknownBinding\n\n/** @public */\nexport type TLBindingUpdate<T extends TLBinding = TLBinding> = Expand<{\n\tid: TLBindingId\n\ttype: T['type']\n\ttypeName?: T['typeName']\n\tfromId?: T['fromId']\n\ttoId?: T['toId']\n\tprops?: Partial<T['props']>\n\tmeta?: Partial<T['meta']>\n}>\n\n/** @public */\nexport type TLBindingCreate<T extends TLBinding = TLBinding> = Expand<{\n\tid?: TLBindingId\n\ttype: T['type']\n\ttypeName?: T['typeName']\n\tfromId: T['fromId']\n\ttoId: T['toId']\n\tprops?: Partial<T['props']>\n\tmeta?: Partial<T['meta']>\n}>\n\n/**\n * An ID for a {@link TLBinding}.\n *\n * @public\n */\nexport type TLBindingId = RecordId<TLUnknownBinding>\n\n/** @public */\nexport const rootBindingVersions = createMigrationIds('com.tldraw.binding', {} as const)\n\n/** @public */\nexport const rootBindingMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.binding',\n\trecordType: 'binding',\n\tsequence: [],\n})\n\n/** @public */\nexport function isBinding(record?: UnknownRecord): record is TLBinding {\n\tif (!record) return false\n\treturn record.typeName === 'binding'\n}\n\n/** @public */\nexport function isBindingId(id?: string): id is TLBindingId {\n\tif (!id) return false\n\treturn id.startsWith('binding:')\n}\n\n/** @public */\nexport function createBindingId(id?: string): TLBindingId {\n\treturn `binding:${id ?? uniqueId()}` as TLBindingId\n}\n\n/**\n * @public\n */\nexport function createBindingPropsMigrationSequence(\n\tmigrations: TLPropsMigrations\n): TLPropsMigrations {\n\treturn migrations\n}\n\n/**\n * @public\n */\nexport function createBindingPropsMigrationIds<S extends string, T extends Record<string, number>>(\n\tbindingType: S,\n\tids: T\n): { [k in keyof T]: `com.tldraw.binding.${S}/${T[k]}` } {\n\treturn mapObjectMapValues(ids, (_k, v) => `com.tldraw.binding.${bindingType}/${v}`) as any\n}\n\n/** @internal */\nexport function createBindingRecordType(bindings: Record<string, SchemaPropsInfo>) {\n\treturn createRecordType<TLBinding>('binding', {\n\t\tscope: 'document',\n\t\tvalidator: T.model(\n\t\t\t'binding',\n\t\t\tT.union(\n\t\t\t\t'type',\n\t\t\t\tmapObjectMapValues(bindings, (type, { props, meta }) =>\n\t\t\t\t\tcreateBindingValidator(type, props, meta)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t}).withDefaultProperties(() => ({\n\t\tmeta: {},\n\t}))\n}\n", "import { BaseRecord } from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\nimport { TLBindingId } from '../records/TLBinding'\nimport { TLShapeId } from '../records/TLShape'\nimport { shapeIdValidator } from '../shapes/TLBaseShape'\n\n/** @public */\nexport interface TLBaseBinding<Type extends string, Props extends object>\n\textends BaseRecord<'binding', TLBindingId> {\n\ttype: Type\n\tfromId: TLShapeId\n\ttoId: TLShapeId\n\tprops: Props\n\tmeta: JsonObject\n}\n\n/** @public */\nexport const bindingIdValidator = idValidator<TLBindingId>('binding')\n\n/** @public */\nexport function createBindingValidator<\n\tType extends string,\n\tProps extends JsonObject,\n\tMeta extends JsonObject,\n>(\n\ttype: Type,\n\tprops?: { [K in keyof Props]: T.Validatable<Props[K]> },\n\tmeta?: { [K in keyof Meta]: T.Validatable<Meta[K]> }\n) {\n\treturn T.object<TLBaseBinding<Type, Props>>({\n\t\tid: bindingIdValidator,\n\t\ttypeName: T.literal('binding'),\n\t\ttype: T.literal(type),\n\t\tfromId: shapeIdValidator,\n\t\ttoId: shapeIdValidator,\n\t\tprops: props ? T.object(props) : (T.jsonValue as any),\n\t\tmeta: meta ? T.object(meta) : (T.jsonValue as any),\n\t})\n}\n", "import { BaseRecord } from '@tldraw/store'\nimport { IndexKey, JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { TLOpacityType, opacityValidator } from '../misc/TLOpacity'\nimport { idValidator } from '../misc/id-validator'\nimport { TLParentId, TLShapeId } from '../records/TLShape'\n\n/** @public */\nexport interface TLBaseShape<Type extends string, Props extends object>\n\textends BaseRecord<'shape', TLShapeId> {\n\ttype: Type\n\tx: number\n\ty: number\n\trotation: number\n\tindex: IndexKey\n\tparentId: TLParentId\n\tisLocked: boolean\n\topacity: TLOpacityType\n\tprops: Props\n\tmeta: JsonObject\n}\n\n/** @public */\nexport const parentIdValidator = T.string.refine((id) => {\n\tif (!id.startsWith('page:') && !id.startsWith('shape:')) {\n\t\tthrow new Error('Parent ID must start with \"page:\" or \"shape:\"')\n\t}\n\treturn id as TLParentId\n})\n\n/** @public */\nexport const shapeIdValidator = idValidator<TLShapeId>('shape')\n\n/** @public */\nexport function createShapeValidator<\n\tType extends string,\n\tProps extends JsonObject,\n\tMeta extends JsonObject,\n>(\n\ttype: Type,\n\tprops?: { [K in keyof Props]: T.Validatable<Props[K]> },\n\tmeta?: { [K in keyof Meta]: T.Validatable<Meta[K]> }\n) {\n\treturn T.object<TLBaseShape<Type, Props>>({\n\t\tid: shapeIdValidator,\n\t\ttypeName: T.literal('shape'),\n\t\tx: T.number,\n\t\ty: T.number,\n\t\trotation: T.number,\n\t\tindex: T.indexKey,\n\t\tparentId: parentIdValidator,\n\t\ttype: T.literal(type),\n\t\tisLocked: T.boolean,\n\t\topacity: opacityValidator,\n\t\tprops: props ? T.object(props) : (T.jsonValue as any),\n\t\tmeta: meta ? T.object(meta) : (T.jsonValue as any),\n\t})\n}\n", "import { T } from '@tldraw/validate'\n\n/** @public */\nexport type TLOpacityType = number\n\n/** @public */\nexport const opacityValidator = T.number.check((n) => {\n\tif (n < 0 || n > 1) {\n\t\tthrow new T.ValidationError('Opacity must be between 0 and 1')\n\t}\n})\n", "import { createMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLArrowBinding } from '../bindings/TLArrowBinding'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport { createBindingId } from '../records/TLBinding'\nimport { TLShapeId, createShapePropsMigrationIds } from '../records/TLShape'\nimport { RecordProps, TLPropsMigration, createPropsMigration } from '../recordsWithProps'\nimport { StyleProp } from '../styles/StyleProp'\nimport {\n\tDefaultColorStyle,\n\tDefaultLabelColorStyle,\n\tTLDefaultColorStyle,\n} from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultFillStyle, TLDefaultFillStyle } from '../styles/TLFillStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\nconst arrowheadTypes = [\n\t'arrow',\n\t'triangle',\n\t'square',\n\t'dot',\n\t'pipe',\n\t'diamond',\n\t'inverted',\n\t'bar',\n\t'none',\n] as const\n\n/** @public */\nexport const ArrowShapeArrowheadStartStyle = StyleProp.defineEnum('tldraw:arrowheadStart', {\n\tdefaultValue: 'none',\n\tvalues: arrowheadTypes,\n})\n\n/** @public */\nexport const ArrowShapeArrowheadEndStyle = StyleProp.defineEnum('tldraw:arrowheadEnd', {\n\tdefaultValue: 'arrow',\n\tvalues: arrowheadTypes,\n})\n\n/** @public */\nexport type TLArrowShapeArrowheadStyle = T.TypeOf<typeof ArrowShapeArrowheadStartStyle>\n\n/** @public */\nexport interface TLArrowShapeProps {\n\tlabelColor: TLDefaultColorStyle\n\tcolor: TLDefaultColorStyle\n\tfill: TLDefaultFillStyle\n\tdash: TLDefaultDashStyle\n\tsize: TLDefaultSizeStyle\n\tarrowheadStart: TLArrowShapeArrowheadStyle\n\tarrowheadEnd: TLArrowShapeArrowheadStyle\n\tfont: TLDefaultFontStyle\n\tstart: VecModel\n\tend: VecModel\n\tbend: number\n\ttext: string\n\tlabelPosition: number\n\tscale: number\n}\n\n/** @public */\nexport type TLArrowShape = TLBaseShape<'arrow', TLArrowShapeProps>\n\n/** @public */\nexport const arrowShapeProps: RecordProps<TLArrowShape> = {\n\tlabelColor: DefaultLabelColorStyle,\n\tcolor: DefaultColorStyle,\n\tfill: DefaultFillStyle,\n\tdash: DefaultDashStyle,\n\tsize: DefaultSizeStyle,\n\tarrowheadStart: ArrowShapeArrowheadStartStyle,\n\tarrowheadEnd: ArrowShapeArrowheadEndStyle,\n\tfont: DefaultFontStyle,\n\tstart: vecModelValidator,\n\tend: vecModelValidator,\n\tbend: T.number,\n\ttext: T.string,\n\tlabelPosition: T.number,\n\tscale: T.nonZeroNumber,\n}\n\nexport const arrowShapeVersions = createShapePropsMigrationIds('arrow', {\n\tAddLabelColor: 1,\n\tAddIsPrecise: 2,\n\tAddLabelPosition: 3,\n\tExtractBindings: 4,\n\tAddScale: 5,\n})\n\nfunction propsMigration(migration: TLPropsMigration) {\n\treturn createPropsMigration<TLArrowShape>('shape', 'arrow', migration)\n}\n\n/** @public */\nexport const arrowShapeMigrations = createMigrationSequence({\n\tsequenceId: 'com.tldraw.shape.arrow',\n\tretroactive: false,\n\tsequence: [\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddLabelColor,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelColor = 'black'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t}),\n\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddIsPrecise,\n\t\t\tup: ({ start, end }) => {\n\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\tstart.isPrecise = !(start.normalizedAnchor.x === 0.5 && start.normalizedAnchor.y === 0.5)\n\t\t\t\t}\n\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\tend.isPrecise = !(end.normalizedAnchor.x === 0.5 && end.normalizedAnchor.y === 0.5)\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: ({ start, end }) => {\n\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\tif (!start.isPrecise) {\n\t\t\t\t\t\tstart.normalizedAnchor = { x: 0.5, y: 0.5 }\n\t\t\t\t\t}\n\t\t\t\t\tdelete start.isPrecise\n\t\t\t\t}\n\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\tif (!end.isPrecise) {\n\t\t\t\t\t\tend.normalizedAnchor = { x: 0.5, y: 0.5 }\n\t\t\t\t\t}\n\t\t\t\t\tdelete end.isPrecise\n\t\t\t\t}\n\t\t\t},\n\t\t}),\n\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddLabelPosition,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelPosition = 0.5\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.labelPosition\n\t\t\t},\n\t\t}),\n\n\t\t{\n\t\t\tid: arrowShapeVersions.ExtractBindings,\n\t\t\tscope: 'store',\n\t\t\tup: (oldStore) => {\n\t\t\t\ttype OldArrowTerminal =\n\t\t\t\t\t| {\n\t\t\t\t\t\t\ttype: 'point'\n\t\t\t\t\t\t\tx: number\n\t\t\t\t\t\t\ty: number\n\t\t\t\t\t  }\n\t\t\t\t\t| {\n\t\t\t\t\t\t\ttype: 'binding'\n\t\t\t\t\t\t\tboundShapeId: TLShapeId\n\t\t\t\t\t\t\tnormalizedAnchor: VecModel\n\t\t\t\t\t\t\tisExact: boolean\n\t\t\t\t\t\t\tisPrecise: boolean\n\t\t\t\t\t  }\n\t\t\t\t\t// new type:\n\t\t\t\t\t| { type?: undefined; x: number; y: number }\n\n\t\t\t\ttype OldArrow = TLBaseShape<'arrow', { start: OldArrowTerminal; end: OldArrowTerminal }>\n\n\t\t\t\tconst arrows = Object.values(oldStore).filter(\n\t\t\t\t\t(r: any): r is OldArrow => r.typeName === 'shape' && r.type === 'arrow'\n\t\t\t\t)\n\n\t\t\t\tfor (const arrow of arrows) {\n\t\t\t\t\tconst { start, end } = arrow.props\n\t\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\t\tconst id = createBindingId()\n\t\t\t\t\t\tconst binding: TLArrowBinding = {\n\t\t\t\t\t\t\ttypeName: 'binding',\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\ttype: 'arrow',\n\t\t\t\t\t\t\tfromId: arrow.id,\n\t\t\t\t\t\t\ttoId: start.boundShapeId,\n\t\t\t\t\t\t\tmeta: {},\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tterminal: 'start',\n\t\t\t\t\t\t\t\tnormalizedAnchor: start.normalizedAnchor,\n\t\t\t\t\t\t\t\tisExact: start.isExact,\n\t\t\t\t\t\t\t\tisPrecise: start.isPrecise,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toldStore[id] = binding\n\t\t\t\t\t\tarrow.props.start = { x: 0, y: 0 }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete arrow.props.start.type\n\t\t\t\t\t}\n\t\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\t\tconst id = createBindingId()\n\t\t\t\t\t\tconst binding: TLArrowBinding = {\n\t\t\t\t\t\t\ttypeName: 'binding',\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\ttype: 'arrow',\n\t\t\t\t\t\t\tfromId: arrow.id,\n\t\t\t\t\t\t\ttoId: end.boundShapeId,\n\t\t\t\t\t\t\tmeta: {},\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tterminal: 'end',\n\t\t\t\t\t\t\t\tnormalizedAnchor: end.normalizedAnchor,\n\t\t\t\t\t\t\t\tisExact: end.isExact,\n\t\t\t\t\t\t\t\tisPrecise: end.isPrecise,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toldStore[id] = binding\n\t\t\t\t\t\tarrow.props.end = { x: 0, y: 0 }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete arrow.props.end.type\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t}),\n\t],\n})\n", "import {\n\tRecordId,\n\tUnknownRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n} from '@tldraw/store'\nimport { mapObjectMapValues, uniqueId } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { SchemaPropsInfo } from '../createTLSchema'\nimport { TLPropsMigrations } from '../recordsWithProps'\nimport { TLArrowShape } from '../shapes/TLArrowShape'\nimport { TLBaseShape, createShapeValidator } from '../shapes/TLBaseShape'\nimport { TLBookmarkShape } from '../shapes/TLBookmarkShape'\nimport { TLDrawShape } from '../shapes/TLDrawShape'\nimport { TLEmbedShape } from '../shapes/TLEmbedShape'\nimport { TLFrameShape } from '../shapes/TLFrameShape'\nimport { TLGeoShape } from '../shapes/TLGeoShape'\nimport { TLGroupShape } from '../shapes/TLGroupShape'\nimport { TLHighlightShape } from '../shapes/TLHighlightShape'\nimport { TLImageShape } from '../shapes/TLImageShape'\nimport { TLLineShape } from '../shapes/TLLineShape'\nimport { TLNoteShape } from '../shapes/TLNoteShape'\nimport { TLTextShape } from '../shapes/TLTextShape'\nimport { TLVideoShape } from '../shapes/TLVideoShape'\nimport { StyleProp } from '../styles/StyleProp'\nimport { TLPageId } from './TLPage'\n\n/**\n * The default set of shapes that are available in the editor.\n *\n * @public */\nexport type TLDefaultShape =\n\t| TLArrowShape\n\t| TLBookmarkShape\n\t| TLDrawShape\n\t| TLEmbedShape\n\t| TLFrameShape\n\t| TLGeoShape\n\t| TLGroupShape\n\t| TLImageShape\n\t| TLLineShape\n\t| TLNoteShape\n\t| TLTextShape\n\t| TLVideoShape\n\t| TLHighlightShape\n\n/**\n * A type for a shape that is available in the editor but whose type is\n * unknown\u2014either one of the editor's default shapes or else a custom shape.\n *\n * @public */\nexport type TLUnknownShape = TLBaseShape<string, object>\n\n/**\n * The set of all shapes that are available in the editor, including unknown shapes.\n *\n * @public\n */\nexport type TLShape = TLDefaultShape | TLUnknownShape\n\n/** @public */\nexport type TLShapePartial<T extends TLShape = TLShape> = T extends T\n\t? {\n\t\t\tid: TLShapeId\n\t\t\ttype: T['type']\n\t\t\tprops?: Partial<T['props']>\n\t\t\tmeta?: Partial<T['meta']>\n\t\t} & Partial<Omit<T, 'type' | 'id' | 'props' | 'meta'>>\n\t: never\n\n/** @public */\nexport type TLShapeId = RecordId<TLUnknownShape>\n\n/** @public */\nexport type TLParentId = TLPageId | TLShapeId\n\n/** @public */\nexport const rootShapeVersions = createMigrationIds('com.tldraw.shape', {\n\tAddIsLocked: 1,\n\tHoistOpacity: 2,\n\tAddMeta: 3,\n\tAddWhite: 4,\n} as const)\n\n/** @public */\nexport const rootShapeMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.shape',\n\trecordType: 'shape',\n\tsequence: [\n\t\t{\n\t\t\tid: rootShapeVersions.AddIsLocked,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.isLocked = false\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tdelete record.isLocked\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.HoistOpacity,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.opacity = Number(record.props.opacity ?? '1')\n\t\t\t\tdelete record.props.opacity\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tconst opacity = record.opacity\n\t\t\t\tdelete record.opacity\n\t\t\t\trecord.props.opacity =\n\t\t\t\t\topacity < 0.175\n\t\t\t\t\t\t? '0.1'\n\t\t\t\t\t\t: opacity < 0.375\n\t\t\t\t\t\t\t? '0.25'\n\t\t\t\t\t\t\t: opacity < 0.625\n\t\t\t\t\t\t\t\t? '0.5'\n\t\t\t\t\t\t\t\t: opacity < 0.875\n\t\t\t\t\t\t\t\t\t? '0.75'\n\t\t\t\t\t\t\t\t\t: '1'\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.AddWhite,\n\t\t\tup: (_record) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tif (record.props.color === 'white') {\n\t\t\t\t\trecord.props.color = 'black'\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport function isShape(record?: UnknownRecord): record is TLShape {\n\tif (!record) return false\n\treturn record.typeName === 'shape'\n}\n\n/** @public */\nexport function isShapeId(id?: string): id is TLShapeId {\n\tif (!id) return false\n\treturn id.startsWith('shape:')\n}\n\n/** @public */\nexport function createShapeId(id?: string): TLShapeId {\n\treturn `shape:${id ?? uniqueId()}` as TLShapeId\n}\n\n/** @internal */\nexport function getShapePropKeysByStyle(props: Record<string, T.Validatable<any>>) {\n\tconst propKeysByStyle = new Map<StyleProp<unknown>, string>()\n\tfor (const [key, prop] of Object.entries(props)) {\n\t\tif (prop instanceof StyleProp) {\n\t\t\tif (propKeysByStyle.has(prop)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Duplicate style prop ${prop.id}. Each style prop can only be used once within a shape.`\n\t\t\t\t)\n\t\t\t}\n\t\t\tpropKeysByStyle.set(prop, key)\n\t\t}\n\t}\n\treturn propKeysByStyle\n}\n\n/**\n * @public\n */\nexport function createShapePropsMigrationSequence(\n\tmigrations: TLPropsMigrations\n): TLPropsMigrations {\n\treturn migrations\n}\n\n/**\n * @public\n */\nexport function createShapePropsMigrationIds<\n\tconst S extends string,\n\tconst T extends Record<string, number>,\n>(shapeType: S, ids: T): { [k in keyof T]: `com.tldraw.shape.${S}/${T[k]}` } {\n\treturn mapObjectMapValues(ids, (_k, v) => `com.tldraw.shape.${shapeType}/${v}`) as any\n}\n\n/** @internal */\nexport function createShapeRecordType(shapes: Record<string, SchemaPropsInfo>) {\n\treturn createRecordType<TLShape>('shape', {\n\t\tscope: 'document',\n\t\tvalidator: T.model(\n\t\t\t'shape',\n\t\t\tT.union(\n\t\t\t\t'type',\n\t\t\t\tmapObjectMapValues(shapes, (type, { props, meta }) =>\n\t\t\t\t\tcreateShapeValidator(type, props, meta)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t}).withDefaultProperties(() => ({\n\t\tx: 0,\n\t\ty: 0,\n\t\trotation: 0,\n\t\tisLocked: false,\n\t\topacity: 1,\n\t\tmeta: {},\n\t}))\n}\n", "import { T } from '@tldraw/validate'\n\n/**\n * A `StyleProp` is a property of a shape that follows some special rules.\n *\n * 1. The same value can be set on lots of shapes at the same time.\n *\n * 2. The last used value is automatically saved and applied to new shapes.\n *\n * For example, {@link DefaultColorStyle} is a style prop used by tldraw's default shapes to set\n * their color. If you try selecting several shapes on tldraw.com and changing their color, you'll\n * see that the color is applied to all of them. Then, if you draw a new shape, it'll have the same\n * color as the one you just set.\n *\n * You can use styles in your own shapes by either defining your own (see {@link StyleProp.define}\n * and {@link StyleProp.defineEnum}) or using tldraw's default ones, like {@link DefaultColorStyle}.\n * When you define a shape, pass a `props` object describing all of your shape's properties, using\n * `StyleProp`s for the ones you want to be styles. See the\n * {@link https://github.com/tldraw/tldraw/tree/main/apps/examples | custom styles example}\n * for more.\n *\n * @public\n */\nexport class StyleProp<Type> implements T.Validatable<Type> {\n\t/**\n\t * Define a new {@link StyleProp}.\n\t *\n\t * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with\n\t * your app/library name.\n\t * @param options -\n\t * - `defaultValue`: The default value for this style prop.\n\t *\n\t * - `type`: Optionally, describe what type of data you expect for this style prop.\n\t *\n\t * @example\n\t * ```ts\n\t * import {T} from '@tldraw/validate'\n\t * import {StyleProp} from '@tldraw/tlschema'\n\t *\n\t * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {\n\t *   defaultValue: 1,\n\t *   type: T.number,\n\t * })\n\t * ```\n\t * @public\n\t */\n\tstatic define<Type>(\n\t\tuniqueId: string,\n\t\toptions: { defaultValue: Type; type?: T.Validatable<Type> }\n\t) {\n\t\tconst { defaultValue, type = T.any } = options\n\t\treturn new StyleProp<Type>(uniqueId, defaultValue, type)\n\t}\n\n\t/**\n\t * Define a new {@link StyleProp} as a list of possible values.\n\t *\n\t * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with\n\t * your app/library name.\n\t * @param options -\n\t * - `defaultValue`: The default value for this style prop.\n\t *\n\t * - `values`: An array of possible values of this style prop.\n\t *\n\t * @example\n\t * ```ts\n\t * import {StyleProp} from '@tldraw/tlschema'\n\t *\n\t * const MySizeProp = StyleProp.defineEnum('myApp:size', {\n\t *   defaultValue: 'medium',\n\t *   values: ['small', 'medium', 'large'],\n\t * })\n\t * ```\n\t */\n\tstatic defineEnum<const Values extends readonly unknown[]>(\n\t\tuniqueId: string,\n\t\toptions: { defaultValue: Values[number]; values: Values }\n\t) {\n\t\tconst { defaultValue, values } = options\n\t\treturn new EnumStyleProp<Values[number]>(uniqueId, defaultValue, values)\n\t}\n\n\t/** @internal */\n\tprotected constructor(\n\t\treadonly id: string,\n\t\tpublic defaultValue: Type,\n\t\treadonly type: T.Validatable<Type>\n\t) {}\n\n\tsetDefaultValue(value: Type) {\n\t\tthis.defaultValue = value\n\t}\n\n\tvalidate(value: unknown) {\n\t\treturn this.type.validate(value)\n\t}\n\n\tvalidateUsingKnownGoodVersion(prevValue: Type, newValue: unknown) {\n\t\tif (this.type.validateUsingKnownGoodVersion) {\n\t\t\treturn this.type.validateUsingKnownGoodVersion(prevValue, newValue)\n\t\t} else {\n\t\t\treturn this.validate(newValue)\n\t\t}\n\t}\n}\n\n/**\n * See {@link StyleProp} & {@link StyleProp.defineEnum}\n *\n * @public\n */\nexport class EnumStyleProp<T> extends StyleProp<T> {\n\t/** @internal */\n\tconstructor(\n\t\tid: string,\n\t\tdefaultValue: T,\n\t\treadonly values: readonly T[]\n\t) {\n\t\tsuper(id, defaultValue, T.literalEnum(...values))\n\t}\n}\n\n/**\n * @public\n */\nexport type StylePropValue<T extends StyleProp<any>> = T extends StyleProp<infer U> ? U : never\n", "import {\n\tMigration,\n\tMigrationId,\n\tMigrationSequence,\n\tRecordType,\n\tStandaloneDependsOn,\n\tUnknownRecord,\n\tcreateMigrationSequence,\n} from '@tldraw/store'\nimport { Expand, assert } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { SchemaPropsInfo } from './createTLSchema'\n\n/** @public */\nexport type RecordProps<R extends UnknownRecord & { props: object }> = {\n\t[K in keyof R['props']]: T.Validatable<R['props'][K]>\n}\n\n/** @public */\nexport type RecordPropsType<Config extends Record<string, T.Validatable<any>>> = Expand<{\n\t[K in keyof Config]: T.TypeOf<Config[K]>\n}>\n\n/**\n * @public\n */\nexport interface TLPropsMigration {\n\treadonly id: MigrationId\n\treadonly dependsOn?: MigrationId[]\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\treadonly up: (props: any) => any\n\t/**\n\t * If a down migration was deployed more than a couple of months ago it should be safe to retire it.\n\t * We only really need them to smooth over the transition between versions, and some folks do keep\n\t * browser tabs open for months without refreshing, but at a certain point that kind of behavior is\n\t * on them. Plus anyway recently chrome has started to actually kill tabs that are open for too long\n\t * rather than just suspending them, so if other browsers follow suit maybe it's less of a concern.\n\t *\n\t * @public\n\t */\n\treadonly down?: 'none' | 'retired' | ((props: any) => any)\n}\n\n/**\n * @public\n */\nexport interface TLPropsMigrations {\n\treadonly sequence: Array<StandaloneDependsOn | TLPropsMigration>\n}\n\nexport function processPropsMigrations<R extends UnknownRecord & { type: string; props: object }>(\n\ttypeName: R['typeName'],\n\trecords: Record<string, SchemaPropsInfo>\n) {\n\tconst result: MigrationSequence[] = []\n\n\tfor (const [subType, { migrations }] of Object.entries(records)) {\n\t\tconst sequenceId = `com.tldraw.${typeName}.${subType}`\n\t\tif (!migrations) {\n\t\t\t// provide empty migrations sequence to allow for future migrations\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: false,\n\t\t\t\t\tsequence: [],\n\t\t\t\t})\n\t\t\t)\n\t\t} else if ('sequenceId' in migrations) {\n\t\t\tassert(\n\t\t\t\tsequenceId === migrations.sequenceId,\n\t\t\t\t`sequenceId mismatch for ${subType} ${RecordType} migrations. Expected '${sequenceId}', got '${migrations.sequenceId}'`\n\t\t\t)\n\t\t\tresult.push(migrations)\n\t\t} else if ('sequence' in migrations) {\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: false,\n\t\t\t\t\tsequence: migrations.sequence.map((m) =>\n\t\t\t\t\t\t'id' in m ? createPropsMigration(typeName, subType, m) : m\n\t\t\t\t\t),\n\t\t\t\t})\n\t\t\t)\n\t\t} else {\n\t\t\t// legacy migrations, will be removed in the future\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: false,\n\t\t\t\t\tsequence: Object.keys(migrations.migrators)\n\t\t\t\t\t\t.map((k) => Number(k))\n\t\t\t\t\t\t.sort((a: number, b: number) => a - b)\n\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t(version): Migration => ({\n\t\t\t\t\t\t\t\tid: `${sequenceId}/${version}`,\n\t\t\t\t\t\t\t\tscope: 'record',\n\t\t\t\t\t\t\t\tfilter: (r) => r.typeName === typeName && (r as R).type === subType,\n\t\t\t\t\t\t\t\tup: (record: any) => {\n\t\t\t\t\t\t\t\t\tconst result = migrations.migrators[version].up(record)\n\t\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tdown: (record: any) => {\n\t\t\t\t\t\t\t\t\tconst result = migrations.migrators[version].down(record)\n\t\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t),\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}\n\n\treturn result\n}\n\nexport function createPropsMigration<R extends UnknownRecord & { type: string; props: object }>(\n\ttypeName: R['typeName'],\n\tsubType: R['type'],\n\tm: TLPropsMigration\n): Migration {\n\treturn {\n\t\tid: m.id,\n\t\tdependsOn: m.dependsOn,\n\t\tscope: 'record',\n\t\tfilter: (r) => r.typeName === typeName && (r as R).type === subType,\n\t\tup: (record: any) => {\n\t\t\tconst result = m.up(record.props)\n\t\t\tif (result) {\n\t\t\t\trecord.props = result\n\t\t\t}\n\t\t},\n\t\tdown:\n\t\t\ttypeof m.down === 'function'\n\t\t\t\t? (record: any) => {\n\t\t\t\t\t\tconst result = (m.down as (props: any) => any)(record.props)\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\trecord.props = result\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t}\n}\n", "import { Expand } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/** @public */\nexport const defaultColorNames = [\n\t'black',\n\t'grey',\n\t'light-violet',\n\t'violet',\n\t'blue',\n\t'light-blue',\n\t'yellow',\n\t'orange',\n\t'green',\n\t'light-green',\n\t'light-red',\n\t'red',\n\t'white',\n] as const\n\n/** @public */\nexport interface TLDefaultColorThemeColor {\n\tsolid: string\n\tsemi: string\n\tpattern: string\n\tfill: string // same as solid\n\tnote: {\n\t\tfill: string\n\t\ttext: string\n\t}\n\thighlight: {\n\t\tsrgb: string\n\t\tp3: string\n\t}\n}\n\n/** @public */\nexport type TLDefaultColorTheme = Expand<\n\t{\n\t\tid: 'light' | 'dark'\n\t\ttext: string\n\t\tbackground: string\n\t\tsolid: string\n\t} & Record<(typeof defaultColorNames)[number], TLDefaultColorThemeColor>\n>\n\n/** @public */\nexport const DefaultColorThemePalette: {\n\tlightMode: TLDefaultColorTheme\n\tdarkMode: TLDefaultColorTheme\n} = {\n\tlightMode: {\n\t\tid: 'light',\n\t\ttext: '#000000',\n\t\tbackground: 'rgb(249, 250, 251)',\n\t\tsolid: '#fcfffe',\n\t\tblack: {\n\t\t\tsolid: '#1d1d1d',\n\t\t\tfill: '#1d1d1d',\n\t\t\tnote: {\n\t\t\t\tfill: '#FCE19C',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#e8e8e8',\n\t\t\tpattern: '#494949',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#fddd00',\n\t\t\t\tp3: 'color(display-p3 0.972 0.8705 0.05)',\n\t\t\t},\n\t\t},\n\t\tblue: {\n\t\t\tsolid: '#4465e9',\n\t\t\tfill: '#4465e9',\n\t\t\tnote: {\n\t\t\t\tfill: '#8AA3FF',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#dce1f8',\n\t\t\tpattern: '#6681ee',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#10acff',\n\t\t\t\tp3: 'color(display-p3 0.308 0.6632 0.9996)',\n\t\t\t},\n\t\t},\n\t\tgreen: {\n\t\t\tsolid: '#099268',\n\t\t\tfill: '#099268',\n\t\t\tnote: {\n\t\t\t\tfill: '#6FC896',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#d3e9e3',\n\t\t\tpattern: '#39a785',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#00ffc8',\n\t\t\t\tp3: 'color(display-p3 0.2536 0.984 0.7981)',\n\t\t\t},\n\t\t},\n\t\tgrey: {\n\t\t\tsolid: '#9fa8b2',\n\t\t\tfill: '#9fa8b2',\n\t\t\tnote: {\n\t\t\t\tfill: '#C0CAD3',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#eceef0',\n\t\t\tpattern: '#bcc3c9',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#cbe7f1',\n\t\t\t\tp3: 'color(display-p3 0.8163 0.9023 0.9416)',\n\t\t\t},\n\t\t},\n\t\t'light-blue': {\n\t\t\tsolid: '#4ba1f1',\n\t\t\tfill: '#4ba1f1',\n\t\t\tnote: {\n\t\t\t\tfill: '#9BC4FD',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#ddedfa',\n\t\t\tpattern: '#6fbbf8',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#00f4ff',\n\t\t\t\tp3: 'color(display-p3 0.1512 0.9414 0.9996)',\n\t\t\t},\n\t\t},\n\t\t'light-green': {\n\t\t\tsolid: '#4cb05e',\n\t\t\tfill: '#4cb05e',\n\t\t\tnote: {\n\t\t\t\tfill: '#98D08A',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#dbf0e0',\n\t\t\tpattern: '#65cb78',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#65f641',\n\t\t\t\tp3: 'color(display-p3 0.563 0.9495 0.3857)',\n\t\t\t},\n\t\t},\n\t\t'light-red': {\n\t\t\tsolid: '#f87777',\n\t\t\tfill: '#f87777',\n\t\t\tnote: {\n\t\t\t\tfill: '#F7A5A1',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#f4dadb',\n\t\t\tpattern: '#fe9e9e',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#ff7fa3',\n\t\t\t\tp3: 'color(display-p3 0.9988 0.5301 0.6397)',\n\t\t\t},\n\t\t},\n\t\t'light-violet': {\n\t\t\tsolid: '#e085f4',\n\t\t\tfill: '#e085f4',\n\t\t\tnote: {\n\t\t\t\tfill: '#DFB0F9',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#f5eafa',\n\t\t\tpattern: '#e9acf8',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#ff88ff',\n\t\t\t\tp3: 'color(display-p3 0.9676 0.5652 0.9999)',\n\t\t\t},\n\t\t},\n\t\torange: {\n\t\t\tsolid: '#e16919',\n\t\t\tfill: '#e16919',\n\t\t\tnote: {\n\t\t\t\tfill: '#FAA475',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#f8e2d4',\n\t\t\tpattern: '#f78438',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#ffa500',\n\t\t\t\tp3: 'color(display-p3 0.9988 0.6905 0.266)',\n\t\t\t},\n\t\t},\n\t\tred: {\n\t\t\tsolid: '#e03131',\n\t\t\tfill: '#e03131',\n\t\t\tnote: {\n\t\t\t\tfill: '#FC8282',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#f4dadb',\n\t\t\tpattern: '#e55959',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#ff636e',\n\t\t\t\tp3: 'color(display-p3 0.9992 0.4376 0.45)',\n\t\t\t},\n\t\t},\n\t\tviolet: {\n\t\t\tsolid: '#ae3ec9',\n\t\t\tfill: '#ae3ec9',\n\t\t\tnote: {\n\t\t\t\tfill: '#DB91FD',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#ecdcf2',\n\t\t\tpattern: '#bd63d3',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#c77cff',\n\t\t\t\tp3: 'color(display-p3 0.7469 0.5089 0.9995)',\n\t\t\t},\n\t\t},\n\t\tyellow: {\n\t\t\tsolid: '#f1ac4b',\n\t\t\tfill: '#f1ac4b',\n\t\t\tnote: {\n\t\t\t\tfill: '#FED49A',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\tsemi: '#f9f0e6',\n\t\t\tpattern: '#fecb92',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#fddd00',\n\t\t\t\tp3: 'color(display-p3 0.972 0.8705 0.05)',\n\t\t\t},\n\t\t},\n\t\twhite: {\n\t\t\tsolid: '#FFFFFF',\n\t\t\tfill: '#FFFFFF',\n\t\t\tsemi: '#f5f5f5',\n\t\t\tpattern: '#f9f9f9',\n\t\t\tnote: {\n\t\t\t\tfill: '#FFFFFF',\n\t\t\t\ttext: '#000000',\n\t\t\t},\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#ffffff',\n\t\t\t\tp3: 'color(display-p3 1 1 1)',\n\t\t\t},\n\t\t},\n\t},\n\tdarkMode: {\n\t\tid: 'dark',\n\t\ttext: 'hsl(210, 17%, 98%)',\n\t\tbackground: 'hsl(240, 5%, 6.5%)',\n\t\tsolid: '#010403',\n\n\t\tblack: {\n\t\t\tsolid: '#f2f2f2',\n\t\t\tfill: '#f2f2f2',\n\t\t\tnote: {\n\t\t\t\tfill: '#2c2c2c',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#2c3036',\n\t\t\tpattern: '#989898',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#d2b700',\n\t\t\t\tp3: 'color(display-p3 0.8078 0.7225 0.0312)',\n\t\t\t},\n\t\t},\n\t\tblue: {\n\t\t\tsolid: '#4f72fc', // 3c60f0\n\t\t\tfill: '#4f72fc',\n\t\t\tnote: {\n\t\t\t\tfill: '#2A3F98',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#262d40',\n\t\t\tpattern: '#3a4b9e',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#0079d2',\n\t\t\t\tp3: 'color(display-p3 0.0032 0.4655 0.7991)',\n\t\t\t},\n\t\t},\n\t\tgreen: {\n\t\t\tsolid: '#099268',\n\t\t\tfill: '#099268',\n\t\t\tnote: {\n\t\t\t\tfill: '#014429',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#253231',\n\t\t\tpattern: '#366a53',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#009774',\n\t\t\t\tp3: 'color(display-p3 0.0085 0.582 0.4604)',\n\t\t\t},\n\t\t},\n\t\tgrey: {\n\t\t\tsolid: '#9398b0',\n\t\t\tfill: '#9398b0',\n\t\t\tnote: {\n\t\t\t\tfill: '#56595F',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#33373c',\n\t\t\tpattern: '#7c8187',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#9cb4cb',\n\t\t\t\tp3: 'color(display-p3 0.6299 0.7012 0.7856)',\n\t\t\t},\n\t\t},\n\t\t'light-blue': {\n\t\t\tsolid: '#4dabf7',\n\t\t\tfill: '#4dabf7',\n\t\t\tnote: {\n\t\t\t\tfill: '#1F5495',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#2a3642',\n\t\t\tpattern: '#4d7aa9',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#00bdc8',\n\t\t\t\tp3: 'color(display-p3 0.0023 0.7259 0.7735)',\n\t\t\t},\n\t\t},\n\t\t'light-green': {\n\t\t\tsolid: '#40c057',\n\t\t\tfill: '#40c057',\n\t\t\tnote: {\n\t\t\t\tfill: '#21581D',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#2a3830',\n\t\t\tpattern: '#4e874e',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#00a000',\n\t\t\t\tp3: 'color(display-p3 0.2711 0.6172 0.0195)',\n\t\t\t},\n\t\t},\n\t\t'light-red': {\n\t\t\tsolid: '#ff8787',\n\t\t\tfill: '#ff8787',\n\t\t\tnote: {\n\t\t\t\tfill: '#923632',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#3b3235',\n\t\t\tpattern: '#a56767',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#db005b',\n\t\t\t\tp3: 'color(display-p3 0.7849 0.0585 0.3589)',\n\t\t\t},\n\t\t},\n\t\t'light-violet': {\n\t\t\tsolid: '#e599f7',\n\t\t\tfill: '#e599f7',\n\t\t\tnote: {\n\t\t\t\tfill: '#762F8E',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#383442',\n\t\t\tpattern: '#9770a9',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#c400c7',\n\t\t\t\tp3: 'color(display-p3 0.7024 0.0403 0.753)',\n\t\t\t},\n\t\t},\n\t\torange: {\n\t\t\tsolid: '#f76707',\n\t\t\tfill: '#f76707',\n\t\t\tnote: {\n\t\t\t\tfill: '#843906',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#3a2e2a',\n\t\t\tpattern: '#9f552d',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#d07a00',\n\t\t\t\tp3: 'color(display-p3 0.7699 0.4937 0.0085)',\n\t\t\t},\n\t\t},\n\t\tred: {\n\t\t\tsolid: '#e03131',\n\t\t\tfill: '#e03131',\n\t\t\tnote: {\n\t\t\t\tfill: '#89231A',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#36292b',\n\t\t\tpattern: '#8f3734',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#de002c',\n\t\t\t\tp3: 'color(display-p3 0.7978 0.0509 0.2035)',\n\t\t\t},\n\t\t},\n\t\tviolet: {\n\t\t\tsolid: '#ae3ec9',\n\t\t\tfill: '#ae3ec9',\n\t\t\tnote: {\n\t\t\t\tfill: '#681683',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#31293c',\n\t\t\tpattern: '#763a8b',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#9e00ee',\n\t\t\t\tp3: 'color(display-p3 0.5651 0.0079 0.8986)',\n\t\t\t},\n\t\t},\n\t\tyellow: {\n\t\t\tsolid: '#ffc034',\n\t\t\tfill: '#ffc034',\n\t\t\tnote: {\n\t\t\t\tfill: '#98571B',\n\t\t\t\ttext: '#f2f2f2',\n\t\t\t},\n\t\t\tsemi: '#3c3934',\n\t\t\tpattern: '#fecb92',\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#d2b700',\n\t\t\t\tp3: 'color(display-p3 0.8078 0.7225 0.0312)',\n\t\t\t},\n\t\t},\n\t\twhite: {\n\t\t\tsolid: '#f3f3f3',\n\t\t\tfill: '#f3f3f3',\n\t\t\tsemi: '#f5f5f5',\n\t\t\tpattern: '#f9f9f9',\n\t\t\tnote: {\n\t\t\t\tfill: '#eaeaea',\n\t\t\t\ttext: '#1d1d1d',\n\t\t\t},\n\t\t\thighlight: {\n\t\t\t\tsrgb: '#ffffff',\n\t\t\t\tp3: 'color(display-p3 1 1 1)',\n\t\t\t},\n\t\t},\n\t},\n}\n\n/** @public */\nexport function getDefaultColorTheme(opts: { isDarkMode: boolean }): TLDefaultColorTheme {\n\treturn opts.isDarkMode ? DefaultColorThemePalette.darkMode : DefaultColorThemePalette.lightMode\n}\n\n/** @public */\nexport const DefaultColorStyle = StyleProp.defineEnum('tldraw:color', {\n\tdefaultValue: 'black',\n\tvalues: defaultColorNames,\n})\n\n/** @public */\nexport const DefaultLabelColorStyle = StyleProp.defineEnum('tldraw:labelColor', {\n\tdefaultValue: 'black',\n\tvalues: defaultColorNames,\n})\n\n/** @public */\nexport type TLDefaultColorStyle = T.TypeOf<typeof DefaultColorStyle>\n", "import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/** @public */\nexport const DefaultDashStyle = StyleProp.defineEnum('tldraw:dash', {\n\tdefaultValue: 'draw',\n\tvalues: ['draw', 'solid', 'dashed', 'dotted'],\n})\n\n/** @public */\nexport type TLDefaultDashStyle = T.TypeOf<typeof DefaultDashStyle>\n", "import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/** @public */\nexport const DefaultFillStyle = StyleProp.defineEnum('tldraw:fill', {\n\tdefaultValue: 'none',\n\tvalues: ['none', 'semi', 'solid', 'pattern', 'fill'],\n})\n\n/** @public */\nexport type TLDefaultFillStyle = T.TypeOf<typeof DefaultFillStyle>\n", "import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/** @public */\nexport const DefaultFontStyle = StyleProp.defineEnum('tldraw:font', {\n\tdefaultValue: 'draw',\n\tvalues: ['draw', 'sans', 'serif', 'mono'],\n})\n\n/** @public */\nexport type TLDefaultFontStyle = T.TypeOf<typeof DefaultFontStyle>\n\n/** @public */\nexport const DefaultFontFamilies = {\n\tdraw: \"'tldraw_draw', sans-serif\",\n\tsans: \"'tldraw_sans', sans-serif\",\n\tserif: \"'tldraw_serif', serif\",\n\tmono: \"'tldraw_mono', monospace\",\n}\n", "import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/** @public */\nexport const DefaultSizeStyle = StyleProp.defineEnum('tldraw:size', {\n\tdefaultValue: 'm',\n\tvalues: ['s', 'm', 'l', 'xl'],\n})\n\n/** @public */\nexport type TLDefaultSizeStyle = T.TypeOf<typeof DefaultSizeStyle>\n", "import { Signal, computed } from '@tldraw/state'\nimport { TLStore } from './TLStore'\nimport { CameraRecordType } from './records/TLCamera'\nimport { TLINSTANCE_ID } from './records/TLInstance'\nimport { InstancePageStateRecordType } from './records/TLPageState'\nimport { TLPOINTER_ID } from './records/TLPointer'\nimport { InstancePresenceRecordType, TLInstancePresence } from './records/TLPresence'\n\n/**\n * Creates a derivation that represents the current presence state of the current user.\n * @public\n */\nexport function createPresenceStateDerivation(\n\t$user: Signal<{ id: string; color: string; name: string }>,\n\tinstanceId?: TLInstancePresence['id']\n) {\n\treturn (store: TLStore): Signal<TLInstancePresence | null> => {\n\t\treturn computed('instancePresence', () => {\n\t\t\tconst instance = store.get(TLINSTANCE_ID)\n\t\t\tconst pageState = store.get(InstancePageStateRecordType.createId(instance?.currentPageId))\n\t\t\tconst camera = store.get(CameraRecordType.createId(instance?.currentPageId))\n\t\t\tconst pointer = store.get(TLPOINTER_ID)\n\t\t\tconst user = $user.get()\n\t\t\tif (!pageState || !instance || !camera || !pointer || !user) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\treturn InstancePresenceRecordType.create({\n\t\t\t\tid: instanceId ?? InstancePresenceRecordType.createId(store.id),\n\t\t\t\tselectedShapeIds: pageState.selectedShapeIds,\n\t\t\t\tbrush: instance.brush,\n\t\t\t\tscribbles: instance.scribbles,\n\t\t\t\tuserId: user.id,\n\t\t\t\tuserName: user.name,\n\t\t\t\tfollowingUserId: instance.followingUserId,\n\t\t\t\tcamera: {\n\t\t\t\t\tx: camera.x,\n\t\t\t\t\ty: camera.y,\n\t\t\t\t\tz: camera.z,\n\t\t\t\t},\n\t\t\t\tcolor: user.color,\n\t\t\t\tcurrentPageId: instance.currentPageId,\n\t\t\t\tcursor: {\n\t\t\t\t\tx: pointer.x,\n\t\t\t\t\ty: pointer.y,\n\t\t\t\t\trotation: instance.cursor.rotation,\n\t\t\t\t\ttype: instance.cursor.type,\n\t\t\t\t},\n\t\t\t\tlastActivityTimestamp: pointer.lastActivityTimestamp,\n\t\t\t\tscreenBounds: instance.screenBounds,\n\t\t\t\tchatMessage: instance.chatMessage,\n\t\t\t\tmeta: {},\n\t\t\t})\n\t\t})\n\t}\n}\n", "import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\n\n/**\n * A camera record.\n *\n * @public\n */\nexport interface TLCamera extends BaseRecord<'camera', TLCameraId> {\n\tx: number\n\ty: number\n\tz: number\n\tmeta: JsonObject\n}\n\n/**\n * The id of a camera record.\n *\n * @public */\nexport type TLCameraId = RecordId<TLCamera>\n\n/** @public */\nexport const cameraValidator: T.Validator<TLCamera> = T.model(\n\t'camera',\n\tT.object({\n\t\ttypeName: T.literal('camera'),\n\t\tid: idValidator<TLCameraId>('camera'),\n\t\tx: T.number,\n\t\ty: T.number,\n\t\tz: T.number,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/** @public */\nexport const cameraVersions = createMigrationIds('com.tldraw.camera', {\n\tAddMeta: 1,\n})\n\n/** @public */\nexport const cameraMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.camera',\n\trecordType: 'camera',\n\tsequence: [\n\t\t{\n\t\t\tid: cameraVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\t;(record as any).meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport const CameraRecordType = createRecordType<TLCamera>('camera', {\n\tvalidator: cameraValidator,\n\tscope: 'session',\n}).withDefaultProperties(\n\t(): Omit<TLCamera, 'id' | 'typeName'> => ({\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 1,\n\t\tmeta: {},\n\t})\n)\n", "import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { filterEntries, JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { BoxModel, boxModelValidator } from '../misc/geometry-types'\nimport { idValidator } from '../misc/id-validator'\nimport { cursorValidator, TLCursor } from '../misc/TLCursor'\nimport { opacityValidator, TLOpacityType } from '../misc/TLOpacity'\nimport { scribbleValidator, TLScribble } from '../misc/TLScribble'\nimport { StyleProp } from '../styles/StyleProp'\nimport { pageIdValidator, TLPageId } from './TLPage'\nimport { TLShapeId } from './TLShape'\n\n/**\n * TLInstance\n *\n * State that is particular to a single browser tab\n *\n * @public\n */\nexport interface TLInstance extends BaseRecord<'instance', TLInstanceId> {\n\tcurrentPageId: TLPageId\n\topacityForNextShape: TLOpacityType\n\tstylesForNextShape: Record<string, unknown>\n\tfollowingUserId: string | null\n\thighlightedUserIds: string[]\n\tbrush: BoxModel | null\n\tcursor: TLCursor\n\tscribbles: TLScribble[]\n\tisFocusMode: boolean\n\tisDebugMode: boolean\n\tisToolLocked: boolean\n\texportBackground: boolean\n\tscreenBounds: BoxModel\n\tinsets: boolean[]\n\tzoomBrush: BoxModel | null\n\tchatMessage: string\n\tisChatting: boolean\n\tisPenMode: boolean\n\tisGridMode: boolean\n\tisFocused: boolean\n\tdevicePixelRatio: number\n\t/**\n\t * This is whether the primary input mechanism includes a pointing device of limited accuracy,\n\t * such as a finger on a touchscreen.\n\t */\n\tisCoarsePointer: boolean\n\t/**\n\t * Will be null if the pointer doesn't support hovering (e.g. touch), but true or false\n\t * otherwise\n\t */\n\tisHoveringCanvas: boolean | null\n\topenMenus: string[]\n\tisChangingStyle: boolean\n\tisReadonly: boolean\n\tmeta: JsonObject\n\tduplicateProps: {\n\t\tshapeIds: TLShapeId[]\n\t\toffset: {\n\t\t\tx: number\n\t\t\ty: number\n\t\t}\n\t} | null\n}\n\n/** @internal */\nexport const shouldKeyBePreservedBetweenSessions = {\n\t// This object defines keys that should be preserved across calls to loadSnapshot()\n\n\tid: false, // meta\n\ttypeName: false, // meta\n\n\tcurrentPageId: false, // does not preserve because who knows if the page still exists\n\topacityForNextShape: false, // does not preserve because it's a temporary state\n\tstylesForNextShape: false, // does not preserve because it's a temporary state\n\tfollowingUserId: false, // does not preserve because it's a temporary state\n\thighlightedUserIds: false, // does not preserve because it's a temporary state\n\tbrush: false, // does not preserve because it's a temporary state\n\tcursor: false, // does not preserve because it's a temporary state\n\tscribbles: false, // does not preserve because it's a temporary state\n\n\tisFocusMode: true, // preserves because it's a user preference\n\tisDebugMode: true, // preserves because it's a user preference\n\tisToolLocked: true, // preserves because it's a user preference\n\texportBackground: true, // preserves because it's a user preference\n\tscreenBounds: true, // preserves because it's capturing the user's screen state\n\tinsets: true, // preserves because it's capturing the user's screen state\n\n\tzoomBrush: false, // does not preserve because it's a temporary state\n\tchatMessage: false, // does not preserve because it's a temporary state\n\tisChatting: false, // does not preserve because it's a temporary state\n\tisPenMode: false, // does not preserve because it's a temporary state\n\n\tisGridMode: true, // preserves because it's a user preference\n\tisFocused: true, // preserves because obviously\n\tdevicePixelRatio: true, // preserves because it captures the user's screen state\n\tisCoarsePointer: true, // preserves because it captures the user's screen state\n\tisHoveringCanvas: false, // does not preserve because it's a temporary state\n\topenMenus: false, // does not preserve because it's a temporary state\n\tisChangingStyle: false, // does not preserve because it's a temporary state\n\tisReadonly: true, // preserves because it's a config option\n\tmeta: false, // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate\n\tduplicateProps: false, //\n} as const satisfies { [K in keyof TLInstance]: boolean }\n\n/** @internal */\nexport function pluckPreservingValues(val?: TLInstance | null): null | Partial<TLInstance> {\n\treturn val\n\t\t? (filterEntries(val, (key) => {\n\t\t\t\treturn shouldKeyBePreservedBetweenSessions[key as keyof TLInstance]\n\t\t\t}) as Partial<TLInstance>)\n\t\t: null\n}\n\n/** @public */\nexport type TLInstanceId = RecordId<TLInstance>\n\n/** @public */\nexport const instanceIdValidator = idValidator<TLInstanceId>('instance')\n\nexport function createInstanceRecordType(stylesById: Map<string, StyleProp<unknown>>) {\n\tconst stylesForNextShapeValidators = {} as Record<string, T.Validator<unknown>>\n\tfor (const [id, style] of stylesById) {\n\t\tstylesForNextShapeValidators[id] = T.optional(style)\n\t}\n\n\tconst instanceTypeValidator: T.Validator<TLInstance> = T.model(\n\t\t'instance',\n\t\tT.object({\n\t\t\ttypeName: T.literal('instance'),\n\t\t\tid: idValidator<TLInstanceId>('instance'),\n\t\t\tcurrentPageId: pageIdValidator,\n\t\t\tfollowingUserId: T.string.nullable(),\n\t\t\tbrush: boxModelValidator.nullable(),\n\t\t\topacityForNextShape: opacityValidator,\n\t\t\tstylesForNextShape: T.object(stylesForNextShapeValidators),\n\t\t\tcursor: cursorValidator,\n\t\t\tscribbles: T.arrayOf(scribbleValidator),\n\t\t\tisFocusMode: T.boolean,\n\t\t\tisDebugMode: T.boolean,\n\t\t\tisToolLocked: T.boolean,\n\t\t\texportBackground: T.boolean,\n\t\t\tscreenBounds: boxModelValidator,\n\t\t\tinsets: T.arrayOf(T.boolean),\n\t\t\tzoomBrush: boxModelValidator.nullable(),\n\t\t\tisPenMode: T.boolean,\n\t\t\tisGridMode: T.boolean,\n\t\t\tchatMessage: T.string,\n\t\t\tisChatting: T.boolean,\n\t\t\thighlightedUserIds: T.arrayOf(T.string),\n\t\t\tisFocused: T.boolean,\n\t\t\tdevicePixelRatio: T.number,\n\t\t\tisCoarsePointer: T.boolean,\n\t\t\tisHoveringCanvas: T.boolean.nullable(),\n\t\t\topenMenus: T.arrayOf(T.string),\n\t\t\tisChangingStyle: T.boolean,\n\t\t\tisReadonly: T.boolean,\n\t\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t\t\tduplicateProps: T.object({\n\t\t\t\tshapeIds: T.arrayOf(idValidator<TLShapeId>('shape')),\n\t\t\t\toffset: T.object({\n\t\t\t\t\tx: T.number,\n\t\t\t\t\ty: T.number,\n\t\t\t\t}),\n\t\t\t}).nullable(),\n\t\t})\n\t)\n\n\treturn createRecordType<TLInstance>('instance', {\n\t\tvalidator: instanceTypeValidator,\n\t\tscope: 'session',\n\t\tephemeralKeys: {\n\t\t\tcurrentPageId: false,\n\t\t\tmeta: false,\n\n\t\t\tfollowingUserId: true,\n\t\t\topacityForNextShape: true,\n\t\t\tstylesForNextShape: true,\n\t\t\tbrush: true,\n\t\t\tcursor: true,\n\t\t\tscribbles: true,\n\t\t\tisFocusMode: true,\n\t\t\tisDebugMode: true,\n\t\t\tisToolLocked: true,\n\t\t\texportBackground: true,\n\t\t\tscreenBounds: true,\n\t\t\tinsets: true,\n\t\t\tzoomBrush: true,\n\t\t\tisPenMode: true,\n\t\t\tisGridMode: true,\n\t\t\tchatMessage: true,\n\t\t\tisChatting: true,\n\t\t\thighlightedUserIds: true,\n\t\t\tisFocused: true,\n\t\t\tdevicePixelRatio: true,\n\t\t\tisCoarsePointer: true,\n\t\t\tisHoveringCanvas: true,\n\t\t\topenMenus: true,\n\t\t\tisChangingStyle: true,\n\t\t\tisReadonly: true,\n\t\t\tduplicateProps: true,\n\t\t},\n\t}).withDefaultProperties(\n\t\t(): Omit<TLInstance, 'typeName' | 'id' | 'currentPageId'> => ({\n\t\t\tfollowingUserId: null,\n\t\t\topacityForNextShape: 1,\n\t\t\tstylesForNextShape: {},\n\t\t\tbrush: null,\n\t\t\tscribbles: [],\n\t\t\tcursor: {\n\t\t\t\ttype: 'default',\n\t\t\t\trotation: 0,\n\t\t\t},\n\t\t\tisFocusMode: false,\n\t\t\texportBackground: false,\n\t\t\tisDebugMode: false,\n\t\t\tisToolLocked: false,\n\t\t\tscreenBounds: { x: 0, y: 0, w: 1080, h: 720 },\n\t\t\tinsets: [false, false, false, false],\n\t\t\tzoomBrush: null,\n\t\t\tisGridMode: false,\n\t\t\tisPenMode: false,\n\t\t\tchatMessage: '',\n\t\t\tisChatting: false,\n\t\t\thighlightedUserIds: [],\n\t\t\tisFocused: false,\n\t\t\tdevicePixelRatio: typeof window === 'undefined' ? 1 : window.devicePixelRatio,\n\t\t\tisCoarsePointer: false,\n\t\t\tisHoveringCanvas: null,\n\t\t\topenMenus: [] as string[],\n\t\t\tisChangingStyle: false,\n\t\t\tisReadonly: false,\n\t\t\tmeta: {},\n\t\t\tduplicateProps: null,\n\t\t})\n\t)\n}\n\n/** @public */\nexport const instanceVersions = createMigrationIds('com.tldraw.instance', {\n\tAddTransparentExportBgs: 1,\n\tRemoveDialog: 2,\n\tAddToolLockMode: 3,\n\tRemoveExtraPropsForNextShape: 4,\n\tAddLabelColor: 5,\n\tAddFollowingUserId: 6,\n\tRemoveAlignJustify: 7,\n\tAddZoom: 8,\n\tAddVerticalAlign: 9,\n\tAddScribbleDelay: 10,\n\tRemoveUserId: 11,\n\tAddIsPenModeAndIsGridMode: 12,\n\tHoistOpacity: 13,\n\tAddChat: 14,\n\tAddHighlightedUserIds: 15,\n\tReplacePropsForNextShapeWithStylesForNextShape: 16,\n\tAddMeta: 17,\n\tRemoveCursorColor: 18,\n\tAddLonelyProperties: 19,\n\tReadOnlyReadonly: 20,\n\tAddHoveringCanvas: 21,\n\tAddScribbles: 22,\n\tAddInset: 23,\n\tAddDuplicateProps: 24,\n\tRemoveCanMoveCamera: 25,\n} as const)\n\n// TODO: rewrite these to use mutation\n\n/** @public */\nexport const instanceMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.instance',\n\trecordType: 'instance',\n\tsequence: [\n\t\t{\n\t\t\tid: instanceVersions.AddTransparentExportBgs,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, exportBackground: true }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveDialog,\n\t\t\tup: ({ dialog: _, ...instance }: any) => {\n\t\t\t\treturn instance\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\tid: instanceVersions.AddToolLockMode,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, isToolLocked: false }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveExtraPropsForNextShape,\n\t\t\tup: ({ propsForNextShape, ...instance }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...instance,\n\t\t\t\t\tpropsForNextShape: Object.fromEntries(\n\t\t\t\t\t\tObject.entries(propsForNextShape).filter(([key]) =>\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t'color',\n\t\t\t\t\t\t\t\t'labelColor',\n\t\t\t\t\t\t\t\t'dash',\n\t\t\t\t\t\t\t\t'fill',\n\t\t\t\t\t\t\t\t'size',\n\t\t\t\t\t\t\t\t'font',\n\t\t\t\t\t\t\t\t'align',\n\t\t\t\t\t\t\t\t'verticalAlign',\n\t\t\t\t\t\t\t\t'icon',\n\t\t\t\t\t\t\t\t'geo',\n\t\t\t\t\t\t\t\t'arrowheadStart',\n\t\t\t\t\t\t\t\t'arrowheadEnd',\n\t\t\t\t\t\t\t\t'spline',\n\t\t\t\t\t\t\t].includes(key)\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddLabelColor,\n\t\t\tup: ({ propsForNextShape, ...instance }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...instance,\n\t\t\t\t\tpropsForNextShape: {\n\t\t\t\t\t\t...propsForNextShape,\n\t\t\t\t\t\tlabelColor: 'black',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddFollowingUserId,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, followingUserId: null }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveAlignJustify,\n\t\t\tup: (instance: any) => {\n\t\t\t\tlet newAlign = instance.propsForNextShape.align\n\t\t\t\tif (newAlign === 'justify') {\n\t\t\t\t\tnewAlign = 'start'\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...instance,\n\t\t\t\t\tpropsForNextShape: {\n\t\t\t\t\t\t...instance.propsForNextShape,\n\t\t\t\t\t\talign: newAlign,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddZoom,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, zoomBrush: null }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddVerticalAlign,\n\t\t\tup: (instance: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...instance,\n\t\t\t\t\tpropsForNextShape: {\n\t\t\t\t\t\t...instance.propsForNextShape,\n\t\t\t\t\t\tverticalAlign: 'middle',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddScribbleDelay,\n\t\t\tup: (instance: any) => {\n\t\t\t\tif (instance.scribble !== null) {\n\t\t\t\t\treturn { ...instance, scribble: { ...instance.scribble, delay: 0 } }\n\t\t\t\t}\n\t\t\t\treturn { ...instance }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveUserId,\n\t\t\tup: ({ userId: _, ...instance }: any) => {\n\t\t\t\treturn instance\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddIsPenModeAndIsGridMode,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, isPenMode: false, isGridMode: false }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.HoistOpacity,\n\t\t\tup: ({ propsForNextShape: { opacity, ...propsForNextShape }, ...instance }: any) => {\n\t\t\t\treturn { ...instance, opacityForNextShape: Number(opacity ?? '1'), propsForNextShape }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddChat,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, chatMessage: '', isChatting: false }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddHighlightedUserIds,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, highlightedUserIds: [] }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.ReplacePropsForNextShapeWithStylesForNextShape,\n\t\t\tup: ({ propsForNextShape: _, ...instance }: any) => {\n\t\t\t\treturn { ...instance, stylesForNextShape: {} }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tmeta: {},\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveCursorColor,\n\t\t\tup: (record: any) => {\n\t\t\t\tconst { color: _, ...cursor } = record.cursor\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tcursor,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddLonelyProperties,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tcanMoveCamera: true,\n\t\t\t\t\tisFocused: false,\n\t\t\t\t\tdevicePixelRatio: 1,\n\t\t\t\t\tisCoarsePointer: false,\n\t\t\t\t\topenMenus: [],\n\t\t\t\t\tisChangingStyle: false,\n\t\t\t\t\tisReadOnly: false,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.ReadOnlyReadonly,\n\t\t\tup: ({ isReadOnly: _isReadOnly, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tisReadonly: _isReadOnly,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddHoveringCanvas,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tisHoveringCanvas: null,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddScribbles,\n\t\t\tup: ({ scribble: _, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tscribbles: [],\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddInset,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tinsets: [false, false, false, false],\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: ({ insets: _, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddDuplicateProps,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tduplicateProps: null,\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: ({ duplicateProps: _, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveCanMoveCamera,\n\t\t\tup: ({ canMoveCamera: _, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (instance) => {\n\t\t\t\treturn { ...instance, canMoveCamera: true }\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport const TLINSTANCE_ID = 'instance:instance' as TLInstanceId\n", "import { T } from '@tldraw/validate'\nimport { SetValue } from '../util-types'\n\n/**\n * The cursor types used by tldraw's default shapes.\n *\n * @public */\nexport const TL_CURSOR_TYPES = new Set([\n\t'none',\n\t'default',\n\t'pointer',\n\t'cross',\n\t'grab',\n\t'rotate',\n\t'grabbing',\n\t'resize-edge',\n\t'resize-corner',\n\t'text',\n\t'move',\n\t'ew-resize',\n\t'ns-resize',\n\t'nesw-resize',\n\t'nwse-resize',\n\t'nesw-rotate',\n\t'nwse-rotate',\n\t'swne-rotate',\n\t'senw-rotate',\n\t'zoom-in',\n\t'zoom-out',\n])\n\n/**\n * A type for the cursor types used by tldraw's default shapes.\n *\n *  @public */\nexport type TLCursorType = SetValue<typeof TL_CURSOR_TYPES>\n\n/** @public */\nexport const cursorTypeValidator = T.setEnum(TL_CURSOR_TYPES)\n\n/**\n * A cursor used by tldraw.\n *\n *  @public */\nexport interface TLCursor {\n\ttype: TLCursorType\n\trotation: number\n}\n\n/** @public */\nexport const cursorValidator: T.ObjectValidator<TLCursor> = T.object<TLCursor>({\n\ttype: cursorTypeValidator,\n\trotation: T.number,\n})\n", "import { T } from '@tldraw/validate'\nimport { SetValue } from '../util-types'\nimport { TLCanvasUiColor, canvasUiColorTypeValidator } from './TLColor'\nimport { VecModel, vecModelValidator } from './geometry-types'\n\n/**\n * The scribble states used by tldraw.\n *\n *  @public */\nexport const TL_SCRIBBLE_STATES = new Set(['starting', 'paused', 'active', 'stopping'] as const)\n\n/**\n * A type for the scribble used by tldraw.\n *\n * @public */\nexport interface TLScribble {\n\tid: string\n\tpoints: VecModel[]\n\tsize: number\n\tcolor: TLCanvasUiColor\n\topacity: number\n\tstate: SetValue<typeof TL_SCRIBBLE_STATES>\n\tdelay: number\n\tshrink: number\n\ttaper: boolean\n}\n\n/** @public */\nexport const scribbleValidator: T.ObjectValidator<TLScribble> = T.object({\n\tid: T.string,\n\tpoints: T.arrayOf(vecModelValidator),\n\tsize: T.positiveNumber,\n\tcolor: canvasUiColorTypeValidator,\n\topacity: T.number,\n\tstate: T.setEnum(TL_SCRIBBLE_STATES),\n\tdelay: T.number,\n\tshrink: T.number,\n\ttaper: T.boolean,\n})\n", "import { T } from '@tldraw/validate'\nimport { SetValue } from '../util-types'\n\n/**\n * The colors used by tldraw's default shapes.\n *\n *  @public */\nexport const TL_CANVAS_UI_COLOR_TYPES = new Set([\n\t'accent',\n\t'white',\n\t'black',\n\t'selection-stroke',\n\t'selection-fill',\n\t'laser',\n\t'muted-1',\n] as const)\n\n/**\n * A type for the colors used by tldraw's default shapes.\n *\n *  @public */\nexport type TLCanvasUiColor = SetValue<typeof TL_CANVAS_UI_COLOR_TYPES>\n\n/**\n * A validator for the colors used by tldraw's default shapes.\n *\n * @public */\nexport const canvasUiColorTypeValidator = T.setEnum(TL_CANVAS_UI_COLOR_TYPES)\n", "import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { IndexKey, JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\n\n/**\n * TLPage\n *\n * @public\n */\nexport interface TLPage extends BaseRecord<'page', TLPageId> {\n\tname: string\n\tindex: IndexKey\n\tmeta: JsonObject\n}\n\n/** @public */\nexport type TLPageId = RecordId<TLPage>\n\n/** @public */\nexport const pageIdValidator = idValidator<TLPageId>('page')\n\n/** @public */\nexport const pageValidator: T.Validator<TLPage> = T.model(\n\t'page',\n\tT.object({\n\t\ttypeName: T.literal('page'),\n\t\tid: pageIdValidator,\n\t\tname: T.string,\n\t\tindex: T.indexKey,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/** @public */\nexport const pageVersions = createMigrationIds('com.tldraw.page', {\n\tAddMeta: 1,\n})\n\n/** @public */\nexport const pageMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.page',\n\trecordType: 'page',\n\tsequence: [\n\t\t{\n\t\t\tid: pageVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport const PageRecordType = createRecordType<TLPage>('page', {\n\tvalidator: pageValidator,\n\tscope: 'document',\n}).withDefaultProperties(() => ({\n\tmeta: {},\n}))\n\n/** @public */\nexport function isPageId(id: string): id is TLPageId {\n\treturn PageRecordType.isId(id)\n}\n", "import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\nimport { shapeIdValidator } from '../shapes/TLBaseShape'\nimport { pageIdValidator, TLPage } from './TLPage'\nimport { TLShapeId } from './TLShape'\n\n/**\n * TLInstancePageState\n *\n * State that is unique to a particular page of the document in a particular browser tab\n *\n * @public\n */\nexport interface TLInstancePageState\n\textends BaseRecord<'instance_page_state', TLInstancePageStateId> {\n\tpageId: RecordId<TLPage>\n\tselectedShapeIds: TLShapeId[]\n\thintingShapeIds: TLShapeId[]\n\terasingShapeIds: TLShapeId[]\n\thoveredShapeId: TLShapeId | null\n\teditingShapeId: TLShapeId | null\n\tcroppingShapeId: TLShapeId | null\n\tfocusedGroupId: TLShapeId | null\n\tmeta: JsonObject\n}\n\n/** @public */\nexport const instancePageStateValidator: T.Validator<TLInstancePageState> = T.model(\n\t'instance_page_state',\n\tT.object({\n\t\ttypeName: T.literal('instance_page_state'),\n\t\tid: idValidator<TLInstancePageStateId>('instance_page_state'),\n\t\tpageId: pageIdValidator,\n\t\tselectedShapeIds: T.arrayOf(shapeIdValidator),\n\t\thintingShapeIds: T.arrayOf(shapeIdValidator),\n\t\terasingShapeIds: T.arrayOf(shapeIdValidator),\n\t\thoveredShapeId: shapeIdValidator.nullable(),\n\t\teditingShapeId: shapeIdValidator.nullable(),\n\t\tcroppingShapeId: shapeIdValidator.nullable(),\n\t\tfocusedGroupId: shapeIdValidator.nullable(),\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/** @public */\nexport const instancePageStateVersions = createMigrationIds('com.tldraw.instance_page_state', {\n\tAddCroppingId: 1,\n\tRemoveInstanceIdAndCameraId: 2,\n\tAddMeta: 3,\n\tRenameProperties: 4,\n\tRenamePropertiesAgain: 5,\n} as const)\n\n/** @public */\nexport const instancePageStateMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.instance_page_state',\n\trecordType: 'instance_page_state',\n\tsequence: [\n\t\t{\n\t\t\tid: instancePageStateVersions.AddCroppingId,\n\t\t\tup(instance: any) {\n\t\t\t\tinstance.croppingShapeId = null\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePageStateVersions.RemoveInstanceIdAndCameraId,\n\t\t\tup(instance: any) {\n\t\t\t\tdelete instance.instanceId\n\t\t\t\tdelete instance.cameraId\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePageStateVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePageStateVersions.RenameProperties,\n\t\t\t// this migration is cursed: it was written wrong and doesn't do anything.\n\t\t\t// rather than replace it, I've added another migration below that fixes it.\n\t\t\tup: (_record) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: (_record) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePageStateVersions.RenamePropertiesAgain,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.selectedShapeIds = record.selectedIds\n\t\t\t\tdelete record.selectedIds\n\t\t\t\trecord.hintingShapeIds = record.hintingIds\n\t\t\t\tdelete record.hintingIds\n\t\t\t\trecord.erasingShapeIds = record.erasingIds\n\t\t\t\tdelete record.erasingIds\n\t\t\t\trecord.hoveredShapeId = record.hoveredId\n\t\t\t\tdelete record.hoveredId\n\t\t\t\trecord.editingShapeId = record.editingId\n\t\t\t\tdelete record.editingId\n\t\t\t\trecord.croppingShapeId = record.croppingShapeId ?? record.croppingId ?? null\n\t\t\t\tdelete record.croppingId\n\t\t\t\trecord.focusedGroupId = record.focusLayerId\n\t\t\t\tdelete record.focusLayerId\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\trecord.selectedIds = record.selectedShapeIds\n\t\t\t\tdelete record.selectedShapeIds\n\t\t\t\trecord.hintingIds = record.hintingShapeIds\n\t\t\t\tdelete record.hintingShapeIds\n\t\t\t\trecord.erasingIds = record.erasingShapeIds\n\t\t\t\tdelete record.erasingShapeIds\n\t\t\t\trecord.hoveredId = record.hoveredShapeId\n\t\t\t\tdelete record.hoveredShapeId\n\t\t\t\trecord.editingId = record.editingShapeId\n\t\t\t\tdelete record.editingShapeId\n\t\t\t\trecord.croppingId = record.croppingShapeId\n\t\t\t\tdelete record.croppingShapeId\n\t\t\t\trecord.focusLayerId = record.focusedGroupId\n\t\t\t\tdelete record.focusedGroupId\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport const InstancePageStateRecordType = createRecordType<TLInstancePageState>(\n\t'instance_page_state',\n\t{\n\t\tvalidator: instancePageStateValidator,\n\t\tscope: 'session',\n\t\tephemeralKeys: {\n\t\t\tpageId: false,\n\t\t\tselectedShapeIds: false,\n\t\t\teditingShapeId: false,\n\t\t\tcroppingShapeId: false,\n\t\t\tmeta: false,\n\n\t\t\thintingShapeIds: true,\n\t\t\terasingShapeIds: true,\n\t\t\thoveredShapeId: true,\n\t\t\tfocusedGroupId: true,\n\t\t},\n\t}\n).withDefaultProperties(\n\t(): Omit<TLInstancePageState, 'id' | 'typeName' | 'pageId'> => ({\n\t\teditingShapeId: null,\n\t\tcroppingShapeId: null,\n\t\tselectedShapeIds: [],\n\t\thoveredShapeId: null,\n\t\terasingShapeIds: [],\n\t\thintingShapeIds: [],\n\t\tfocusedGroupId: null,\n\t\tmeta: {},\n\t})\n)\n\n/** @public */\nexport type TLInstancePageStateId = RecordId<TLInstancePageState>\n", "import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\n\n/**\n * TLPointer\n *\n * @public\n */\nexport interface TLPointer extends BaseRecord<'pointer', TLPointerId> {\n\tx: number\n\ty: number\n\tlastActivityTimestamp: number\n\tmeta: JsonObject\n}\n\n/** @public */\nexport type TLPointerId = RecordId<TLPointer>\n\n/** @public */\nexport const pointerValidator: T.Validator<TLPointer> = T.model(\n\t'pointer',\n\tT.object({\n\t\ttypeName: T.literal('pointer'),\n\t\tid: idValidator<TLPointerId>('pointer'),\n\t\tx: T.number,\n\t\ty: T.number,\n\t\tlastActivityTimestamp: T.number,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/** @public */\nexport const pointerVersions = createMigrationIds('com.tldraw.pointer', {\n\tAddMeta: 1,\n})\n\n/** @public */\nexport const pointerMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.pointer',\n\trecordType: 'pointer',\n\tsequence: [\n\t\t{\n\t\t\tid: pointerVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport const PointerRecordType = createRecordType<TLPointer>('pointer', {\n\tvalidator: pointerValidator,\n\tscope: 'session',\n}).withDefaultProperties(\n\t(): Omit<TLPointer, 'id' | 'typeName'> => ({\n\t\tx: 0,\n\t\ty: 0,\n\t\tlastActivityTimestamp: 0,\n\t\tmeta: {},\n\t})\n)\n\n/** @public */\nexport const TLPOINTER_ID = PointerRecordType.createId('pointer')\n", "import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { BoxModel, boxModelValidator } from '../misc/geometry-types'\nimport { idValidator } from '../misc/id-validator'\nimport { cursorTypeValidator, TLCursor } from '../misc/TLCursor'\nimport { scribbleValidator, TLScribble } from '../misc/TLScribble'\nimport { TLPageId } from './TLPage'\nimport { TLShapeId } from './TLShape'\n\n/** @public */\nexport interface TLInstancePresence extends BaseRecord<'instance_presence', TLInstancePresenceID> {\n\tuserId: string\n\tuserName: string\n\tlastActivityTimestamp: number\n\tcolor: string // can be any hex color\n\tcamera: { x: number; y: number; z: number }\n\tselectedShapeIds: TLShapeId[]\n\tcurrentPageId: TLPageId\n\tbrush: BoxModel | null\n\tscribbles: TLScribble[]\n\tscreenBounds: BoxModel\n\tfollowingUserId: string | null\n\tcursor: {\n\t\tx: number\n\t\ty: number\n\t\ttype: TLCursor['type']\n\t\trotation: number\n\t}\n\tchatMessage: string\n\tmeta: JsonObject\n}\n\n/** @public */\nexport type TLInstancePresenceID = RecordId<TLInstancePresence>\n\n/** @public */\nexport const instancePresenceValidator: T.Validator<TLInstancePresence> = T.model(\n\t'instance_presence',\n\tT.object({\n\t\ttypeName: T.literal('instance_presence'),\n\t\tid: idValidator<TLInstancePresenceID>('instance_presence'),\n\t\tuserId: T.string,\n\t\tuserName: T.string,\n\t\tlastActivityTimestamp: T.number,\n\t\tfollowingUserId: T.string.nullable(),\n\t\tcursor: T.object({\n\t\t\tx: T.number,\n\t\t\ty: T.number,\n\t\t\ttype: cursorTypeValidator,\n\t\t\trotation: T.number,\n\t\t}),\n\t\tcolor: T.string,\n\t\tcamera: T.object({\n\t\t\tx: T.number,\n\t\t\ty: T.number,\n\t\t\tz: T.number,\n\t\t}),\n\t\tscreenBounds: boxModelValidator,\n\t\tselectedShapeIds: T.arrayOf(idValidator<TLShapeId>('shape')),\n\t\tcurrentPageId: idValidator<TLPageId>('page'),\n\t\tbrush: boxModelValidator.nullable(),\n\t\tscribbles: T.arrayOf(scribbleValidator),\n\t\tchatMessage: T.string,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/** @public */\nexport const instancePresenceVersions = createMigrationIds('com.tldraw.instance_presence', {\n\tAddScribbleDelay: 1,\n\tRemoveInstanceId: 2,\n\tAddChatMessage: 3,\n\tAddMeta: 4,\n\tRenameSelectedShapeIds: 5,\n} as const)\n\nexport const instancePresenceMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.instance_presence',\n\trecordType: 'instance_presence',\n\tsequence: [\n\t\t{\n\t\t\tid: instancePresenceVersions.AddScribbleDelay,\n\t\t\tup: (instance: any) => {\n\t\t\t\tif (instance.scribble !== null) {\n\t\t\t\t\tinstance.scribble.delay = 0\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.RemoveInstanceId,\n\t\t\tup: (instance: any) => {\n\t\t\t\tdelete instance.instanceId\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.AddChatMessage,\n\t\t\tup: (instance: any) => {\n\t\t\t\tinstance.chatMessage = ''\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.RenameSelectedShapeIds,\n\t\t\tup: (_record) => {\n\t\t\t\t// noop, whoopsie\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport const InstancePresenceRecordType = createRecordType<TLInstancePresence>(\n\t'instance_presence',\n\t{\n\t\tvalidator: instancePresenceValidator,\n\t\tscope: 'presence',\n\t}\n).withDefaultProperties(() => ({\n\tlastActivityTimestamp: 0,\n\tfollowingUserId: null,\n\tcolor: '#FF0000',\n\tcamera: {\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 1,\n\t},\n\tcursor: {\n\t\tx: 0,\n\t\ty: 0,\n\t\ttype: 'default',\n\t\trotation: 0,\n\t},\n\tscreenBounds: {\n\t\tx: 0,\n\t\ty: 0,\n\t\tw: 1,\n\t\th: 1,\n\t},\n\tselectedShapeIds: [],\n\tbrush: null,\n\tscribbles: [],\n\tchatMessage: '',\n\tmeta: {},\n}))\n", "import { LegacyMigrations, MigrationSequence, StoreSchema, StoreValidator } from '@tldraw/store'\nimport { objectMapValues } from '@tldraw/utils'\nimport { TLStoreProps, createIntegrityChecker, onValidationFailure } from './TLStore'\nimport { bookmarkAssetMigrations } from './assets/TLBookmarkAsset'\nimport { imageAssetMigrations } from './assets/TLImageAsset'\nimport { videoAssetMigrations } from './assets/TLVideoAsset'\nimport { arrowBindingMigrations, arrowBindingProps } from './bindings/TLArrowBinding'\nimport { AssetRecordType, assetMigrations } from './records/TLAsset'\nimport { TLBinding, TLDefaultBinding, createBindingRecordType } from './records/TLBinding'\nimport { CameraRecordType, cameraMigrations } from './records/TLCamera'\nimport { DocumentRecordType, documentMigrations } from './records/TLDocument'\nimport { createInstanceRecordType, instanceMigrations } from './records/TLInstance'\nimport { PageRecordType, pageMigrations } from './records/TLPage'\nimport { InstancePageStateRecordType, instancePageStateMigrations } from './records/TLPageState'\nimport { PointerRecordType, pointerMigrations } from './records/TLPointer'\nimport { InstancePresenceRecordType, instancePresenceMigrations } from './records/TLPresence'\nimport { TLRecord } from './records/TLRecord'\nimport {\n\tTLDefaultShape,\n\tTLShape,\n\tcreateShapeRecordType,\n\tgetShapePropKeysByStyle,\n\trootShapeMigrations,\n} from './records/TLShape'\nimport { TLPropsMigrations, processPropsMigrations } from './recordsWithProps'\nimport { arrowShapeMigrations, arrowShapeProps } from './shapes/TLArrowShape'\nimport { bookmarkShapeMigrations, bookmarkShapeProps } from './shapes/TLBookmarkShape'\nimport { drawShapeMigrations, drawShapeProps } from './shapes/TLDrawShape'\nimport { embedShapeMigrations, embedShapeProps } from './shapes/TLEmbedShape'\nimport { frameShapeMigrations, frameShapeProps } from './shapes/TLFrameShape'\nimport { geoShapeMigrations, geoShapeProps } from './shapes/TLGeoShape'\nimport { groupShapeMigrations, groupShapeProps } from './shapes/TLGroupShape'\nimport { highlightShapeMigrations, highlightShapeProps } from './shapes/TLHighlightShape'\nimport { imageShapeMigrations, imageShapeProps } from './shapes/TLImageShape'\nimport { lineShapeMigrations, lineShapeProps } from './shapes/TLLineShape'\nimport { noteShapeMigrations, noteShapeProps } from './shapes/TLNoteShape'\nimport { textShapeMigrations, textShapeProps } from './shapes/TLTextShape'\nimport { videoShapeMigrations, videoShapeProps } from './shapes/TLVideoShape'\nimport { storeMigrations } from './store-migrations'\nimport { StyleProp } from './styles/StyleProp'\n\n/** @public */\nexport interface SchemaPropsInfo {\n\tmigrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence\n\tprops?: Record<string, StoreValidator<any>>\n\tmeta?: Record<string, StoreValidator<any>>\n}\n\n/** @public */\nexport type TLSchema = StoreSchema<TLRecord, TLStoreProps>\n\n/** @public */\nexport const defaultShapeSchemas = {\n\tarrow: { migrations: arrowShapeMigrations, props: arrowShapeProps },\n\tbookmark: { migrations: bookmarkShapeMigrations, props: bookmarkShapeProps },\n\tdraw: { migrations: drawShapeMigrations, props: drawShapeProps },\n\tembed: { migrations: embedShapeMigrations, props: embedShapeProps },\n\tframe: { migrations: frameShapeMigrations, props: frameShapeProps },\n\tgeo: { migrations: geoShapeMigrations, props: geoShapeProps },\n\tgroup: { migrations: groupShapeMigrations, props: groupShapeProps },\n\thighlight: { migrations: highlightShapeMigrations, props: highlightShapeProps },\n\timage: { migrations: imageShapeMigrations, props: imageShapeProps },\n\tline: { migrations: lineShapeMigrations, props: lineShapeProps },\n\tnote: { migrations: noteShapeMigrations, props: noteShapeProps },\n\ttext: { migrations: textShapeMigrations, props: textShapeProps },\n\tvideo: { migrations: videoShapeMigrations, props: videoShapeProps },\n} satisfies { [T in TLDefaultShape['type']]: SchemaPropsInfo }\n\n/** @public */\nexport const defaultBindingSchemas = {\n\tarrow: { migrations: arrowBindingMigrations, props: arrowBindingProps },\n} satisfies { [T in TLDefaultBinding['type']]: SchemaPropsInfo }\n\n/**\n * Create a TLSchema with custom shapes. Custom shapes cannot override default shapes.\n *\n * @param opts - Options\n *\n * @public */\nexport function createTLSchema({\n\tshapes = defaultShapeSchemas,\n\tbindings = defaultBindingSchemas,\n\tmigrations,\n}: {\n\tshapes?: Record<string, SchemaPropsInfo>\n\tbindings?: Record<string, SchemaPropsInfo>\n\tmigrations?: readonly MigrationSequence[]\n} = {}): TLSchema {\n\tconst stylesById = new Map<string, StyleProp<unknown>>()\n\tfor (const shape of objectMapValues(shapes)) {\n\t\tfor (const style of getShapePropKeysByStyle(shape.props ?? {}).keys()) {\n\t\t\tif (stylesById.has(style.id) && stylesById.get(style.id) !== style) {\n\t\t\t\tthrow new Error(`Multiple StyleProp instances with the same id: ${style.id}`)\n\t\t\t}\n\t\t\tstylesById.set(style.id, style)\n\t\t}\n\t}\n\n\tconst ShapeRecordType = createShapeRecordType(shapes)\n\tconst BindingRecordType = createBindingRecordType(bindings)\n\tconst InstanceRecordType = createInstanceRecordType(stylesById)\n\n\treturn StoreSchema.create(\n\t\t{\n\t\t\tasset: AssetRecordType,\n\t\t\tbinding: BindingRecordType,\n\t\t\tcamera: CameraRecordType,\n\t\t\tdocument: DocumentRecordType,\n\t\t\tinstance: InstanceRecordType,\n\t\t\tinstance_page_state: InstancePageStateRecordType,\n\t\t\tpage: PageRecordType,\n\t\t\tinstance_presence: InstancePresenceRecordType,\n\t\t\tpointer: PointerRecordType,\n\t\t\tshape: ShapeRecordType,\n\t\t},\n\t\t{\n\t\t\tmigrations: [\n\t\t\t\tstoreMigrations,\n\t\t\t\tassetMigrations,\n\t\t\t\tcameraMigrations,\n\t\t\t\tdocumentMigrations,\n\t\t\t\tinstanceMigrations,\n\t\t\t\tinstancePageStateMigrations,\n\t\t\t\tpageMigrations,\n\t\t\t\tinstancePresenceMigrations,\n\t\t\t\tpointerMigrations,\n\t\t\t\trootShapeMigrations,\n\n\t\t\t\tbookmarkAssetMigrations,\n\t\t\t\timageAssetMigrations,\n\t\t\t\tvideoAssetMigrations,\n\n\t\t\t\t...processPropsMigrations<TLShape>('shape', shapes),\n\t\t\t\t...processPropsMigrations<TLBinding>('binding', bindings),\n\n\t\t\t\t...(migrations ?? []),\n\t\t\t],\n\t\t\tonValidationFailure,\n\t\t\tcreateIntegrityChecker,\n\t\t}\n\t)\n}\n", "import { Signal } from '@tldraw/state'\nimport {\n\tSerializedStore,\n\tStore,\n\tStoreSchema,\n\tStoreSnapshot,\n\tStoreValidationFailure,\n} from '@tldraw/store'\nimport { IndexKey, annotateError, structuredClone } from '@tldraw/utils'\nimport { TLAsset } from './records/TLAsset'\nimport { CameraRecordType, TLCameraId } from './records/TLCamera'\nimport { DocumentRecordType, TLDOCUMENT_ID } from './records/TLDocument'\nimport { TLINSTANCE_ID } from './records/TLInstance'\nimport { PageRecordType, TLPageId } from './records/TLPage'\nimport { InstancePageStateRecordType, TLInstancePageStateId } from './records/TLPageState'\nimport { PointerRecordType, TLPOINTER_ID } from './records/TLPointer'\nimport { TLRecord } from './records/TLRecord'\n\nfunction sortByIndex<T extends { index: string }>(a: T, b: T) {\n\tif (a.index < b.index) {\n\t\treturn -1\n\t} else if (a.index > b.index) {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunction redactRecordForErrorReporting(record: any) {\n\tif (record.typeName === 'asset') {\n\t\tif ('src' in record) {\n\t\t\trecord.src = '<redacted>'\n\t\t}\n\n\t\tif ('src' in record.props) {\n\t\t\trecord.props.src = '<redacted>'\n\t\t}\n\t}\n}\n\n/** @public */\nexport type TLStoreSchema = StoreSchema<TLRecord, TLStoreProps>\n\n/** @public */\nexport type TLSerializedStore = SerializedStore<TLRecord>\n\n/** @public */\nexport type TLStoreSnapshot = StoreSnapshot<TLRecord>\n\n/** @public */\nexport interface TLAssetContext {\n\tscreenScale: number\n\tsteppedScreenScale: number\n\tdpr: number\n\tnetworkEffectiveType: string | null\n\tshouldResolveToOriginal: boolean\n}\n\n/**\n * A `TLAssetStore` sits alongside the main {@link TLStore} and is responsible for storing and\n * retrieving large assets such as images. Generally, this should be part of a wider sync system:\n *\n * - By default, the store is in-memory only, so `TLAssetStore` converts images to data URLs\n * - When using\n *   {@link @tldraw/editor#TldrawEditorWithoutStoreProps.persistenceKey | `persistenceKey`}, the\n *   store is synced to the browser's local IndexedDB, so `TLAssetStore` stores images there too\n * - When using a multiplayer sync server, you would implement `TLAssetStore` to upload images to\n *   e.g. an S3 bucket.\n *\n * @public\n */\nexport interface TLAssetStore {\n\t/**\n\t * Upload an asset to your storage, returning a URL that can be used to refer to the asset\n\t * long-term.\n\t *\n\t * @param asset - Information & metadata about the asset being uploaded\n\t * @param file - The `File` to be uploaded\n\t * @returns A promise that resolves to the URL of the uploaded asset\n\t */\n\tupload(asset: TLAsset, file: File): Promise<string>\n\t/**\n\t * Resolve an asset to a URL. This is used when rendering the asset in the editor. By default,\n\t * this will just use `asset.props.src`, the URL returned by `upload()`. This can be used to\n\t * rewrite that URL to add access credentials, or optimized the asset for how it's currently\n\t * being displayed using the {@link TLAssetContext | information provided}.\n\t *\n\t * @param asset - the asset being resolved\n\t * @param ctx - information about the current environment and where the asset is being used\n\t * @returns The URL of the resolved asset, or `null` if the asset is not available\n\t */\n\tresolve?(asset: TLAsset, ctx: TLAssetContext): Promise<string | null> | string | null\n}\n\n/** @public */\nexport interface TLStoreProps {\n\tdefaultName: string\n\tassets: Required<TLAssetStore>\n\t/**\n\t * Called an {@link @tldraw/editor#Editor} connected to this store is mounted.\n\t */\n\tonMount(editor: unknown): void | (() => void)\n\tcollaboration?: {\n\t\tstatus: Signal<'online' | 'offline'> | null\n\t\tmode?: Signal<'readonly' | 'readwrite'> | null\n\t}\n}\n\n/** @public */\nexport type TLStore = Store<TLRecord, TLStoreProps>\n\n/** @public */\nexport function onValidationFailure({\n\terror,\n\tphase,\n\trecord,\n\trecordBefore,\n}: StoreValidationFailure<TLRecord>): TLRecord {\n\tconst isExistingValidationIssue =\n\t\t// if we're initializing the store for the first time, we should\n\t\t// allow invalid records so people can load old buggy data:\n\t\tphase === 'initialize'\n\n\tannotateError(error, {\n\t\ttags: {\n\t\t\torigin: 'store.validateRecord',\n\t\t\tstorePhase: phase,\n\t\t\tisExistingValidationIssue,\n\t\t},\n\t\textras: {\n\t\t\trecordBefore: recordBefore\n\t\t\t\t? redactRecordForErrorReporting(structuredClone(recordBefore))\n\t\t\t\t: undefined,\n\t\t\trecordAfter: redactRecordForErrorReporting(structuredClone(record)),\n\t\t},\n\t})\n\n\tthrow error\n}\n\nfunction getDefaultPages() {\n\treturn [\n\t\tPageRecordType.create({\n\t\t\tid: 'page:page' as TLPageId,\n\t\t\tname: 'Page 1',\n\t\t\tindex: 'a1' as IndexKey,\n\t\t\tmeta: {},\n\t\t}),\n\t]\n}\n\n/** @internal */\nexport function createIntegrityChecker(store: Store<TLRecord, TLStoreProps>): () => void {\n\tconst $pageIds = store.query.ids('page')\n\tconst $pageStates = store.query.records('instance_page_state')\n\n\tconst ensureStoreIsUsable = (): void => {\n\t\t// make sure we have exactly one document\n\t\tif (!store.has(TLDOCUMENT_ID)) {\n\t\t\tstore.put([DocumentRecordType.create({ id: TLDOCUMENT_ID, name: store.props.defaultName })])\n\t\t\treturn ensureStoreIsUsable()\n\t\t}\n\n\t\tif (!store.has(TLPOINTER_ID)) {\n\t\t\tstore.put([PointerRecordType.create({ id: TLPOINTER_ID })])\n\t\t\treturn ensureStoreIsUsable()\n\t\t}\n\n\t\t// make sure there is at least one page\n\t\tconst pageIds = $pageIds.get()\n\t\tif (pageIds.size === 0) {\n\t\t\tstore.put(getDefaultPages())\n\t\t\treturn ensureStoreIsUsable()\n\t\t}\n\n\t\tconst getFirstPageId = () => [...pageIds].map((id) => store.get(id)!).sort(sortByIndex)[0].id!\n\n\t\t// make sure we have state for the current user's current tab\n\t\tconst instanceState = store.get(TLINSTANCE_ID)\n\t\tif (!instanceState) {\n\t\t\tstore.put([\n\t\t\t\tstore.schema.types.instance.create({\n\t\t\t\t\tid: TLINSTANCE_ID,\n\t\t\t\t\tcurrentPageId: getFirstPageId(),\n\t\t\t\t\texportBackground: true,\n\t\t\t\t}),\n\t\t\t])\n\n\t\t\treturn ensureStoreIsUsable()\n\t\t} else if (!pageIds.has(instanceState.currentPageId)) {\n\t\t\tstore.put([{ ...instanceState, currentPageId: getFirstPageId() }])\n\t\t\treturn ensureStoreIsUsable()\n\t\t}\n\n\t\t// make sure we have page states and cameras for all the pages\n\t\tconst missingPageStateIds = new Set<TLInstancePageStateId>()\n\t\tconst missingCameraIds = new Set<TLCameraId>()\n\t\tfor (const id of pageIds) {\n\t\t\tconst pageStateId = InstancePageStateRecordType.createId(id)\n\t\t\tconst pageState = store.get(pageStateId)\n\t\t\tif (!pageState) {\n\t\t\t\tmissingPageStateIds.add(pageStateId)\n\t\t\t}\n\t\t\tconst cameraId = CameraRecordType.createId(id)\n\t\t\tif (!store.has(cameraId)) {\n\t\t\t\tmissingCameraIds.add(cameraId)\n\t\t\t}\n\t\t}\n\n\t\tif (missingPageStateIds.size > 0) {\n\t\t\tstore.put(\n\t\t\t\t[...missingPageStateIds].map((id) =>\n\t\t\t\t\tInstancePageStateRecordType.create({\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tpageId: InstancePageStateRecordType.parseId(id) as TLPageId,\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tif (missingCameraIds.size > 0) {\n\t\t\tstore.put([...missingCameraIds].map((id) => CameraRecordType.create({ id })))\n\t\t}\n\n\t\tconst pageStates = $pageStates.get()\n\t\tfor (const pageState of pageStates) {\n\t\t\tif (!pageIds.has(pageState.pageId)) {\n\t\t\t\tstore.remove([pageState.id])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (pageState.croppingShapeId && !store.has(pageState.croppingShapeId)) {\n\t\t\t\tstore.put([{ ...pageState, croppingShapeId: null }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tif (pageState.focusedGroupId && !store.has(pageState.focusedGroupId)) {\n\t\t\t\tstore.put([{ ...pageState, focusedGroupId: null }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tif (pageState.hoveredShapeId && !store.has(pageState.hoveredShapeId)) {\n\t\t\t\tstore.put([{ ...pageState, hoveredShapeId: null }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tconst filteredSelectedIds = pageState.selectedShapeIds.filter((id) => store.has(id))\n\t\t\tif (filteredSelectedIds.length !== pageState.selectedShapeIds.length) {\n\t\t\t\tstore.put([{ ...pageState, selectedShapeIds: filteredSelectedIds }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tconst filteredHintingIds = pageState.hintingShapeIds.filter((id) => store.has(id))\n\t\t\tif (filteredHintingIds.length !== pageState.hintingShapeIds.length) {\n\t\t\t\tstore.put([{ ...pageState, hintingShapeIds: filteredHintingIds }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tconst filteredErasingIds = pageState.erasingShapeIds.filter((id) => store.has(id))\n\t\t\tif (filteredErasingIds.length !== pageState.erasingShapeIds.length) {\n\t\t\t\tstore.put([{ ...pageState, erasingShapeIds: filteredErasingIds }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ensureStoreIsUsable\n}\n", "import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\n\n/**\n * TLDocument\n *\n * @public\n */\nexport interface TLDocument extends BaseRecord<'document', RecordId<TLDocument>> {\n\tgridSize: number\n\tname: string\n\tmeta: JsonObject\n}\n\n/** @public */\nexport const documentValidator: T.Validator<TLDocument> = T.model(\n\t'document',\n\tT.object({\n\t\ttypeName: T.literal('document'),\n\t\tid: T.literal('document:document' as RecordId<TLDocument>),\n\t\tgridSize: T.number,\n\t\tname: T.string,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/** @public */\nexport const documentVersions = createMigrationIds('com.tldraw.document', {\n\tAddName: 1,\n\tAddMeta: 2,\n} as const)\n\n/** @public */\nexport const documentMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.document',\n\trecordType: 'document',\n\tsequence: [\n\t\t{\n\t\t\tid: documentVersions.AddName,\n\t\t\tup: (document) => {\n\t\t\t\t;(document as any).name = ''\n\t\t\t},\n\t\t\tdown: (document) => {\n\t\t\t\tdelete (document as any).name\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: documentVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\t;(record as any).meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport const DocumentRecordType = createRecordType<TLDocument>('document', {\n\tvalidator: documentValidator,\n\tscope: 'document',\n}).withDefaultProperties(\n\t(): Omit<TLDocument, 'id' | 'typeName'> => ({\n\t\tgridSize: 10,\n\t\tname: '',\n\t\tmeta: {},\n\t})\n)\n\n// all document records have the same ID: 'document:document'\n/** @public */\nexport const TLDOCUMENT_ID: RecordId<TLDocument> = DocumentRecordType.createId('document')\n", "import { createMigrationIds, createRecordMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLAsset } from '../records/TLAsset'\nimport { TLBaseAsset, createAssetValidator } from './TLBaseAsset'\n\n/**\n * An asset used for URL bookmarks, used by the TLBookmarkShape.\n *\n *  @public */\nexport type TLBookmarkAsset = TLBaseAsset<\n\t'bookmark',\n\t{\n\t\ttitle: string\n\t\tdescription: string\n\t\timage: string\n\t\tfavicon: string\n\t\tsrc: string | null\n\t}\n>\n\n/** @public */\nexport const bookmarkAssetValidator: T.Validator<TLBookmarkAsset> = createAssetValidator(\n\t'bookmark',\n\tT.object({\n\t\ttitle: T.string,\n\t\tdescription: T.string,\n\t\timage: T.string,\n\t\tfavicon: T.string,\n\t\tsrc: T.srcUrl.nullable(),\n\t})\n)\n\nconst Versions = createMigrationIds('com.tldraw.asset.bookmark', {\n\tMakeUrlsValid: 1,\n\tAddFavicon: 2,\n} as const)\n\nexport { Versions as bookmarkAssetVersions }\n\n/** @public */\nexport const bookmarkAssetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset.bookmark',\n\trecordType: 'asset',\n\tfilter: (asset) => (asset as TLAsset).type === 'bookmark',\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (!T.srcUrl.isValid(asset.props.src)) {\n\t\t\t\t\tasset.props.src = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_asset) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFavicon,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (!T.srcUrl.isValid(asset.props.favicon)) {\n\t\t\t\t\tasset.props.favicon = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.favicon\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { createMigrationIds, createRecordMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLAsset } from '../records/TLAsset'\nimport { TLBaseAsset, createAssetValidator } from './TLBaseAsset'\n\n/**\n * An asset for images such as PNGs and JPEGs, used by the TLImageShape.\n *\n * @public */\nexport type TLImageAsset = TLBaseAsset<\n\t'image',\n\t{\n\t\tw: number\n\t\th: number\n\t\tname: string\n\t\tisAnimated: boolean\n\t\tmimeType: string | null\n\t\tsrc: string | null\n\t\tfileSize?: number\n\t}\n>\n\n/** @public */\nexport const imageAssetValidator: T.Validator<TLImageAsset> = createAssetValidator(\n\t'image',\n\tT.object({\n\t\tw: T.number,\n\t\th: T.number,\n\t\tname: T.string,\n\t\tisAnimated: T.boolean,\n\t\tmimeType: T.string.nullable(),\n\t\tsrc: T.srcUrl.nullable(),\n\t\tfileSize: T.nonZeroNumber.optional(),\n\t})\n)\n\nconst Versions = createMigrationIds('com.tldraw.asset.image', {\n\tAddIsAnimated: 1,\n\tRenameWidthHeight: 2,\n\tMakeUrlsValid: 3,\n\tAddFileSize: 4,\n\tMakeFileSizeOptional: 5,\n} as const)\n\nexport { Versions as imageAssetVersions }\n\n/** @public */\nexport const imageAssetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset.image',\n\trecordType: 'asset',\n\tfilter: (asset) => (asset as TLAsset).type === 'image',\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddIsAnimated,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.isAnimated = false\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.isAnimated\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.RenameWidthHeight,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.w = asset.props.width\n\t\t\t\tasset.props.h = asset.props.height\n\t\t\t\tdelete asset.props.width\n\t\t\t\tdelete asset.props.height\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tasset.props.width = asset.props.w\n\t\t\t\tasset.props.height = asset.props.h\n\t\t\t\tdelete asset.props.w\n\t\t\t\tdelete asset.props.h\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (!T.srcUrl.isValid(asset.props.src)) {\n\t\t\t\t\tasset.props.src = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_asset) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFileSize,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.fileSize = -1\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.fileSize\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeFileSizeOptional,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (asset.props.fileSize === -1) {\n\t\t\t\t\tasset.props.fileSize = undefined\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tif (asset.props.fileSize === undefined) {\n\t\t\t\t\tasset.props.fileSize = -1\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { createMigrationIds, createRecordMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLAsset } from '../records/TLAsset'\nimport { TLBaseAsset, createAssetValidator } from './TLBaseAsset'\n\n/**\n * An asset used for videos, used by the TLVideoShape.\n *\n * @public */\nexport type TLVideoAsset = TLBaseAsset<\n\t'video',\n\t{\n\t\tw: number\n\t\th: number\n\t\tname: string\n\t\tisAnimated: boolean\n\t\tmimeType: string | null\n\t\tsrc: string | null\n\t\tfileSize?: number\n\t}\n>\n\n/** @public */\nexport const videoAssetValidator: T.Validator<TLVideoAsset> = createAssetValidator(\n\t'video',\n\tT.object({\n\t\tw: T.number,\n\t\th: T.number,\n\t\tname: T.string,\n\t\tisAnimated: T.boolean,\n\t\tmimeType: T.string.nullable(),\n\t\tsrc: T.srcUrl.nullable(),\n\t\tfileSize: T.number.optional(),\n\t})\n)\n\nconst Versions = createMigrationIds('com.tldraw.asset.video', {\n\tAddIsAnimated: 1,\n\tRenameWidthHeight: 2,\n\tMakeUrlsValid: 3,\n\tAddFileSize: 4,\n\tMakeFileSizeOptional: 5,\n} as const)\n\nexport { Versions as videoAssetVersions }\n\n/** @public */\nexport const videoAssetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset.video',\n\trecordType: 'asset',\n\tfilter: (asset) => (asset as TLAsset).type === 'video',\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddIsAnimated,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.isAnimated = false\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.isAnimated\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.RenameWidthHeight,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.w = asset.props.width\n\t\t\t\tasset.props.h = asset.props.height\n\t\t\t\tdelete asset.props.width\n\t\t\t\tdelete asset.props.height\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tasset.props.width = asset.props.w\n\t\t\t\tasset.props.height = asset.props.h\n\t\t\t\tdelete asset.props.w\n\t\t\t\tdelete asset.props.h\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (!T.srcUrl.isValid(asset.props.src)) {\n\t\t\t\t\tasset.props.src = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_asset) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFileSize,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.fileSize = -1\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.fileSize\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeFileSizeOptional,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (asset.props.fileSize === -1) {\n\t\t\t\t\tasset.props.fileSize = undefined\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tif (asset.props.fileSize === undefined) {\n\t\t\t\t\tasset.props.fileSize = -1\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n", "import {\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLBaseAsset } from '../assets/TLBaseAsset'\nimport { bookmarkAssetValidator, TLBookmarkAsset } from '../assets/TLBookmarkAsset'\nimport { imageAssetValidator, TLImageAsset } from '../assets/TLImageAsset'\nimport { TLVideoAsset, videoAssetValidator } from '../assets/TLVideoAsset'\nimport { TLShape } from './TLShape'\n\n/** @public */\nexport type TLAsset = TLImageAsset | TLVideoAsset | TLBookmarkAsset\n\n/** @public */\nexport const assetValidator: T.Validator<TLAsset> = T.model(\n\t'asset',\n\tT.union('type', {\n\t\timage: imageAssetValidator,\n\t\tvideo: videoAssetValidator,\n\t\tbookmark: bookmarkAssetValidator,\n\t})\n)\n\n/** @public */\nexport const assetVersions = createMigrationIds('com.tldraw.asset', {\n\tAddMeta: 1,\n} as const)\n\n/** @public */\nexport const assetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset',\n\trecordType: 'asset',\n\tsequence: [\n\t\t{\n\t\t\tid: assetVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\t;(record as any).meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/** @public */\nexport type TLAssetPartial<T extends TLAsset = TLAsset> = T extends T\n\t? {\n\t\t\tid: TLAssetId\n\t\t\ttype: T['type']\n\t\t\tprops?: Partial<T['props']>\n\t\t\tmeta?: Partial<T['meta']>\n\t\t} & Partial<Omit<T, 'type' | 'id' | 'props' | 'meta'>>\n\t: never\n\n/** @public */\nexport const AssetRecordType = createRecordType<TLAsset>('asset', {\n\tvalidator: assetValidator,\n\tscope: 'document',\n}).withDefaultProperties(() => ({\n\tmeta: {},\n}))\n\n/** @public */\nexport type TLAssetId = RecordId<TLBaseAsset<any, any>>\n\n/** @public */\nexport type TLAssetShape = Extract<TLShape, { props: { assetId: TLAssetId } }>\n", "import { T } from '@tldraw/validate'\nimport { assetIdValidator } from '../assets/TLBaseAsset'\nimport { TLAssetId } from '../records/TLAsset'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport interface TLBookmarkShapeProps {\n\tw: number\n\th: number\n\tassetId: TLAssetId | null\n\turl: string\n}\n\n/** @public */\nexport type TLBookmarkShape = TLBaseShape<'bookmark', TLBookmarkShapeProps>\n\n/** @public */\nexport const bookmarkShapeProps: RecordProps<TLBookmarkShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\tassetId: assetIdValidator.nullable(),\n\turl: T.linkUrl,\n}\n\nconst Versions = createShapePropsMigrationIds('bookmark', {\n\tNullAssetId: 1,\n\tMakeUrlsValid: 2,\n})\n\nexport { Versions as bookmarkShapeVersions }\n\n/** @public */\nexport const bookmarkShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.NullAssetId,\n\t\t\tup: (props) => {\n\t\t\t\tif (props.assetId === undefined) {\n\t\t\t\t\tprops.assetId = null\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { T } from '@tldraw/validate'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultFillStyle, TLDefaultFillStyle } from '../styles/TLFillStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport interface TLDrawShapeSegment {\n\ttype: 'free' | 'straight'\n\tpoints: VecModel[]\n}\n\n/** @public */\nexport const DrawShapeSegment: T.ObjectValidator<TLDrawShapeSegment> = T.object({\n\ttype: T.literalEnum('free', 'straight'),\n\tpoints: T.arrayOf(vecModelValidator),\n})\n\n/** @public */\nexport interface TLDrawShapeProps {\n\tcolor: TLDefaultColorStyle\n\tfill: TLDefaultFillStyle\n\tdash: TLDefaultDashStyle\n\tsize: TLDefaultSizeStyle\n\tsegments: TLDrawShapeSegment[]\n\tisComplete: boolean\n\tisClosed: boolean\n\tisPen: boolean\n\tscale: number\n}\n\n/** @public */\nexport type TLDrawShape = TLBaseShape<'draw', TLDrawShapeProps>\n\n/** @public */\nexport const drawShapeProps: RecordProps<TLDrawShape> = {\n\tcolor: DefaultColorStyle,\n\tfill: DefaultFillStyle,\n\tdash: DefaultDashStyle,\n\tsize: DefaultSizeStyle,\n\tsegments: T.arrayOf(DrawShapeSegment),\n\tisComplete: T.boolean,\n\tisClosed: T.boolean,\n\tisPen: T.boolean,\n\tscale: T.nonZeroNumber,\n}\n\nconst Versions = createShapePropsMigrationIds('draw', {\n\tAddInPen: 1,\n\tAddScale: 2,\n})\n\nexport { Versions as drawShapeVersions }\n\n/** @public */\nexport const drawShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddInPen,\n\t\t\tup: (props) => {\n\t\t\t\t// Rather than checking to see whether the shape is a pen at runtime,\n\t\t\t\t// from now on we're going to use the type of device reported to us\n\t\t\t\t// as well as the pressure data received; but for existing shapes we\n\t\t\t\t// need to check the pressure data to see if it's a pen or not.\n\n\t\t\t\tconst { points } = props.segments[0]\n\n\t\t\t\tif (points.length === 0) {\n\t\t\t\t\tprops.isPen = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tlet isPen = !(points[0].z === 0 || points[0].z === 0.5)\n\n\t\t\t\tif (points[1]) {\n\t\t\t\t\t// Double check if we have a second point (we probably should)\n\t\t\t\t\tisPen = isPen && !(points[1].z === 0 || points[1].z === 0.5)\n\t\t\t\t}\n\t\t\t\tprops.isPen = isPen\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { safeParseUrl } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n// Only allow multiplayer embeds. If we add additional routes later for example '/help' this won't match\nconst TLDRAW_APP_RE = /(^\\/r\\/[^/]+\\/?$)/\n\nconst EMBED_DEFINITIONS = [\n\t{\n\t\thostnames: ['beta.tldraw.com', 'tldraw.com', 'localhost:3000'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {\n\t\t\t\treturn url\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['figma.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/?$/)) {\n\t\t\t\tconst outUrl = urlObj.searchParams.get('url')\n\t\t\t\tif (outUrl) {\n\t\t\t\t\treturn outUrl\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['google.*'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (!urlObj) return\n\n\t\t\tconst matches = urlObj.pathname.match(/^\\/maps\\/embed\\/v1\\/view\\/?$/)\n\t\t\tif (matches && urlObj.searchParams.has('center') && urlObj.searchParams.get('zoom')) {\n\t\t\t\tconst zoom = urlObj.searchParams.get('zoom')\n\t\t\t\tconst [lat, lon] = urlObj.searchParams.get('center')!.split(',')\n\t\t\t\treturn `https://www.google.com/maps/@${lat},${lon},${zoom}z`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['val.town'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\t// e.g. extract \"steveruizok/mathFact\" from https://www.val.town/v/steveruizok/mathFact\n\t\t\tconst matches = urlObj && urlObj.pathname.match(/\\/embed\\/(.+)\\/?/)\n\t\t\tif (matches) {\n\t\t\t\treturn `https://www.val.town/v/${matches[1]}`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['codesandbox.io'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tconst matches = urlObj && urlObj.pathname.match(/\\/embed\\/([^/]+)\\/?/)\n\t\t\tif (matches) {\n\t\t\t\treturn `https://codesandbox.io/s/${matches[1]}`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['codepen.io'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst CODEPEN_EMBED_REGEXP = /https:\\/\\/codepen.io\\/([^/]+)\\/embed\\/([^/]+)/\n\t\t\tconst matches = url.match(CODEPEN_EMBED_REGEXP)\n\t\t\tif (matches) {\n\t\t\t\tconst [_, user, id] = matches\n\t\t\t\treturn `https://codepen.io/${user}/pen/${id}`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['scratch.mit.edu'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst SCRATCH_EMBED_REGEXP = /https:\\/\\/scratch.mit.edu\\/projects\\/embed\\/([^/]+)/\n\t\t\tconst matches = url.match(SCRATCH_EMBED_REGEXP)\n\t\t\tif (matches) {\n\t\t\t\tconst [_, id] = matches\n\t\t\t\treturn `https://scratch.mit.edu/projects/${id}`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['*.youtube.com', 'youtube.com', 'youtu.be'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (!urlObj) return\n\n\t\t\tconst hostname = urlObj.hostname.replace(/^www./, '')\n\t\t\tif (hostname === 'youtube.com') {\n\t\t\t\tconst matches = urlObj.pathname.match(/^\\/embed\\/([^/]+)\\/?/)\n\t\t\t\tif (matches) {\n\t\t\t\t\treturn `https://www.youtube.com/watch?v=${matches[1]}`\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['calendar.google.*'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tconst srcQs = urlObj?.searchParams.get('src')\n\n\t\t\tif (urlObj?.pathname.match(/\\/calendar\\/embed/) && srcQs) {\n\t\t\t\turlObj.pathname = '/calendar/u/0'\n\t\t\t\tconst keys = Array.from(urlObj.searchParams.keys())\n\t\t\t\tfor (const key of keys) {\n\t\t\t\t\turlObj.searchParams.delete(key)\n\t\t\t\t}\n\t\t\t\turlObj.searchParams.set('cid', srcQs)\n\t\t\t\treturn urlObj.href\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['docs.google.*'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\n\t\t\tif (urlObj?.pathname.match(/^\\/presentation/) && urlObj?.pathname.match(/\\/embed\\/?$/)) {\n\t\t\t\turlObj.pathname = urlObj.pathname.replace(/\\/embed$/, '/pub')\n\t\t\t\tconst keys = Array.from(urlObj.searchParams.keys())\n\t\t\t\tfor (const key of keys) {\n\t\t\t\t\turlObj.searchParams.delete(key)\n\t\t\t\t}\n\t\t\t\treturn urlObj.href\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['gist.github.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/\\/([^/]+)\\/([^/]+)/)) {\n\t\t\t\tif (!url.split('/').pop()) return\n\t\t\t\treturn url\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['replit.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (\n\t\t\t\turlObj &&\n\t\t\t\turlObj.pathname.match(/\\/@([^/]+)\\/([^/]+)/) &&\n\t\t\t\turlObj.searchParams.has('embed')\n\t\t\t) {\n\t\t\t\turlObj.searchParams.delete('embed')\n\t\t\t\treturn urlObj.href\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['felt.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/map\\//)) {\n\t\t\t\turlObj.pathname = urlObj.pathname.replace(/^\\/embed/, '')\n\t\t\t\treturn urlObj.href\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['open.spotify.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/(artist|album)\\//)) {\n\t\t\t\treturn urlObj.origin + urlObj.pathname.replace(/^\\/embed/, '')\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['vimeo.com', 'player.vimeo.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.hostname === 'player.vimeo.com') {\n\t\t\t\tconst matches = urlObj.pathname.match(/^\\/video\\/([^/]+)\\/?$/)\n\t\t\t\tif (matches) {\n\t\t\t\t\treturn 'https://vimeo.com/' + matches[1]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['excalidraw.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.hash.match(/#room=/)) {\n\t\t\t\treturn url\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['observablehq.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/@([^/]+)\\/([^/]+)\\/?$/)) {\n\t\t\t\treturn `${urlObj.origin}${urlObj.pathname.replace('/embed', '')}#cell-*`\n\t\t\t}\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/([^/]+)\\/?$/)) {\n\t\t\t\treturn `${urlObj.origin}${urlObj.pathname.replace('/embed', '/d')}#cell-*`\n\t\t\t}\n\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['desmos.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (\n\t\t\t\turlObj &&\n\t\t\t\turlObj.hostname === 'www.desmos.com' &&\n\t\t\t\turlObj.pathname.match(/^\\/calculator\\/([^/]+)\\/?$/) &&\n\t\t\t\turlObj.search === '?embed' &&\n\t\t\t\turlObj.hash === ''\n\t\t\t) {\n\t\t\t\treturn url.replace('?embed', '')\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n]\n\n/** @public */\nexport interface TLEmbedShapeProps {\n\tw: number\n\th: number\n\turl: string\n}\n\n/** @public */\nexport type TLEmbedShape = TLBaseShape<'embed', TLEmbedShapeProps>\n\n/** @public */\nexport const embedShapeProps: RecordProps<TLEmbedShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\turl: T.string,\n}\n\nconst Versions = createShapePropsMigrationIds('embed', {\n\tGenOriginalUrlInEmbed: 1,\n\tRemoveDoesResize: 2,\n\tRemoveTmpOldUrl: 3,\n\tRemovePermissionOverrides: 4,\n})\n\nexport { Versions as embedShapeVersions }\n\n/** @public */\nexport const embedShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.GenOriginalUrlInEmbed,\n\t\t\t// add tmpOldUrl property\n\t\t\tup: (props) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst url = props.url\n\t\t\t\t\tconst host = new URL(url).host.replace('www.', '')\n\t\t\t\t\tlet originalUrl\n\t\t\t\t\tfor (const localEmbedDef of EMBED_DEFINITIONS) {\n\t\t\t\t\t\tif (localEmbedDef.hostnames.includes(host)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toriginalUrl = localEmbedDef.fromEmbedUrl(url)\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tconsole.warn(err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tprops.tmpOldUrl = props.url\n\t\t\t\t\tprops.url = originalUrl ?? ''\n\t\t\t\t} catch (e) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t\tprops.tmpOldUrl = props.url\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.RemoveDoesResize,\n\t\t\tup: (props) => {\n\t\t\t\tdelete props.doesResize\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.RemoveTmpOldUrl,\n\t\t\tup: (props) => {\n\t\t\t\tdelete props.tmpOldUrl\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.RemovePermissionOverrides,\n\t\t\tup: (props) => {\n\t\t\t\tdelete props.overridePermissions\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t],\n})\n", "import { T } from '@tldraw/validate'\nimport { createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport interface TLFrameShapeProps {\n\tw: number\n\th: number\n\tname: string\n}\n\n/** @public */\nexport type TLFrameShape = TLBaseShape<'frame', TLFrameShapeProps>\n\n/** @public */\nexport const frameShapeProps: RecordProps<TLFrameShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\tname: T.string,\n}\n\n/** @public */\nexport const frameShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [],\n})\n", "import { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { StyleProp } from '../styles/StyleProp'\nimport {\n\tDefaultColorStyle,\n\tDefaultLabelColorStyle,\n\tTLDefaultColorStyle,\n} from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultFillStyle, TLDefaultFillStyle } from '../styles/TLFillStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport {\n\tDefaultHorizontalAlignStyle,\n\tTLDefaultHorizontalAlignStyle,\n} from '../styles/TLHorizontalAlignStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport {\n\tDefaultVerticalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n} from '../styles/TLVerticalAlignStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport const GeoShapeGeoStyle = StyleProp.defineEnum('tldraw:geo', {\n\tdefaultValue: 'rectangle',\n\tvalues: [\n\t\t'cloud',\n\t\t'rectangle',\n\t\t'ellipse',\n\t\t'triangle',\n\t\t'diamond',\n\t\t'pentagon',\n\t\t'hexagon',\n\t\t'octagon',\n\t\t'star',\n\t\t'rhombus',\n\t\t'rhombus-2',\n\t\t'oval',\n\t\t'trapezoid',\n\t\t'arrow-right',\n\t\t'arrow-left',\n\t\t'arrow-up',\n\t\t'arrow-down',\n\t\t'x-box',\n\t\t'check-box',\n\t\t'heart',\n\t],\n})\n\n/** @public */\nexport type TLGeoShapeGeoStyle = T.TypeOf<typeof GeoShapeGeoStyle>\n\n/** @public */\nexport interface TLGeoShapeProps {\n\tgeo: TLGeoShapeGeoStyle\n\tlabelColor: TLDefaultColorStyle\n\tcolor: TLDefaultColorStyle\n\tfill: TLDefaultFillStyle\n\tdash: TLDefaultDashStyle\n\tsize: TLDefaultSizeStyle\n\tfont: TLDefaultFontStyle\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\turl: string\n\tw: number\n\th: number\n\tgrowY: number\n\ttext: string\n\tscale: number\n}\n\n/** @public */\nexport type TLGeoShape = TLBaseShape<'geo', TLGeoShapeProps>\n\n/** @public */\nexport const geoShapeProps: RecordProps<TLGeoShape> = {\n\tgeo: GeoShapeGeoStyle,\n\tlabelColor: DefaultLabelColorStyle,\n\tcolor: DefaultColorStyle,\n\tfill: DefaultFillStyle,\n\tdash: DefaultDashStyle,\n\tsize: DefaultSizeStyle,\n\tfont: DefaultFontStyle,\n\talign: DefaultHorizontalAlignStyle,\n\tverticalAlign: DefaultVerticalAlignStyle,\n\turl: T.linkUrl,\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\tgrowY: T.positiveNumber,\n\ttext: T.string,\n\tscale: T.nonZeroNumber,\n}\n\nconst geoShapeVersions = createShapePropsMigrationIds('geo', {\n\tAddUrlProp: 1,\n\tAddLabelColor: 2,\n\tRemoveJustify: 3,\n\tAddCheckBox: 4,\n\tAddVerticalAlign: 5,\n\tMigrateLegacyAlign: 6,\n\tAddCloud: 7,\n\tMakeUrlsValid: 8,\n\tAddScale: 9,\n})\n\nexport { geoShapeVersions as geoShapeVersions }\n\n/** @public */\nexport const geoShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: geoShapeVersions.AddUrlProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.url = ''\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddLabelColor,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelColor = 'black'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.RemoveJustify,\n\t\t\tup: (props) => {\n\t\t\t\tif (props.align === 'justify') {\n\t\t\t\t\tprops.align = 'start'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddCheckBox,\n\t\t\tup: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddVerticalAlign,\n\t\t\tup: (props) => {\n\t\t\t\tprops.verticalAlign = 'middle'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.MigrateLegacyAlign,\n\t\t\tup: (props) => {\n\t\t\t\tlet newAlign: TLDefaultHorizontalAlignStyle\n\t\t\t\tswitch (props.align) {\n\t\t\t\t\tcase 'start':\n\t\t\t\t\t\tnewAlign = 'start-legacy'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase 'end':\n\t\t\t\t\t\tnewAlign = 'end-legacy'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnewAlign = 'middle-legacy'\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tprops.align = newAlign\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddCloud,\n\t\t\tup: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/** @public */\nexport const DefaultHorizontalAlignStyle = StyleProp.defineEnum('tldraw:horizontalAlign', {\n\tdefaultValue: 'middle',\n\tvalues: ['start', 'middle', 'end', 'start-legacy', 'end-legacy', 'middle-legacy'],\n})\n\n/** @public */\nexport type TLDefaultHorizontalAlignStyle = T.TypeOf<typeof DefaultHorizontalAlignStyle>\n", "import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/** @public */\nexport const DefaultVerticalAlignStyle = StyleProp.defineEnum('tldraw:verticalAlign', {\n\tdefaultValue: 'middle',\n\tvalues: ['start', 'middle', 'end'],\n})\n\n/** @public */\nexport type TLDefaultVerticalAlignStyle = T.TypeOf<typeof DefaultVerticalAlignStyle>\n", "import { createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface TLGroupShapeProps {}\n\n/** @public */\nexport type TLGroupShape = TLBaseShape<'group', TLGroupShapeProps>\n\n/** @public */\nexport const groupShapeProps: RecordProps<TLGroupShape> = {}\n\n/** @public */\nexport const groupShapeMigrations = createShapePropsMigrationSequence({ sequence: [] })\n", "import { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\nimport { DrawShapeSegment, TLDrawShapeSegment } from './TLDrawShape'\n\n/** @public */\nexport interface TLHighlightShapeProps {\n\tcolor: TLDefaultColorStyle\n\tsize: TLDefaultSizeStyle\n\tsegments: TLDrawShapeSegment[]\n\tisComplete: boolean\n\tisPen: boolean\n\tscale: number\n}\n\n/** @public */\nexport type TLHighlightShape = TLBaseShape<'highlight', TLHighlightShapeProps>\n\n/** @public */\nexport const highlightShapeProps: RecordProps<TLHighlightShape> = {\n\tcolor: DefaultColorStyle,\n\tsize: DefaultSizeStyle,\n\tsegments: T.arrayOf(DrawShapeSegment),\n\tisComplete: T.boolean,\n\tisPen: T.boolean,\n\tscale: T.nonZeroNumber,\n}\n\nconst Versions = createShapePropsMigrationIds('highlight', {\n\tAddScale: 1,\n})\n\nexport { Versions as highlightShapeVersions }\n\n/** @public */\nexport const highlightShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { T } from '@tldraw/validate'\nimport { assetIdValidator } from '../assets/TLBaseAsset'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport { TLAssetId } from '../records/TLAsset'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport interface TLImageShapeCrop {\n\ttopLeft: VecModel\n\tbottomRight: VecModel\n}\n\n/** @public */\nexport const ImageShapeCrop: T.ObjectValidator<TLImageShapeCrop> = T.object({\n\ttopLeft: vecModelValidator,\n\tbottomRight: vecModelValidator,\n})\n\n/** @public */\nexport interface TLImageShapeProps {\n\tw: number\n\th: number\n\tplaying: boolean\n\turl: string\n\tassetId: TLAssetId | null\n\tcrop: TLImageShapeCrop | null\n\tflipX: boolean\n\tflipY: boolean\n}\n\n/** @public */\nexport type TLImageShape = TLBaseShape<'image', TLImageShapeProps>\n\n/** @public */\nexport const imageShapeProps: RecordProps<TLImageShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\tplaying: T.boolean,\n\turl: T.linkUrl,\n\tassetId: assetIdValidator.nullable(),\n\tcrop: ImageShapeCrop.nullable(),\n\tflipX: T.boolean,\n\tflipY: T.boolean,\n}\n\nconst Versions = createShapePropsMigrationIds('image', {\n\tAddUrlProp: 1,\n\tAddCropProp: 2,\n\tMakeUrlsValid: 3,\n\tAddFlipProps: 4,\n})\n\nexport { Versions as imageShapeVersions }\n\n/** @public */\nexport const imageShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddUrlProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.url = ''\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddCropProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.crop = null\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.crop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFlipProps,\n\t\t\tup: (props) => {\n\t\t\t\tprops.flipX = false\n\t\t\t\tprops.flipY = false\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.flipX\n\t\t\t\tdelete props.flipY\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { IndexKey, getIndices, objectMapFromEntries, sortByIndex } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { StyleProp } from '../styles/StyleProp'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport const LineShapeSplineStyle = StyleProp.defineEnum('tldraw:spline', {\n\tdefaultValue: 'line',\n\tvalues: ['cubic', 'line'],\n})\n\n/** @public */\nexport type TLLineShapeSplineStyle = T.TypeOf<typeof LineShapeSplineStyle>\n\n/** @public */\nexport interface TLLineShapePoint {\n\tid: string\n\tindex: IndexKey\n\tx: number\n\ty: number\n}\n\nconst lineShapePointValidator: T.ObjectValidator<TLLineShapePoint> = T.object({\n\tid: T.string,\n\tindex: T.indexKey,\n\tx: T.number,\n\ty: T.number,\n})\n\n/** @public */\nexport interface TLLineShapeProps {\n\tcolor: TLDefaultColorStyle\n\tdash: TLDefaultDashStyle\n\tsize: TLDefaultSizeStyle\n\tspline: TLLineShapeSplineStyle\n\tpoints: Record<string, TLLineShapePoint>\n\tscale: number\n}\n\n/** @public */\nexport type TLLineShape = TLBaseShape<'line', TLLineShapeProps>\n\n/** @public */\nexport const lineShapeProps: RecordProps<TLLineShape> = {\n\tcolor: DefaultColorStyle,\n\tdash: DefaultDashStyle,\n\tsize: DefaultSizeStyle,\n\tspline: LineShapeSplineStyle,\n\tpoints: T.dict(T.string, lineShapePointValidator),\n\tscale: T.nonZeroNumber,\n}\n\n/** @public */\nexport const lineShapeVersions = createShapePropsMigrationIds('line', {\n\tAddSnapHandles: 1,\n\tRemoveExtraHandleProps: 2,\n\tHandlesToPoints: 3,\n\tPointIndexIds: 4,\n\tAddScale: 5,\n})\n\n/** @public */\nexport const lineShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: lineShapeVersions.AddSnapHandles,\n\t\t\tup: (props) => {\n\t\t\t\tfor (const handle of Object.values(props.handles)) {\n\t\t\t\t\t;(handle as any).canSnap = true\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: lineShapeVersions.RemoveExtraHandleProps,\n\t\t\tup: (props) => {\n\t\t\t\tprops.handles = objectMapFromEntries(\n\t\t\t\t\tObject.values(props.handles).map((handle: any) => [\n\t\t\t\t\t\thandle.index,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t\t},\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tconst handles = Object.entries(props.handles)\n\t\t\t\t\t.map(([index, handle]: any) => ({ index, ...handle }))\n\t\t\t\t\t.sort(sortByIndex)\n\t\t\t\tprops.handles = Object.fromEntries(\n\t\t\t\t\thandles.map((handle, i) => {\n\t\t\t\t\t\tconst id =\n\t\t\t\t\t\t\ti === 0 ? 'start' : i === handles.length - 1 ? 'end' : `handle:${handle.index}`\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\ttype: 'vertex',\n\t\t\t\t\t\t\t\tcanBind: false,\n\t\t\t\t\t\t\t\tcanSnap: true,\n\t\t\t\t\t\t\t\tindex: handle.index,\n\t\t\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: lineShapeVersions.HandlesToPoints,\n\t\t\tup: (props) => {\n\t\t\t\tconst sortedHandles = (\n\t\t\t\t\tObject.entries(props.handles) as [IndexKey, { x: number; y: number }][]\n\t\t\t\t)\n\t\t\t\t\t.map(([index, { x, y }]) => ({ x, y, index }))\n\t\t\t\t\t.sort(sortByIndex)\n\n\t\t\t\tprops.points = sortedHandles.map(({ x, y }) => ({ x, y }))\n\t\t\t\tdelete props.handles\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tconst indices = getIndices(props.points.length)\n\n\t\t\t\tprops.handles = Object.fromEntries(\n\t\t\t\t\tprops.points.map((handle: { x: number; y: number }, i: number) => {\n\t\t\t\t\t\tconst index = indices[i]\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\n\t\t\t\tdelete props.points\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: lineShapeVersions.PointIndexIds,\n\t\t\tup: (props) => {\n\t\t\t\tconst indices = getIndices(props.points.length)\n\n\t\t\t\tprops.points = Object.fromEntries(\n\t\t\t\t\tprops.points.map((point: { x: number; y: number }, i: number) => {\n\t\t\t\t\t\tconst id = indices[i]\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\t\tindex: id,\n\t\t\t\t\t\t\t\tx: point.x,\n\t\t\t\t\t\t\t\ty: point.y,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tconst sortedHandles = (\n\t\t\t\t\tObject.values(props.points) as { x: number; y: number; index: IndexKey }[]\n\t\t\t\t).sort(sortByIndex)\n\n\t\t\t\tprops.points = sortedHandles.map(({ x, y }) => ({ x, y }))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: lineShapeVersions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport {\n\tDefaultHorizontalAlignStyle,\n\tTLDefaultHorizontalAlignStyle,\n} from '../styles/TLHorizontalAlignStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport {\n\tDefaultVerticalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n} from '../styles/TLVerticalAlignStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport interface TLNoteShapeProps {\n\tcolor: TLDefaultColorStyle\n\tsize: TLDefaultSizeStyle\n\tfont: TLDefaultFontStyle\n\tfontSizeAdjustment: number\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\tgrowY: number\n\turl: string\n\ttext: string\n\tscale: number\n}\n\n/** @public */\nexport type TLNoteShape = TLBaseShape<'note', TLNoteShapeProps>\n\n/** @public */\nexport const noteShapeProps: RecordProps<TLNoteShape> = {\n\tcolor: DefaultColorStyle,\n\tsize: DefaultSizeStyle,\n\tfont: DefaultFontStyle,\n\tfontSizeAdjustment: T.positiveNumber,\n\talign: DefaultHorizontalAlignStyle,\n\tverticalAlign: DefaultVerticalAlignStyle,\n\tgrowY: T.positiveNumber,\n\turl: T.linkUrl,\n\ttext: T.string,\n\tscale: T.nonZeroNumber,\n}\n\nconst Versions = createShapePropsMigrationIds('note', {\n\tAddUrlProp: 1,\n\tRemoveJustify: 2,\n\tMigrateLegacyAlign: 3,\n\tAddVerticalAlign: 4,\n\tMakeUrlsValid: 5,\n\tAddFontSizeAdjustment: 6,\n\tAddScale: 7,\n})\n\nexport { Versions as noteShapeVersions }\n\n/** @public */\nexport const noteShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddUrlProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.url = ''\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.RemoveJustify,\n\t\t\tup: (props) => {\n\t\t\t\tif (props.align === 'justify') {\n\t\t\t\t\tprops.align = 'start'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.MigrateLegacyAlign,\n\t\t\tup: (props) => {\n\t\t\t\tswitch (props.align) {\n\t\t\t\t\tcase 'start':\n\t\t\t\t\t\tprops.align = 'start-legacy'\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase 'end':\n\t\t\t\t\t\tprops.align = 'end-legacy'\n\t\t\t\t\t\treturn\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprops.align = 'middle-legacy'\n\t\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddVerticalAlign,\n\t\t\tup: (props) => {\n\t\t\t\tprops.verticalAlign = 'middle'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFontSizeAdjustment,\n\t\t\tup: (props) => {\n\t\t\t\tprops.fontSizeAdjustment = 0\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.fontSizeAdjustment\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { DefaultTextAlignStyle, TLDefaultTextAlignStyle } from '../styles/TLTextAlignStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport interface TLTextShapeProps {\n\tcolor: TLDefaultColorStyle\n\tsize: TLDefaultSizeStyle\n\tfont: TLDefaultFontStyle\n\ttextAlign: TLDefaultTextAlignStyle\n\tw: number\n\ttext: string\n\tscale: number\n\tautoSize: boolean\n}\n\n/** @public */\nexport type TLTextShape = TLBaseShape<'text', TLTextShapeProps>\n\n/** @public */\nexport const textShapeProps: RecordProps<TLTextShape> = {\n\tcolor: DefaultColorStyle,\n\tsize: DefaultSizeStyle,\n\tfont: DefaultFontStyle,\n\ttextAlign: DefaultTextAlignStyle,\n\tw: T.nonZeroNumber,\n\ttext: T.string,\n\tscale: T.nonZeroNumber,\n\tautoSize: T.boolean,\n}\n\nconst Versions = createShapePropsMigrationIds('text', {\n\tRemoveJustify: 1,\n\tAddTextAlign: 2,\n})\n\nexport { Versions as textShapeVersions }\n\n/** @public */\nexport const textShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.RemoveJustify,\n\t\t\tup: (props) => {\n\t\t\t\tif (props.align === 'justify') {\n\t\t\t\t\tprops.align = 'start'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddTextAlign,\n\t\t\tup: (props) => {\n\t\t\t\tprops.textAlign = props.align\n\t\t\t\tdelete props.align\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tprops.align = props.textAlign\n\t\t\t\tdelete props.textAlign\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/** @public */\nexport const DefaultTextAlignStyle = StyleProp.defineEnum('tldraw:textAlign', {\n\tdefaultValue: 'start',\n\tvalues: ['start', 'middle', 'end'],\n})\n\n/** @public */\nexport type TLDefaultTextAlignStyle = T.TypeOf<typeof DefaultTextAlignStyle>\n", "import { T } from '@tldraw/validate'\nimport { assetIdValidator } from '../assets/TLBaseAsset'\nimport { TLAssetId } from '../records/TLAsset'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n/** @public */\nexport interface TLVideoShapeProps {\n\tw: number\n\th: number\n\ttime: number\n\tplaying: boolean\n\turl: string\n\tassetId: TLAssetId | null\n}\n\n/** @public */\nexport type TLVideoShape = TLBaseShape<'video', TLVideoShapeProps>\n\n/** @public */\nexport const videoShapeProps: RecordProps<TLVideoShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\ttime: T.number,\n\tplaying: T.boolean,\n\turl: T.linkUrl,\n\tassetId: assetIdValidator.nullable(),\n}\n\nconst Versions = createShapePropsMigrationIds('video', {\n\tAddUrlProp: 1,\n\tMakeUrlsValid: 2,\n})\n\nexport { Versions as videoShapeVersions }\n\n/** @public */\nexport const videoShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddUrlProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.url = ''\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { createMigrationIds, createMigrationSequence } from '@tldraw/store'\nimport { objectMapEntries } from '@tldraw/utils'\nimport { TLShape } from './records/TLShape'\n\nconst Versions = createMigrationIds('com.tldraw.store', {\n\tRemoveCodeAndIconShapeTypes: 1,\n\tAddInstancePresenceType: 2,\n\tRemoveTLUserAndPresenceAndAddPointer: 3,\n\tRemoveUserDocument: 4,\n} as const)\n\nexport { Versions as storeVersions }\n\n/** @public */\nexport const storeMigrations = createMigrationSequence({\n\tsequenceId: 'com.tldraw.store',\n\tretroactive: false,\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.RemoveCodeAndIconShapeTypes,\n\t\t\tscope: 'store',\n\t\t\tup: (store) => {\n\t\t\t\tfor (const [id, record] of objectMapEntries(store)) {\n\t\t\t\t\tif (\n\t\t\t\t\t\trecord.typeName === 'shape' &&\n\t\t\t\t\t\t((record as TLShape).type === 'icon' || (record as TLShape).type === 'code')\n\t\t\t\t\t) {\n\t\t\t\t\t\tdelete store[id]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddInstancePresenceType,\n\t\t\tscope: 'store',\n\t\t\tup(_store) {\n\t\t\t\t// noop\n\t\t\t\t// there used to be a down migration for this but we made down migrations optional\n\t\t\t\t// and we don't use them on store-level migrations so we can just remove it\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// remove user and presence records and add pointer records\n\t\t\tid: Versions.RemoveTLUserAndPresenceAndAddPointer,\n\t\t\tscope: 'store',\n\t\t\tup: (store) => {\n\t\t\t\tfor (const [id, record] of objectMapEntries(store)) {\n\t\t\t\t\tif (record.typeName.match(/^(user|user_presence)$/)) {\n\t\t\t\t\t\tdelete store[id]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// remove user document records\n\t\t\tid: Versions.RemoveUserDocument,\n\t\t\tscope: 'store',\n\t\t\tup: (store) => {\n\t\t\t\tfor (const [id, record] of objectMapEntries(store)) {\n\t\t\t\t\tif (record.typeName.match('user_document')) {\n\t\t\t\t\t\tdelete store[id]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n", "import { IndexKey } from '@tldraw/utils'\nimport { SetValue } from '../util-types'\n\n/**\n * The handle types used by tldraw's default shapes.\n *\n * @public */\nexport const TL_HANDLE_TYPES = new Set(['vertex', 'virtual', 'create', 'clone'] as const)\n\n/**\n * A type for the handle types used by tldraw's default shapes.\n *\n * @public */\nexport type TLHandleType = SetValue<typeof TL_HANDLE_TYPES>\n\n/**\n * A base interface for a shape's handles.\n *\n * @public\n */\nexport interface TLHandle {\n\t/** A unique identifier for the handle. */\n\tid: string\n\ttype: TLHandleType\n\tcanSnap?: boolean\n\tindex: IndexKey\n\tx: number\n\ty: number\n}\n", "import { LANGUAGES } from './languages'\n\n/** @public */\nexport { LANGUAGES }\n\n/** @public */\nexport type TLLanguage = (typeof LANGUAGES)[number]\n// {\n// \treadonly locale: string\n// \treadonly label: string\n// }\n\n/** @public */\nexport function getDefaultTranslationLocale(): TLLanguage['locale'] {\n\tconst locales = typeof window !== 'undefined' ? window.navigator.languages ?? ['en'] : ['en']\n\treturn _getDefaultTranslationLocale(locales)\n}\n\n/** @internal */\nexport function _getDefaultTranslationLocale(locales: readonly string[]): TLLanguage['locale'] {\n\tfor (const locale of locales) {\n\t\tconst supportedLocale = getSupportedLocale(locale)\n\t\tif (supportedLocale) {\n\t\t\treturn supportedLocale\n\t\t}\n\t}\n\treturn 'en'\n}\n\n/** @public */\nconst DEFAULT_LOCALE_REGIONS: { [locale: string]: TLLanguage['locale'] } = {\n\tzh: 'zh-cn',\n\tpt: 'pt-br',\n\tko: 'ko-kr',\n\thi: 'hi-in',\n}\n\n/** @public */\nfunction getSupportedLocale(locale: string): TLLanguage['locale'] | null {\n\t// If we have an exact match, return it!\n\t// (e.g. if the user has 'fr' and we have 'fr')\n\t// (or if the user has 'pt-BR' and we have 'pt-br')\n\tconst exactMatch = LANGUAGES.find((t) => t.locale === locale.toLowerCase())\n\tif (exactMatch) {\n\t\treturn exactMatch.locale\n\t}\n\n\t// Otherwise, we need to be more flexible...\n\tconst [language, region] = locale.split(/[-_]/).map((s) => s.toLowerCase())\n\n\t// If the user's language has a region...\n\t// let's try to find non-region-specific locale for them\n\t// (e.g. if they have 'fr-CA' but we only have 'fr')\n\tif (region) {\n\t\tconst languageMatch = LANGUAGES.find((t) => t.locale === language)\n\t\tif (languageMatch) {\n\t\t\treturn languageMatch.locale\n\t\t}\n\t}\n\n\t// If the user's language doesn't have a region...\n\t// let's try to find a region-specific locale for them\n\t// (e.g. if they have 'pt' but we only have 'pt-pt' or 'pt-br')\n\t//\n\t// In this case, we choose the hard-coded default region for that language\n\tif (language in DEFAULT_LOCALE_REGIONS) {\n\t\treturn DEFAULT_LOCALE_REGIONS[language]\n\t}\n\n\t// Oh no! We don't have a translation for this language!\n\t// Let's give up...\n\treturn null\n}\n", "// This file is automatically generated by internal/scripts/refresh-assets.ts.\n// Do not edit manually. Or do, I'm a comment, not a cop.\n\n/** @public */\nexport const LANGUAGES = [\n\t{ locale: 'id', label: 'Bahasa Indonesia' },\n\t{ locale: 'ca', label: 'Catal\u00E0' },\n\t{ locale: 'cs', label: '\u010Ce\u0161tina' },\n\t{ locale: 'da', label: 'Danish' },\n\t{ locale: 'de', label: 'Deutsch' },\n\t{ locale: 'en', label: 'English' },\n\t{ locale: 'es', label: 'Espa\u00F1ol' },\n\t{ locale: 'fr', label: 'Fran\u00E7ais' },\n\t{ locale: 'gl', label: 'Galego' },\n\t{ locale: 'hr', label: 'Hrvatski' },\n\t{ locale: 'it', label: 'Italiano' },\n\t{ locale: 'hu', label: 'Magyar' },\n\t{ locale: 'no', label: 'Norwegian' },\n\t{ locale: 'pl', label: 'Polski' },\n\t{ locale: 'pt-br', label: 'Portugu\u00EAs - Brasil' },\n\t{ locale: 'pt-pt', label: 'Portugu\u00EAs - Europeu' },\n\t{ locale: 'ro', label: 'Rom\u00E2n\u0103' },\n\t{ locale: 'ru', label: 'Russian' },\n\t{ locale: 'sl', label: 'Sloven\u0161\u010Dina' },\n\t{ locale: 'fi', label: 'Suomi' },\n\t{ locale: 'sv', label: 'Svenska' },\n\t{ locale: 'vi', label: 'Ti\u1EBFng Vi\u1EC7t' },\n\t{ locale: 'tr', label: 'T\u00FCrk\u00E7e' },\n\t{ locale: 'uk', label: 'Ukrainian' },\n\t{ locale: 'he', label: '\u05E2\u05D1\u05E8\u05D9\u05EA' },\n\t{ locale: 'ar', label: '\u0639\u0631\u0628\u064A' },\n\t{ locale: 'fa', label: '\u0641\u0627\u0631\u0633\u06CC' },\n\t{ locale: 'ku', label: '\u06A9\u0648\u0631\u062F\u06CC' },\n\t{ locale: 'ne', label: '\u0928\u0947\u092A\u093E\u0932\u0940' },\n\t{ locale: 'hi-in', label: '\u0939\u093F\u0928\u094D\u0926\u0940' },\n\t{ locale: 'te', label: '\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41' },\n\t{ locale: 'th', label: '\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22' },\n\t{ locale: 'my', label: '\u1019\u103C\u1014\u103A\u1019\u102C\u1005\u102C' },\n\t{ locale: 'ko-kr', label: '\uD55C\uAD6D\uC5B4' },\n\t{ locale: 'ja', label: '\u65E5\u672C\u8A9E' },\n\t{ locale: 'zh-cn', label: '\u7B80\u4F53\u4E2D\u6587' },\n\t{ locale: 'zh-tw', label: '\u7E41\u9AD4\u4E2D\u6587 (\u53F0\u7063)' },\n] as const\n", "import { UnknownRecord } from '@tldraw/store'\nimport { TLRoomSocket } from './TLSyncRoom'\nimport { TLSocketServerSentEvent } from './protocol'\n\n/**\n * Minimal server-side WebSocket interface that is compatible with\n *\n * - The standard WebSocket interface (cloudflare, deno, some node setups)\n * - The 'ws' WebSocket interface (some node setups)\n * - The Bun.serve socket implementation\n *\n * @public\n */\nexport interface WebSocketMinimal {\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\taddEventListener?: (type: 'message' | 'close' | 'error', listener: (event: any) => void) => void\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tremoveEventListener?: (\n\t\ttype: 'message' | 'close' | 'error',\n\t\tlistener: (event: any) => void\n\t) => void\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tsend: (data: string) => void\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tclose: (code?: number, reason?: string) => void\n\treadyState: number\n}\n\n/** @internal */\nexport interface ServerSocketAdapterOptions<R extends UnknownRecord> {\n\treadonly ws: WebSocketMinimal\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\treadonly onBeforeSendMessage?: (msg: TLSocketServerSentEvent<R>, stringified: string) => void\n}\n\n/** @internal */\nexport class ServerSocketAdapter<R extends UnknownRecord> implements TLRoomSocket<R> {\n\tconstructor(public readonly opts: ServerSocketAdapterOptions<R>) {}\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isOpen(): boolean {\n\t\treturn this.opts.ws.readyState === 1 // ready state open\n\t}\n\t// see TLRoomSocket for details on why this accepts a union and not just arrays\n\tsendMessage(msg: TLSocketServerSentEvent<R>) {\n\t\tconst message = JSON.stringify(msg)\n\t\tthis.opts.onBeforeSendMessage?.(msg, message)\n\t\tthis.opts.ws.send(message)\n\t}\n\tclose(code?: number, reason?: string) {\n\t\tthis.opts.ws.close(code, reason)\n\t}\n}\n", "import { Atom, atom, transaction } from '@tldraw/state'\nimport {\n\tIdOf,\n\tMigrationFailureReason,\n\tRecordType,\n\tSerializedSchema,\n\tStoreSchema,\n\tUnknownRecord,\n} from '@tldraw/store'\nimport { DocumentRecordType, PageRecordType, TLDOCUMENT_ID } from '@tldraw/tlschema'\nimport {\n\tIndexKey,\n\tResult,\n\tassert,\n\tassertExists,\n\texhaustiveSwitchError,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tisNativeStructuredClone,\n\tobjectMapEntries,\n\tobjectMapKeys,\n\tstructuredClone,\n} from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\nimport { createNanoEvents } from 'nanoevents'\nimport {\n\tRoomSession,\n\tRoomSessionState,\n\tSESSION_IDLE_TIMEOUT,\n\tSESSION_REMOVAL_WAIT_TIME,\n\tSESSION_START_WAIT_TIME,\n} from './RoomSession'\nimport { TLSyncLog } from './TLSocketRoom'\nimport { TLSyncErrorCloseEventCode, TLSyncErrorCloseEventReason } from './TLSyncClient'\nimport {\n\tNetworkDiff,\n\tObjectDiff,\n\tRecordOp,\n\tRecordOpType,\n\tValueOpType,\n\tapplyObjectDiff,\n\tdiffRecord,\n} from './diff'\nimport { interval } from './interval'\nimport {\n\tTLIncompatibilityReason,\n\tTLSocketClientSentEvent,\n\tTLSocketServerSentDataEvent,\n\tTLSocketServerSentEvent,\n\tgetTlsyncProtocolVersion,\n} from './protocol'\n\n/** @internal */\nexport interface TLRoomSocket<R extends UnknownRecord> {\n\tisOpen: boolean\n\tsendMessage(msg: TLSocketServerSentEvent<R>): void\n\tclose(code?: number, reason?: string): void\n}\n\n// the max number of tombstones to keep in the store\nexport const MAX_TOMBSTONES = 3000\n// the number of tombstones to delete when the max is reached\nexport const TOMBSTONE_PRUNE_BUFFER_SIZE = 300\n// the minimum time between data-related messages to the clients\nexport const DATA_MESSAGE_DEBOUNCE_INTERVAL = 1000 / 60\n\nconst timeSince = (time: number) => Date.now() - time\n\n/** @internal */\nexport class DocumentState<R extends UnknownRecord> {\n\t_atom: Atom<{ state: R; lastChangedClock: number }>\n\n\tstatic createWithoutValidating<R extends UnknownRecord>(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\trecordType: RecordType<R, any>\n\t): DocumentState<R> {\n\t\treturn new DocumentState(state, lastChangedClock, recordType)\n\t}\n\n\tstatic createAndValidate<R extends UnknownRecord>(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\trecordType: RecordType<R, any>\n\t): Result<DocumentState<R>, Error> {\n\t\ttry {\n\t\t\trecordType.validate(state)\n\t\t} catch (error: any) {\n\t\t\treturn Result.err(error)\n\t\t}\n\t\treturn Result.ok(new DocumentState(state, lastChangedClock, recordType))\n\t}\n\n\tprivate constructor(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\tprivate readonly recordType: RecordType<R, any>\n\t) {\n\t\tthis._atom = atom('document:' + state.id, { state, lastChangedClock })\n\t}\n\t// eslint-disable-next-line no-restricted-syntax\n\tget state() {\n\t\treturn this._atom.get().state\n\t}\n\t// eslint-disable-next-line no-restricted-syntax\n\tget lastChangedClock() {\n\t\treturn this._atom.get().lastChangedClock\n\t}\n\treplaceState(state: R, clock: number): Result<ObjectDiff | null, Error> {\n\t\tconst diff = diffRecord(this.state, state)\n\t\tif (!diff) return Result.ok(null)\n\t\ttry {\n\t\t\tthis.recordType.validate(state)\n\t\t} catch (error: any) {\n\t\t\treturn Result.err(error)\n\t\t}\n\t\tthis._atom.set({ state, lastChangedClock: clock })\n\t\treturn Result.ok(diff)\n\t}\n\tmergeDiff(diff: ObjectDiff, clock: number): Result<ObjectDiff | null, Error> {\n\t\tconst newState = applyObjectDiff(this.state, diff)\n\t\treturn this.replaceState(newState, clock)\n\t}\n}\n\n/** @public */\nexport interface RoomSnapshot {\n\tclock: number\n\tdocuments: Array<{ state: UnknownRecord; lastChangedClock: number }>\n\ttombstones?: Record<string, number>\n\tschema?: SerializedSchema\n}\n\n/**\n * A room is a workspace for a group of clients. It allows clients to collaborate on documents\n * within that workspace.\n *\n * @internal\n */\nexport class TLSyncRoom<R extends UnknownRecord, SessionMeta> {\n\t// A table of connected clients\n\treadonly sessions = new Map<string, RoomSession<R, SessionMeta>>()\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tpruneSessions = () => {\n\t\tfor (const client of this.sessions.values()) {\n\t\t\tswitch (client.state) {\n\t\t\t\tcase RoomSessionState.Connected: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.lastInteractionTime) > SESSION_IDLE_TIMEOUT\n\t\t\t\t\tif (hasTimedOut || !client.socket.isOpen) {\n\t\t\t\t\t\tthis.cancelSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase RoomSessionState.AwaitingConnectMessage: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.sessionStartTime) > SESSION_START_WAIT_TIME\n\t\t\t\t\tif (hasTimedOut || !client.socket.isOpen) {\n\t\t\t\t\t\t// remove immediately\n\t\t\t\t\t\tthis.removeSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase RoomSessionState.AwaitingRemoval: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.cancellationTime) > SESSION_REMOVAL_WAIT_TIME\n\t\t\t\t\tif (hasTimedOut) {\n\t\t\t\t\t\tthis.removeSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\texhaustiveSwitchError(client)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate disposables: Array<() => void> = [interval(this.pruneSessions, 2000)]\n\n\tprivate _isClosed = false\n\n\tclose() {\n\t\tthis.disposables.forEach((d) => d())\n\t\tthis.sessions.forEach((session) => {\n\t\t\tsession.socket.close()\n\t\t})\n\t\tthis._isClosed = true\n\t}\n\n\tisClosed() {\n\t\treturn this._isClosed\n\t}\n\n\treadonly events = createNanoEvents<{\n\t\troom_became_empty(): void\n\t\tsession_removed(args: { sessionId: string; meta: SessionMeta }): void\n\t}>()\n\n\t// Values associated with each uid (must be serializable).\n\t/** @internal */\n\tstate = atom<{\n\t\tdocuments: Record<string, DocumentState<R>>\n\t\ttombstones: Record<string, number>\n\t}>('room state', {\n\t\tdocuments: {},\n\t\ttombstones: {},\n\t})\n\n\t// this clock should start higher than the client, to make sure that clients who sync with their\n\t// initial lastServerClock value get the full state\n\t// in this case clients will start with 0, and the server will start with 1\n\tclock = 1\n\tdocumentClock = 1\n\ttombstoneHistoryStartsAtClock = this.clock\n\t// map from record id to clock upon deletion\n\n\treadonly serializedSchema: SerializedSchema\n\n\treadonly documentTypes: Set<string>\n\treadonly presenceType: RecordType<R, any> | null\n\tprivate log?: TLSyncLog\n\tpublic readonly schema: StoreSchema<R, any>\n\tprivate onDataChange?(): void\n\n\tconstructor(opts: {\n\t\tlog?: TLSyncLog\n\t\tschema: StoreSchema<R, any>\n\t\tsnapshot?: RoomSnapshot\n\t\tonDataChange?(): void\n\t}) {\n\t\tthis.schema = opts.schema\n\t\tlet snapshot = opts.snapshot\n\t\tthis.log = opts.log\n\t\tthis.onDataChange = opts.onDataChange\n\n\t\tassert(\n\t\t\tisNativeStructuredClone,\n\t\t\t'TLSyncRoom is supposed to run either on Cloudflare Workers' +\n\t\t\t\t'or on a 18+ version of Node.js, which both support the native structuredClone API'\n\t\t)\n\n\t\t// do a json serialization cycle to make sure the schema has no 'undefined' values\n\t\tthis.serializedSchema = JSON.parse(JSON.stringify(this.schema.serialize()))\n\n\t\tthis.documentTypes = new Set(\n\t\t\tObject.values<RecordType<R, any>>(this.schema.types)\n\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t.map((t) => t.typeName)\n\t\t)\n\n\t\tconst presenceTypes = new Set(\n\t\t\tObject.values<RecordType<R, any>>(this.schema.types).filter((t) => t.scope === 'presence')\n\t\t)\n\n\t\tif (presenceTypes.size > 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`TLSyncRoom: exactly zero or one presence type is expected, but found ${presenceTypes.size}`\n\t\t\t)\n\t\t}\n\n\t\tthis.presenceType = presenceTypes.values().next()?.value\n\n\t\tif (!snapshot) {\n\t\t\tsnapshot = {\n\t\t\t\tclock: 0,\n\t\t\t\tdocuments: [\n\t\t\t\t\t{\n\t\t\t\t\t\tstate: DocumentRecordType.create({ id: TLDOCUMENT_ID }),\n\t\t\t\t\t\tlastChangedClock: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tstate: PageRecordType.create({ name: 'Page 1', index: 'a1' as IndexKey }),\n\t\t\t\t\t\tlastChangedClock: 0,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}\n\t\t}\n\n\t\tthis.clock = snapshot.clock\n\t\tlet didIncrementClock = false\n\t\tconst ensureClockDidIncrement = (_reason: string) => {\n\t\t\tif (!didIncrementClock) {\n\t\t\t\tdidIncrementClock = true\n\t\t\t\tthis.clock++\n\t\t\t}\n\t\t}\n\n\t\tconst tombstones = { ...snapshot.tombstones }\n\t\tconst filteredDocuments = []\n\t\tfor (const doc of snapshot.documents) {\n\t\t\tif (this.documentTypes.has(doc.state.typeName)) {\n\t\t\t\tfilteredDocuments.push(doc)\n\t\t\t} else {\n\t\t\t\tensureClockDidIncrement('doc type was not doc type')\n\t\t\t\ttombstones[doc.state.id] = this.clock\n\t\t\t}\n\t\t}\n\n\t\tconst documents: Record<string, DocumentState<R>> = Object.fromEntries(\n\t\t\tfilteredDocuments.map((r) => [\n\t\t\t\tr.state.id,\n\t\t\t\tDocumentState.createWithoutValidating<R>(\n\t\t\t\t\tr.state as R,\n\t\t\t\t\tr.lastChangedClock,\n\t\t\t\t\tassertExists(getOwnProperty(this.schema.types, r.state.typeName))\n\t\t\t\t),\n\t\t\t])\n\t\t)\n\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot({\n\t\t\tstore: Object.fromEntries(\n\t\t\t\tobjectMapEntries(documents).map(([id, { state }]) => [id, state as R])\n\t\t\t) as Record<IdOf<R>, R>,\n\t\t\t// eslint-disable-next-line deprecation/deprecation\n\t\t\tschema: snapshot.schema ?? this.schema.serializeEarliestVersion(),\n\t\t})\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\t// TODO: Fault tolerance\n\t\t\tthrow new Error('Failed to migrate: ' + migrationResult.reason)\n\t\t}\n\n\t\tfor (const [id, r] of objectMapEntries(migrationResult.value)) {\n\t\t\tconst existing = documents[id]\n\t\t\tif (!existing) {\n\t\t\t\t// record was added during migration\n\t\t\t\tensureClockDidIncrement('record was added during migration')\n\t\t\t\tdocuments[id] = DocumentState.createWithoutValidating(\n\t\t\t\t\tr,\n\t\t\t\t\tthis.clock,\n\t\t\t\t\tassertExists(getOwnProperty(this.schema.types, r.typeName)) as any\n\t\t\t\t)\n\t\t\t} else if (!isEqual(existing.state, r)) {\n\t\t\t\t// record was maybe updated during migration\n\t\t\t\tensureClockDidIncrement('record was maybe updated during migration')\n\t\t\t\texisting.replaceState(r, this.clock)\n\t\t\t}\n\t\t}\n\n\t\tfor (const id of objectMapKeys(documents)) {\n\t\t\tif (!migrationResult.value[id as keyof typeof migrationResult.value]) {\n\t\t\t\t// record was removed during migration\n\t\t\t\tensureClockDidIncrement('record was removed during migration')\n\t\t\t\ttombstones[id] = this.clock\n\t\t\t\tdelete documents[id]\n\t\t\t}\n\t\t}\n\n\t\tthis.state.set({ documents, tombstones })\n\n\t\tthis.pruneTombstones()\n\t\tthis.documentClock = this.clock\n\t\tif (didIncrementClock) {\n\t\t\topts.onDataChange?.()\n\t\t}\n\t}\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tprivate pruneTombstones = () => {\n\t\t// avoid blocking any pending responses\n\t\tthis.state.update(({ tombstones, documents }) => {\n\t\t\tconst entries = Object.entries(this.state.get().tombstones)\n\t\t\tif (entries.length > MAX_TOMBSTONES) {\n\t\t\t\t// sort entries in ascending order by clock\n\t\t\t\tentries.sort((a, b) => a[1] - b[1])\n\t\t\t\t// trim off the first bunch\n\t\t\t\tconst excessQuantity = entries.length - MAX_TOMBSTONES\n\t\t\t\ttombstones = Object.fromEntries(entries.slice(excessQuantity + TOMBSTONE_PRUNE_BUFFER_SIZE))\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tdocuments,\n\t\t\t\ttombstones,\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate getDocument(id: string) {\n\t\treturn this.state.get().documents[id]\n\t}\n\n\tprivate addDocument(id: string, state: R, clock: number): Result<void, Error> {\n\t\tlet { documents, tombstones } = this.state.get()\n\t\tif (hasOwnProperty(tombstones, id)) {\n\t\t\ttombstones = { ...tombstones }\n\t\t\tdelete tombstones[id]\n\t\t}\n\t\tconst createResult = DocumentState.createAndValidate(\n\t\t\tstate,\n\t\t\tclock,\n\t\t\tassertExists(getOwnProperty(this.schema.types, state.typeName))\n\t\t)\n\t\tif (!createResult.ok) return createResult\n\t\tdocuments = { ...documents, [id]: createResult.value }\n\t\tthis.state.set({ documents, tombstones })\n\t\treturn Result.ok(undefined)\n\t}\n\n\tprivate removeDocument(id: string, clock: number) {\n\t\tthis.state.update(({ documents, tombstones }) => {\n\t\t\tdocuments = { ...documents }\n\t\t\tdelete documents[id]\n\t\t\ttombstones = { ...tombstones, [id]: clock }\n\t\t\treturn { documents, tombstones }\n\t\t})\n\t}\n\n\tgetSnapshot(): RoomSnapshot {\n\t\tconst { documents, tombstones } = this.state.get()\n\t\treturn {\n\t\t\tclock: this.clock,\n\t\t\ttombstones,\n\t\t\tschema: this.serializedSchema,\n\t\t\tdocuments: Object.values(documents)\n\t\t\t\t.filter((d) => this.documentTypes.has(d.state.typeName))\n\t\t\t\t.map((doc) => ({\n\t\t\t\t\tstate: doc.state,\n\t\t\t\t\tlastChangedClock: doc.lastChangedClock,\n\t\t\t\t})),\n\t\t}\n\t}\n\n\t/**\n\t * Send a message to a particular client. Debounces data events\n\t *\n\t * @param sessionId - The id of the session to send the message to.\n\t * @param message - The message to send.\n\t */\n\tprivate sendMessage(\n\t\tsessionId: string,\n\t\tmessage: TLSocketServerSentEvent<R> | TLSocketServerSentDataEvent<R>\n\t) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Tried to send message to unknown session', message.type)\n\t\t\treturn\n\t\t}\n\t\tif (session.state !== RoomSessionState.Connected) {\n\t\t\tthis.log?.warn?.('Tried to send message to disconnected client', message.type)\n\t\t\treturn\n\t\t}\n\t\tif (session.socket.isOpen) {\n\t\t\tif (message.type !== 'patch' && message.type !== 'push_result') {\n\t\t\t\t// this is not a data message\n\t\t\t\tif (message.type !== 'pong') {\n\t\t\t\t\t// non-data messages like \"connect\" might still need to be ordered correctly with\n\t\t\t\t\t// respect to data messages, so it's better to flush just in case\n\t\t\t\t\tthis._flushDataMessages(sessionId)\n\t\t\t\t}\n\t\t\t\tsession.socket.sendMessage(message)\n\t\t\t} else {\n\t\t\t\tif (session.debounceTimer === null) {\n\t\t\t\t\t// this is the first message since the last flush, don't delay it\n\t\t\t\t\tsession.socket.sendMessage({ type: 'data', data: [message] })\n\n\t\t\t\t\tsession.debounceTimer = setTimeout(\n\t\t\t\t\t\t() => this._flushDataMessages(sessionId),\n\t\t\t\t\t\tDATA_MESSAGE_DEBOUNCE_INTERVAL\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tsession.outstandingDataMessages.push(message)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cancelSession(session.sessionId)\n\t\t}\n\t}\n\n\t// needs to accept sessionId and not a session because the session might be dead by the time\n\t// the timer fires\n\t_flushDataMessages(sessionId: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\n\t\tif (!session || session.state !== RoomSessionState.Connected) {\n\t\t\treturn\n\t\t}\n\n\t\tsession.debounceTimer = null\n\n\t\tif (session.outstandingDataMessages.length > 0) {\n\t\t\tsession.socket.sendMessage({ type: 'data', data: session.outstandingDataMessages })\n\t\t\tsession.outstandingDataMessages.length = 0\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate removeSession(sessionId: string, fatalReason?: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Tried to remove unknown session')\n\t\t\treturn\n\t\t}\n\n\t\tthis.sessions.delete(sessionId)\n\n\t\tconst presence = this.getDocument(session.presenceId ?? '')\n\n\t\ttry {\n\t\t\tif (session.socket.isOpen) {\n\t\t\t\tif (fatalReason) {\n\t\t\t\t\tsession.socket.close(TLSyncErrorCloseEventCode, fatalReason)\n\t\t\t\t} else {\n\t\t\t\t\tsession.socket.close()\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (_e) {\n\t\t\t// noop\n\t\t}\n\n\t\tif (presence) {\n\t\t\tthis.state.update(({ tombstones, documents }) => {\n\t\t\t\tdocuments = { ...documents }\n\t\t\t\tdelete documents[session.presenceId!]\n\t\t\t\treturn { documents, tombstones }\n\t\t\t})\n\n\t\t\tthis.broadcastPatch({\n\t\t\t\tdiff: { [session.presenceId!]: [RecordOpType.Remove] },\n\t\t\t\tsourceSessionId: sessionId,\n\t\t\t})\n\t\t}\n\n\t\tthis.events.emit('session_removed', { sessionId, meta: session.meta })\n\t\tif (this.sessions.size === 0) {\n\t\t\tthis.events.emit('room_became_empty')\n\t\t}\n\t}\n\n\tprivate cancelSession(sessionId: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\treturn\n\t\t}\n\n\t\tif (session.state === RoomSessionState.AwaitingRemoval) {\n\t\t\tthis.log?.warn?.('Tried to cancel session that is already awaiting removal')\n\t\t\treturn\n\t\t}\n\n\t\tthis.sessions.set(sessionId, {\n\t\t\tstate: RoomSessionState.AwaitingRemoval,\n\t\t\tsessionId,\n\t\t\tpresenceId: session.presenceId,\n\t\t\tsocket: session.socket,\n\t\t\tcancellationTime: Date.now(),\n\t\t\tmeta: session.meta,\n\t\t\tisReadonly: session.isReadonly,\n\t\t\trequiresLegacyRejection: session.requiresLegacyRejection,\n\t\t})\n\t}\n\n\t/**\n\t * Broadcast a message to all connected clients except the one with the sessionId provided.\n\t *\n\t * @param message - The message to broadcast.\n\t */\n\tbroadcastPatch(message: { diff: NetworkDiff<R>; sourceSessionId?: string }) {\n\t\tconst { diff, sourceSessionId } = message\n\t\tthis.sessions.forEach((session) => {\n\t\t\tif (session.state !== RoomSessionState.Connected) return\n\t\t\tif (sourceSessionId === session.sessionId) return\n\t\t\tif (!session.socket.isOpen) {\n\t\t\t\tthis.cancelSession(session.sessionId)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst res = this.migrateDiffForSession(session.serializedSchema, diff)\n\n\t\t\tif (!res.ok) {\n\t\t\t\t// disconnect client and send incompatibility error\n\t\t\t\tthis.rejectSession(\n\t\t\t\t\tsession.sessionId,\n\t\t\t\t\tres.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\ttype: 'patch',\n\t\t\t\tdiff: res.value,\n\t\t\t\tserverClock: this.clock,\n\t\t\t})\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * When a client connects to the room, add them to the list of clients and then merge the history\n\t * down into the snapshots.\n\t *\n\t * @internal\n\t */\n\thandleNewSession(opts: {\n\t\tsessionId: string\n\t\tsocket: TLRoomSocket<R>\n\t\tmeta: SessionMeta\n\t\tisReadonly: boolean\n\t}) {\n\t\tconst { sessionId, socket, meta, isReadonly } = opts\n\t\tconst existing = this.sessions.get(sessionId)\n\t\tthis.sessions.set(sessionId, {\n\t\t\tstate: RoomSessionState.AwaitingConnectMessage,\n\t\t\tsessionId,\n\t\t\tsocket,\n\t\t\tpresenceId: existing?.presenceId ?? this.presenceType?.createId() ?? null,\n\t\t\tsessionStartTime: Date.now(),\n\t\t\tmeta,\n\t\t\tisReadonly: isReadonly ?? false,\n\t\t\t// this gets set later during handleConnectMessage\n\t\t\trequiresLegacyRejection: false,\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * When we send a diff to a client, if that client is on a lower version than us, we need to make\n\t * the diff compatible with their version. At the moment this means migrating each affected record\n\t * to the client's version and sending the whole record again. We can optimize this later by\n\t * keeping the previous versions of records around long enough to recalculate these diffs for\n\t * older client versions.\n\t */\n\tprivate migrateDiffForSession(\n\t\tserializedSchema: SerializedSchema,\n\t\tdiff: NetworkDiff<R>\n\t): Result<NetworkDiff<R>, MigrationFailureReason> {\n\t\t// TODO: optimize this by recalculating patches using the previous versions of records\n\n\t\t// when the client connects we check whether the schema is identical and make sure\n\t\t// to use the same object reference so that === works on this line\n\t\tif (serializedSchema === this.serializedSchema) {\n\t\t\treturn Result.ok(diff)\n\t\t}\n\n\t\tconst result: NetworkDiff<R> = {}\n\t\tfor (const [id, op] of Object.entries(diff)) {\n\t\t\tif (op[0] === RecordOpType.Remove) {\n\t\t\t\tresult[id] = op\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst migrationResult = this.schema.migratePersistedRecord(\n\t\t\t\tthis.getDocument(id).state,\n\t\t\t\tserializedSchema,\n\t\t\t\t'down'\n\t\t\t)\n\n\t\t\tif (migrationResult.type === 'error') {\n\t\t\t\treturn Result.err(migrationResult.reason)\n\t\t\t}\n\n\t\t\tresult[id] = [RecordOpType.Put, migrationResult.value]\n\t\t}\n\n\t\treturn Result.ok(result)\n\t}\n\n\t/**\n\t * When the server receives a message from the clients Currently, supports connect and patches.\n\t * Invalid messages types throws an error. Currently, doesn't validate data.\n\t *\n\t * @param sessionId - The session that sent the message\n\t * @param message - The message that was sent\n\t */\n\tasync handleMessage(sessionId: string, message: TLSocketClientSentEvent<R>) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Received message from unknown session')\n\t\t\treturn\n\t\t}\n\t\tswitch (message.type) {\n\t\t\tcase 'connect': {\n\t\t\t\treturn this.handleConnectRequest(session, message)\n\t\t\t}\n\t\t\tcase 'push': {\n\t\t\t\treturn this.handlePushRequest(session, message)\n\t\t\t}\n\t\t\tcase 'ping': {\n\t\t\t\tif (session.state === RoomSessionState.Connected) {\n\t\t\t\t\tsession.lastInteractionTime = Date.now()\n\t\t\t\t}\n\t\t\t\treturn this.sendMessage(session.sessionId, { type: 'pong' })\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\texhaustiveSwitchError(message)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** If the client is out of date, or we are out of date, we need to let them know */\n\trejectSession(sessionId: string, fatalReason?: TLSyncErrorCloseEventReason | string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) return\n\t\tif (!fatalReason) {\n\t\t\tthis.removeSession(sessionId)\n\t\t\treturn\n\t\t}\n\t\tif (session.requiresLegacyRejection) {\n\t\t\ttry {\n\t\t\t\tif (session.socket.isOpen) {\n\t\t\t\t\t// eslint-disable-next-line deprecation/deprecation\n\t\t\t\t\tlet legacyReason: TLIncompatibilityReason\n\t\t\t\t\tswitch (fatalReason) {\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.CLIENT_TOO_OLD:\n\t\t\t\t\t\t\t// eslint-disable-next-line deprecation/deprecation\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.ClientTooOld\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.SERVER_TOO_OLD:\n\t\t\t\t\t\t\t// eslint-disable-next-line deprecation/deprecation\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.ServerTooOld\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.INVALID_RECORD:\n\t\t\t\t\t\t\t// eslint-disable-next-line deprecation/deprecation\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.InvalidRecord\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// eslint-disable-next-line deprecation/deprecation\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.InvalidOperation\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tsession.socket.sendMessage({\n\t\t\t\t\t\ttype: 'incompatibility_error',\n\t\t\t\t\t\treason: legacyReason,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// noop\n\t\t\t} finally {\n\t\t\t\tthis.removeSession(sessionId)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.removeSession(sessionId, fatalReason)\n\t\t}\n\t}\n\n\tprivate handleConnectRequest(\n\t\tsession: RoomSession<R, SessionMeta>,\n\t\tmessage: Extract<TLSocketClientSentEvent<R>, { type: 'connect' }>\n\t) {\n\t\t// if the protocol versions don't match, disconnect the client\n\t\t// we will eventually want to try to make our protocol backwards compatible to some degree\n\t\t// and have a MIN_PROTOCOL_VERSION constant that the TLSyncRoom implements support for\n\t\tlet theirProtocolVersion = message.protocolVersion\n\t\t// 5 is the same as 6\n\t\tif (theirProtocolVersion === 5) {\n\t\t\ttheirProtocolVersion = 6\n\t\t}\n\t\t// 6 is almost the same as 7\n\t\tsession.requiresLegacyRejection = theirProtocolVersion === 6\n\t\tif (theirProtocolVersion === 6) {\n\t\t\ttheirProtocolVersion++\n\t\t}\n\t\tif (theirProtocolVersion == null || theirProtocolVersion < getTlsyncProtocolVersion()) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t} else if (theirProtocolVersion > getTlsyncProtocolVersion()) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.SERVER_TOO_OLD)\n\t\t\treturn\n\t\t}\n\t\t// If the client's store is at a different version to ours, it could cause corruption.\n\t\t// We should disconnect the client and ask them to refresh.\n\t\tif (message.schema == null) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t}\n\t\tconst migrations = this.schema.getMigrationsSince(message.schema)\n\t\t// if the client's store is at a different version to ours, we can't support them\n\t\tif (!migrations.ok || migrations.value.some((m) => m.scope === 'store' || !m.down)) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t}\n\n\t\tconst sessionSchema = isEqual(message.schema, this.serializedSchema)\n\t\t\t? this.serializedSchema\n\t\t\t: message.schema\n\n\t\tconst connect = (msg: TLSocketServerSentEvent<R>) => {\n\t\t\tthis.sessions.set(session.sessionId, {\n\t\t\t\tstate: RoomSessionState.Connected,\n\t\t\t\tsessionId: session.sessionId,\n\t\t\t\tpresenceId: session.presenceId,\n\t\t\t\tsocket: session.socket,\n\t\t\t\tserializedSchema: sessionSchema,\n\t\t\t\tlastInteractionTime: Date.now(),\n\t\t\t\tdebounceTimer: null,\n\t\t\t\toutstandingDataMessages: [],\n\t\t\t\tmeta: session.meta,\n\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\trequiresLegacyRejection: session.requiresLegacyRejection,\n\t\t\t})\n\t\t\tthis.sendMessage(session.sessionId, msg)\n\t\t}\n\n\t\ttransaction((rollback) => {\n\t\t\tif (\n\t\t\t\t// if the client requests changes since a time before we have tombstone history, send them the full state\n\t\t\t\tmessage.lastServerClock < this.tombstoneHistoryStartsAtClock ||\n\t\t\t\t// similarly, if they ask for a time we haven't reached yet, send them the full state\n\t\t\t\t// this will only happen if the DB is reset (or there is no db) and the server restarts\n\t\t\t\t// or if the server exits/crashes with unpersisted changes\n\t\t\t\tmessage.lastServerClock > this.clock\n\t\t\t) {\n\t\t\t\tconst diff: NetworkDiff<R> = {}\n\t\t\t\tfor (const [id, doc] of Object.entries(this.state.get().documents)) {\n\t\t\t\t\tif (id !== session.presenceId) {\n\t\t\t\t\t\tdiff[id] = [RecordOpType.Put, doc.state]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst migrated = this.migrateDiffForSession(sessionSchema, diff)\n\t\t\t\tif (!migrated.ok) {\n\t\t\t\t\trollback()\n\t\t\t\t\tthis.rejectSession(\n\t\t\t\t\t\tsession.sessionId,\n\t\t\t\t\t\tmigrated.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconnect({\n\t\t\t\t\ttype: 'connect',\n\t\t\t\t\tconnectRequestId: message.connectRequestId,\n\t\t\t\t\thydrationType: 'wipe_all',\n\t\t\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\t\t\tschema: this.schema.serialize(),\n\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\tdiff: migrated.value,\n\t\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// calculate the changes since the time the client last saw\n\t\t\t\tconst diff: NetworkDiff<R> = {}\n\t\t\t\tconst updatedDocs = Object.values(this.state.get().documents).filter(\n\t\t\t\t\t(doc) => doc.lastChangedClock > message.lastServerClock\n\t\t\t\t)\n\t\t\t\tconst presenceDocs = this.presenceType\n\t\t\t\t\t? Object.values(this.state.get().documents).filter(\n\t\t\t\t\t\t\t(doc) =>\n\t\t\t\t\t\t\t\tthis.presenceType!.typeName === doc.state.typeName &&\n\t\t\t\t\t\t\t\tdoc.state.id !== session.presenceId\n\t\t\t\t\t\t)\n\t\t\t\t\t: []\n\t\t\t\tconst deletedDocsIds = Object.entries(this.state.get().tombstones)\n\t\t\t\t\t.filter(([_id, deletedAtClock]) => deletedAtClock > message.lastServerClock)\n\t\t\t\t\t.map(([id]) => id)\n\n\t\t\t\tfor (const doc of updatedDocs) {\n\t\t\t\t\tdiff[doc.state.id] = [RecordOpType.Put, doc.state]\n\t\t\t\t}\n\t\t\t\tfor (const doc of presenceDocs) {\n\t\t\t\t\tdiff[doc.state.id] = [RecordOpType.Put, doc.state]\n\t\t\t\t}\n\n\t\t\t\tfor (const docId of deletedDocsIds) {\n\t\t\t\t\tdiff[docId] = [RecordOpType.Remove]\n\t\t\t\t}\n\t\t\t\tconst migrated = this.migrateDiffForSession(sessionSchema, diff)\n\t\t\t\tif (!migrated.ok) {\n\t\t\t\t\trollback()\n\t\t\t\t\tthis.rejectSession(\n\t\t\t\t\t\tsession.sessionId,\n\t\t\t\t\t\tmigrated.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconnect({\n\t\t\t\t\ttype: 'connect',\n\t\t\t\t\tconnectRequestId: message.connectRequestId,\n\t\t\t\t\thydrationType: 'wipe_presence',\n\t\t\t\t\tschema: this.schema.serialize(),\n\t\t\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\tdiff: migrated.value,\n\t\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate handlePushRequest(\n\t\tsession: RoomSession<R, SessionMeta> | null,\n\t\tmessage: Extract<TLSocketClientSentEvent<R>, { type: 'push' }>\n\t) {\n\t\t// We must be connected to handle push requests\n\t\tif (session && session.state !== RoomSessionState.Connected) {\n\t\t\treturn\n\t\t}\n\n\t\t// update the last interaction time\n\t\tif (session) {\n\t\t\tsession.lastInteractionTime = Date.now()\n\t\t}\n\n\t\t// increment the clock for this push\n\t\tthis.clock++\n\n\t\tconst initialDocumentClock = this.documentClock\n\t\ttransaction((rollback) => {\n\t\t\t// collect actual ops that resulted from the push\n\t\t\t// these will be broadcast to other users\n\t\t\tinterface ActualChanges {\n\t\t\t\tdiff: NetworkDiff<R> | null\n\t\t\t}\n\t\t\tconst docChanges: ActualChanges = { diff: null }\n\t\t\tconst presenceChanges: ActualChanges = { diff: null }\n\n\t\t\tconst propagateOp = (changes: ActualChanges, id: string, op: RecordOp<R>) => {\n\t\t\t\tif (!changes.diff) changes.diff = {}\n\t\t\t\tchanges.diff[id] = op\n\t\t\t}\n\n\t\t\tconst fail = (\n\t\t\t\treason: TLSyncErrorCloseEventReason,\n\t\t\t\tunderlyingError?: Error\n\t\t\t): Result<void, void> => {\n\t\t\t\trollback()\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.rejectSession(session.sessionId, reason)\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('failed to apply changes: ' + reason, underlyingError)\n\t\t\t\t}\n\t\t\t\tif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n\t\t\t\t\tthis.log?.error?.('failed to apply push', reason, message, underlyingError)\n\t\t\t\t}\n\t\t\t\treturn Result.err(undefined)\n\t\t\t}\n\n\t\t\tconst addDocument = (changes: ActualChanges, id: string, _state: R): Result<void, void> => {\n\t\t\t\tconst res = session\n\t\t\t\t\t? this.schema.migratePersistedRecord(_state, session.serializedSchema, 'up')\n\t\t\t\t\t: { type: 'success' as const, value: _state }\n\t\t\t\tif (res.type === 'error') {\n\t\t\t\t\treturn fail(\n\t\t\t\t\t\tres.reason === MigrationFailureReason.TargetVersionTooOld // target version is our version\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tconst { value: state } = res\n\n\t\t\t\t// Get the existing document, if any\n\t\t\t\tconst doc = this.getDocument(id)\n\n\t\t\t\tif (doc) {\n\t\t\t\t\t// If there's an existing document, replace it with the new state\n\t\t\t\t\t// but propagate a diff rather than the entire value\n\t\t\t\t\tconst diff = doc.replaceState(state, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, if we don't already have a document with this id\n\t\t\t\t\t// create the document and propagate the put op\n\t\t\t\t\tconst result = this.addDocument(id, state, this.clock)\n\t\t\t\t\tif (!result.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Put, state])\n\t\t\t\t}\n\n\t\t\t\treturn Result.ok(undefined)\n\t\t\t}\n\n\t\t\tconst patchDocument = (\n\t\t\t\tchanges: ActualChanges,\n\t\t\t\tid: string,\n\t\t\t\tpatch: ObjectDiff\n\t\t\t): Result<void, void> => {\n\t\t\t\t// if it was already deleted, there's no need to apply the patch\n\t\t\t\tconst doc = this.getDocument(id)\n\t\t\t\tif (!doc) return Result.ok(undefined)\n\t\t\t\t// If the client's version of the record is older than ours,\n\t\t\t\t// we apply the patch to the downgraded version of the record\n\t\t\t\tconst downgraded = session\n\t\t\t\t\t? this.schema.migratePersistedRecord(doc.state, session.serializedSchema, 'down')\n\t\t\t\t\t: { type: 'success' as const, value: doc.state }\n\t\t\t\tif (downgraded.type === 'error') {\n\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\t\t}\n\n\t\t\t\tif (downgraded.value === doc.state) {\n\t\t\t\t\t// If the versions are compatible, apply the patch and propagate the patch op\n\t\t\t\t\tconst diff = doc.mergeDiff(patch, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// need to apply the patch to the downgraded version and then upgrade it\n\n\t\t\t\t\t// apply the patch to the downgraded version\n\t\t\t\t\tconst patched = applyObjectDiff(downgraded.value, patch)\n\t\t\t\t\t// then upgrade the patched version and use that as the new state\n\t\t\t\t\tconst upgraded = session\n\t\t\t\t\t\t? this.schema.migratePersistedRecord(patched, session.serializedSchema, 'up')\n\t\t\t\t\t\t: { type: 'success' as const, value: patched }\n\t\t\t\t\t// If the client's version is too old, we'll hit an error\n\t\t\t\t\tif (upgraded.type === 'error') {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\t\t\t}\n\t\t\t\t\t// replace the state with the upgraded version and propagate the patch op\n\t\t\t\t\tconst diff = doc.replaceState(upgraded.value, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Result.ok(undefined)\n\t\t\t}\n\n\t\t\tconst { clientClock } = message\n\n\t\t\tif (this.presenceType && session?.presenceId && 'presence' in message && message.presence) {\n\t\t\t\tif (!session) throw new Error('session is required for presence pushes')\n\t\t\t\t// The push request was for the presence scope.\n\t\t\t\tconst id = session.presenceId\n\t\t\t\tconst [type, val] = message.presence\n\t\t\t\tconst { typeName } = this.presenceType\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase RecordOpType.Put: {\n\t\t\t\t\t\t// Try to put the document. If it fails, stop here.\n\t\t\t\t\t\tconst res = addDocument(presenceChanges, id, { ...val, id, typeName })\n\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase RecordOpType.Patch: {\n\t\t\t\t\t\t// Try to patch the document. If it fails, stop here.\n\t\t\t\t\t\tconst res = patchDocument(presenceChanges, id, {\n\t\t\t\t\t\t\t...val,\n\t\t\t\t\t\t\tid: [ValueOpType.Put, id],\n\t\t\t\t\t\t\ttypeName: [ValueOpType.Put, typeName],\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (message.diff && !session?.isReadonly) {\n\t\t\t\t// The push request was for the document scope.\n\t\t\t\tfor (const [id, op] of Object.entries(message.diff!)) {\n\t\t\t\t\tswitch (op[0]) {\n\t\t\t\t\t\tcase RecordOpType.Put: {\n\t\t\t\t\t\t\t// Try to add the document.\n\t\t\t\t\t\t\t// If we're putting a record with a type that we don't recognize, fail\n\t\t\t\t\t\t\tif (!this.documentTypes.has(op[1].typeName)) {\n\t\t\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst res = addDocument(docChanges, id, op[1])\n\t\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RecordOpType.Patch: {\n\t\t\t\t\t\t\t// Try to patch the document. If it fails, stop here.\n\t\t\t\t\t\t\tconst res = patchDocument(docChanges, id, op[1])\n\t\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RecordOpType.Remove: {\n\t\t\t\t\t\t\tconst doc = this.getDocument(id)\n\t\t\t\t\t\t\tif (!doc) {\n\t\t\t\t\t\t\t\t// If the doc was already deleted, don't do anything, no need to propagate a delete op\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Delete the document and propagate the delete op\n\t\t\t\t\t\t\tthis.removeDocument(id, this.clock)\n\t\t\t\t\t\t\t// Schedule a pruneTombstones call to happen on the next call stack\n\t\t\t\t\t\t\tsetTimeout(this.pruneTombstones, 0)\n\t\t\t\t\t\t\tpropagateOp(docChanges, id, op)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Let the client know what action to take based on the results of the push\n\t\t\tif (\n\t\t\t\t// if there was only a presence push, the client doesn't need to do anything aside from\n\t\t\t\t// shift the push request.\n\t\t\t\t!message.diff ||\n\t\t\t\tisEqual(docChanges.diff, message.diff)\n\t\t\t) {\n\t\t\t\t// COMMIT\n\t\t\t\t// Applying the client's changes had the exact same effect on the server as\n\t\t\t\t// they had on the client, so the client should keep the diff\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: 'commit',\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else if (!docChanges.diff) {\n\t\t\t\t// DISCARD\n\t\t\t\t// Applying the client's changes had no effect, so the client should drop the diff\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: 'discard',\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// REBASE\n\t\t\t\t// Applying the client's changes had a different non-empty effect on the server,\n\t\t\t\t// so the client should rebase with our gold-standard / authoritative diff.\n\t\t\t\t// First we need to migrate the diff to the client's version\n\t\t\t\tif (session) {\n\t\t\t\t\tconst migrateResult = this.migrateDiffForSession(\n\t\t\t\t\t\tsession.serializedSchema,\n\t\t\t\t\t\tdocChanges.diff\n\t\t\t\t\t)\n\t\t\t\t\tif (!migrateResult.ok) {\n\t\t\t\t\t\treturn fail(\n\t\t\t\t\t\t\tmigrateResult.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\t// If the migration worked, send the rebased diff to the client\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: { rebaseWithDiff: migrateResult.value },\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there are merged changes, broadcast them to all other clients\n\t\t\tif (docChanges.diff || presenceChanges.diff) {\n\t\t\t\tthis.broadcastPatch({\n\t\t\t\t\tsourceSessionId: session?.sessionId,\n\t\t\t\t\tdiff: {\n\t\t\t\t\t\t...docChanges.diff,\n\t\t\t\t\t\t...presenceChanges.diff,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (docChanges.diff) {\n\t\t\t\tthis.documentClock = this.clock\n\t\t\t}\n\n\t\t\treturn\n\t\t})\n\n\t\t// if it threw the changes will have been rolled back and the document clock will not have been incremented\n\t\tif (this.documentClock !== initialDocumentClock) {\n\t\t\tthis.onDataChange?.()\n\t\t}\n\t}\n\n\t/**\n\t * Handle the event when a client disconnects.\n\t *\n\t * @param sessionId - The session that disconnected.\n\t */\n\thandleClose(sessionId: string) {\n\t\tthis.cancelSession(sessionId)\n\t}\n\n\t/**\n\t * Allow applying changes to the store in a transactional way.\n\t * @param updater - A function that will be called with a store object that can be used to make changes.\n\t * @returns A promise that resolves when the transaction is complete.\n\t */\n\tasync updateStore(updater: (store: RoomStoreMethods<R>) => void | Promise<void>) {\n\t\tif (this._isClosed) {\n\t\t\tthrow new Error('Cannot update store on a closed room')\n\t\t}\n\t\tconst context = new StoreUpdateContext<R>(\n\t\t\tObject.fromEntries(this.getSnapshot().documents.map((d) => [d.state.id, d.state]))\n\t\t)\n\t\ttry {\n\t\t\tawait updater(context)\n\t\t} finally {\n\t\t\tcontext.close()\n\t\t}\n\n\t\tconst diff = context.toDiff()\n\t\tif (Object.keys(diff).length === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.handlePushRequest(null, { type: 'push', diff, clientClock: 0 })\n\t}\n}\n\n/**\n * @public\n */\nexport interface RoomStoreMethods<R extends UnknownRecord = UnknownRecord> {\n\tput(record: R): void\n\tdelete(recordOrId: R | string): void\n\tget(id: string): R | null\n\tgetAll(): R[]\n}\n\nclass StoreUpdateContext<R extends UnknownRecord> implements RoomStoreMethods<R> {\n\tconstructor(private readonly snapshot: Record<string, UnknownRecord>) {}\n\tprivate readonly updates = {\n\t\tputs: {} as Record<string, UnknownRecord>,\n\t\tdeletes: new Set<string>(),\n\t}\n\tput(record: R): void {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tif (record.id in this.snapshot && isEqual(this.snapshot[record.id], record)) {\n\t\t\tdelete this.updates.puts[record.id]\n\t\t} else {\n\t\t\tthis.updates.puts[record.id] = structuredClone(record)\n\t\t}\n\t\tthis.updates.deletes.delete(record.id)\n\t}\n\tdelete(recordOrId: R | string): void {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tconst id = typeof recordOrId === 'string' ? recordOrId : recordOrId.id\n\t\tdelete this.updates.puts[id]\n\t\tif (this.snapshot[id]) {\n\t\t\tthis.updates.deletes.add(id)\n\t\t}\n\t}\n\tget(id: string): R | null {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tif (hasOwnProperty(this.updates.puts, id)) {\n\t\t\treturn structuredClone(this.updates.puts[id]) as R\n\t\t}\n\t\tif (this.updates.deletes.has(id)) {\n\t\t\treturn null\n\t\t}\n\t\treturn structuredClone(this.snapshot[id] ?? null) as R\n\t}\n\n\tgetAll(): R[] {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tconst result = Object.values(this.updates.puts)\n\t\tfor (const [id, record] of Object.entries(this.snapshot)) {\n\t\t\tif (!this.updates.deletes.has(id) && !hasOwnProperty(this.updates.puts, id)) {\n\t\t\t\tresult.push(record)\n\t\t\t}\n\t\t}\n\t\treturn structuredClone(result) as R[]\n\t}\n\n\ttoDiff(): NetworkDiff<any> {\n\t\tconst diff: NetworkDiff<R> = {}\n\t\tfor (const [id, record] of Object.entries(this.updates.puts)) {\n\t\t\tdiff[id] = [RecordOpType.Put, record as R]\n\t\t}\n\t\tfor (const id of this.updates.deletes) {\n\t\t\tdiff[id] = [RecordOpType.Remove]\n\t\t}\n\t\treturn diff\n\t}\n\n\tprivate _isClosed = false\n\tclose() {\n\t\tthis._isClosed = true\n\t}\n}\n", "export let createNanoEvents = () => ({\n  events: {},\n  emit(event, ...args) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i](...args)\n    }\n  },\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": "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",
  "names": ["debounce", "result", "throttle", "require_lodash", "array", "object", "hasOwnProperty", "Map", "Set", "entry", "computed", "noop", "require_lodash", "array", "n", "object", "hasOwnProperty", "Buffer", "Symbol", "Uint8Array", "DataView", "Map", "Promise", "Set", "WeakMap", "entry", "othValue", "isEqual", "Router", "base", "routes", "other", "__proto__", "Proxy", "get", "target", "prop", "receiver", "path", "route", "handlers", "push", "toUpperCase", "RegExp", "replace", "async", "request", "args", "response", "match", "url", "URL", "query", "k", "v", "searchParams", "concat", "t", "handler", "before", "proxy", "outer", "method", "regex", "pathname", "params", "groups", "err", "catch", "finally", "createResponse", "format", "transform", "body", "options", "Response", "headers", "set", "json", "JSON", "stringify", "getMessage", "code", "error", "a", "b", "Error", "message", "status", "withParams", "obj", "bind", "AutoRouter", "missing", "f", "r", "text", "createResponse", "String", "html", "jpeg", "png", "webp", "cors", "options", "origin", "credentials", "allowMethods", "allowHeaders", "exposeHeaders", "maxAge", "getAccessControlOrigin", "request", "requestOrigin", "headers", "get", "RegExp", "test", "Array", "isArray", "includes", "Function", "appendHeadersAndReturn", "response", "key", "value", "Object", "entries", "append", "corsify", "status", "clone", "preflight", "method", "Response", "join", "object", "a", "f", "import_lodash", "object", "object", "a", "integer", "n", "n", "a", "n", "a", "global", "p", "n", "inst", "atom", "c", "r", "reactors", "isUninitialized", "data", "r", "import_lodash", "r", "process", "n", "MigrationFailureReason", "schema", "import_lodash", "import_lodash", "isEqual", "object", "object", "number", "key", "value", "error", "n", "uniqueId", "a", "r", "result", "r", "document", "sortByIndex", "a", "Versions", "Versions", "Versions", "Versions", "Versions", "Versions", "Versions", "y", "Versions", "Versions", "Versions", "Versions", "import_lodash", "t", "r", "isEqual", "a", "import_lodash", "throttle"]
}
